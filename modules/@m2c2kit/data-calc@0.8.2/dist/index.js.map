{"version":3,"file":"index.js","sources":["../src/M2Error.ts","../src/DataCalc.ts","../src/SummarizeOperations.ts","../src/index.ts"],"sourcesContent":["/**\n * Custom error class for m2c2kit errors.\n *\n * @remarks This is the same class as in the m2c2kit core package. This simple\n * code is copied from that package to avoid taking a dependency on it.\n */\nexport class M2Error extends Error {\n  constructor(...params: string[]) {\n    super(...params);\n    this.name = \"M2Error\";\n    // Set the prototype explicitly to ensure prototype chain is correct.\n    Object.setPrototypeOf(this, M2Error.prototype);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, M2Error);\n    }\n  }\n}\n","import { DataCalcOptions } from \"./DataCalcOptions\";\nimport { DataValue } from \"./DataValue\";\nimport { M2Error } from \"./M2Error\";\nimport { Mutations } from \"./Mutations\";\nimport { Observation } from \"./Observation\";\nimport { SummarizeOperation } from \"./SummarizeOperation\";\n\nexport class DataCalc {\n  private _observations: Array<Observation>;\n  private _groups = new Array<string>();\n\n  /**\n   * A class for transformation and calculation of m2c2kit data.\n   *\n   * @remarks The purpose is to provide a simple and intuitive interface for\n   * assessments to score and summarize their own data. It is not meant for\n   * data analysis or statistical modeling. The idiomatic approach is based on the\n   * dplyr R package.\n   *\n   * @param data - An array of observations, where each observation is a set of\n   * key-value pairs of variable names and values.\n   * @param options - Options, such as groups to group the data by\n   * @example\n   * ```js\n   * const dc = new DataCalc(gameData.trials);\n   * const mean_response_time_correct_trials = dc\n   *  .filter((obs) => obs.correct_response_index === obs.user_response_index)\n   *  .summarize({ mean_rt: mean(\"response_time_duration_ms\") })\n   *  .pull(\"mean_rt\");\n   * ```\n   */\n  constructor(data: Array<Observation>, options?: DataCalcOptions) {\n    // Validate that data is an array\n    if (!Array.isArray(data)) {\n      throw new M2Error(\n        \"DataCalc constructor expects an array of observations as first argument\",\n      );\n    }\n\n    // Validate that all elements in the array are objects (Observations)\n    for (let i = 0; i < data.length; i++) {\n      if (\n        data[i] === null ||\n        typeof data[i] !== \"object\" ||\n        Array.isArray(data[i])\n      ) {\n        throw new M2Error(\n          `DataCalc constructor expects all elements to be objects (observations). Element at index ${i} is ${typeof data[i]}. Element: ${JSON.stringify(data[i])}`,\n        );\n      }\n    }\n\n    this._observations = this.deepCopy(data);\n\n    // Collect all unique variable names across observations\n    const allVariables = new Set<string>();\n    for (const observation of data) {\n      for (const key of Object.keys(observation)) {\n        allVariables.add(key);\n      }\n    }\n\n    // Ensure all observations have all variables, and assign null if missing\n    for (const observation of this._observations) {\n      for (const variable of allVariables) {\n        if (!(variable in observation)) {\n          observation[variable] = null;\n        }\n      }\n    }\n\n    if (options?.groups) {\n      this._groups = Array.from(options.groups);\n    }\n  }\n\n  /**\n   * Returns the groups in the data.\n   */\n  get groups() {\n    return this._groups;\n  }\n\n  /**\n   * Returns the observations in the data.\n   *\n   * @remarks An observation is conceptually similar to a row in a dataset,\n   * where the keys are the variable names and the values are the variable values.\n   */\n  get observations() {\n    return this._observations;\n  }\n\n  /**\n   * Alias for the observations property.\n   */\n  get rows() {\n    return this._observations;\n  }\n\n  /**\n   * Returns a single variable from the data.\n   *\n   * @remarks If the variable length is 1, the value is returned. If the\n   * variable has length > 1, an array of values is returned.\n   *\n   * @param variable - Name of variable to pull from the data\n   * @returns the value of the variable\n   *\n   * @example\n   * ```js\n   * const d = [{ a: 1, b: 2, c: 3 }];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.pull(\"c\")\n   * ); // 3\n   * ```\n   */\n  pull(variable: string): DataValue | DataValue[] {\n    if (this._observations.length === 0) {\n      // Instead of throwing an error, we return null and log a warning. When\n      // filtering datasets, it is common to end up with no observations. Thus,\n      // throwing an error would be too disruptive.\n      console.warn(\n        `DataCalc.pull(): No observations available to pull variable \"${variable}\" from. Returning null.`,\n      );\n      return null;\n    }\n    this.verifyObservationsContainVariable(variable);\n    const values = this._observations.map((o) => o[variable]);\n    if (values.length === 1) {\n      return values[0];\n    }\n    return values;\n  }\n\n  /**\n   * Returns the number of observations in the data.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.length\n   * ); // 2\n   * ```\n   */\n  get length() {\n    return this._observations.length;\n  }\n\n  /**\n   * Filters observations based on a predicate function.\n   *\n   * @param predicate - A function that returns true for observations to keep and\n   * false for observations to discard\n   * @returns A new `DataCalc` object with only the observations that pass the\n   * predicate function\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.filter((obs) => obs.b >= 3).observations);\n   * // [ { a: 0, b: 8, c: 3 }, { a: 9, b: 4, c: 7 } ]\n   * ```\n   */\n  filter(predicate: (observation: Observation) => boolean) {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `filter() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \",\n        )}. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    return new DataCalc(\n      this._observations.filter(\n        predicate as (observation: Observation) => boolean,\n      ),\n      { groups: this._groups },\n    );\n  }\n\n  /**\n   * Groups observations by one or more variables.\n   *\n   * @remarks This is used with the `summarize()` method to calculate summaries\n   * by group.\n   *\n   * @param groups - variable names to group by\n   * @returns A new `DataCalc` object with the observations grouped by one or\n   * more variables\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   *   { a: 5, b: 0, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * const grouped = dc.groupBy(\"c\");\n   * // subsequent summarize operations will be performed separately by\n   * // each unique level of c, in this case, 3 and 7\n   * ```\n   */\n  groupBy(...groups: Array<string>): DataCalc {\n    groups.forEach((group) => {\n      this.verifyObservationsContainVariable(group);\n    });\n    return new DataCalc(this._observations, { groups });\n  }\n\n  /**\n   * Ungroups observations.\n   *\n   * @returns A new DataCalc object with the observations ungrouped\n   */\n  ungroup(): DataCalc {\n    return new DataCalc(this._observations);\n  }\n\n  /**\n   * Adds new variables to the observations based on the provided mutation options.\n   *\n   * @param mutations - An object where the keys are the names of the new variables\n   * and the values are functions that take an observation and return the value\n   * for the new variable.\n   * @returns A new DataCalc object with the new variables added to the observations.\n   *\n   * @example\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.mutate({ doubledA: (obs) => obs.a * 2 }).observations\n   * );\n   * // [ { a: 1, b: 2, c: 3, doubledA: 2 },\n   * //   { a: 0, b: 8, c: 3, doubledA: 0 },\n   * //   { a: 9, b: 4, c: 7, doubledA: 18 } ]\n   */\n  mutate(mutations: Mutations): DataCalc {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `mutate() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \",\n        )}. Ungroup the data first using ungroup().`,\n      );\n    }\n    const newObservations = this._observations.map((observation) => {\n      let newObservation = { ...observation };\n      for (const [newVariable, transformFunction] of Object.entries(\n        mutations,\n      )) {\n        newObservation = {\n          ...newObservation,\n          [newVariable]: transformFunction(observation),\n        };\n      }\n      return newObservation;\n    });\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n\n  /**\n   * Calculates summaries of the data.\n   *\n   * @param summarizations - An object where the keys are the names of the new\n   * variables and the values are `DataCalc` summary functions: `sum()`,\n   * `mean()`, `median()`, `variance()`, `sd()`, `min()`, `max()`, or `n()`.\n   * The summary functions take a variable name as a string, or alternatively,\n   * a value or array of values to summarize.\n   * @returns A new `DataCalc` object with the new summary variables.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   *   { a: 5, b: 0, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.summarize({\n   *     meanA: mean(\"a\"),\n   *     varA: variance(\"a\"),\n   *     totalB: sum(\"b\")\n   *   }).observations\n   * );\n   * // [ { meanA: 3.75, varA: 16.916666666666668, totalB: 14 } ]\n   *\n   * console.log(\n   *   dc.summarize({\n   *    filteredTotalC: sum(dc.filter(obs => obs.b > 2).pull(\"c\"))\n   *  }).observations\n   * );\n   * // [ { filteredTotalC: 10 } ]\n   * ```\n   */\n  summarize(summarizations: {\n    [newVariable: string]: SummarizeOperation | DataValue;\n  }): DataCalc {\n    if (this._groups.length === 0) {\n      const obs: Observation = {};\n      for (const [newVariable, value] of Object.entries(summarizations)) {\n        // Check if the value is a SummarizeOperation\n        if (\n          typeof value === \"object\" &&\n          value !== null &&\n          \"summarizeFunction\" in value\n        ) {\n          // It's a SummarizeOperation\n          const summarizeOperation = value as SummarizeOperation;\n          obs[newVariable] = summarizeOperation.summarizeFunction(\n            this,\n            summarizeOperation.parameters,\n            summarizeOperation.options,\n          );\n        } else {\n          // It's a direct value\n          obs[newVariable] = value;\n        }\n      }\n      return new DataCalc([obs], { groups: this._groups });\n    }\n\n    // Optimized implementation of groupBy summarization\n    return this.summarizeByGroups(summarizations);\n  }\n\n  private summarizeByGroups(summarizations: {\n    [newVariable: string]: SummarizeOperation | DataValue;\n  }): DataCalc {\n    const groupMap = new Map<string, Array<Observation>>();\n\n    this._observations.forEach((obs) => {\n      const groupKey = this._groups\n        .map((g) =>\n          typeof obs[g] === \"object\" ? JSON.stringify(obs[g]) : obs[g],\n        )\n        .join(\"|\");\n\n      if (!groupMap.has(groupKey)) {\n        groupMap.set(groupKey, []);\n      }\n      const groupArray = groupMap.get(groupKey);\n      if (groupArray) {\n        groupArray.push(obs);\n      } else {\n        // This should never happen due to the check above, but handles the case safely\n        groupMap.set(groupKey, [obs]);\n      }\n    });\n\n    const summarizedObservations: Array<Observation> = [];\n    groupMap.forEach((groupObs, groupKey) => {\n      const groupValues = groupKey.split(\"|\");\n      // Use first observation to determine original types\n      const firstObs = groupObs[0];\n\n      // Create summary object with group identifiers\n      const summaryObj: Observation = {};\n      this._groups.forEach((group, i) => {\n        // Get original value as string\n        const valueStr = groupValues[i];\n        const originalType = typeof firstObs[group];\n\n        if (originalType === \"number\") {\n          summaryObj[group] = Number(valueStr);\n        } else if (originalType === \"boolean\") {\n          summaryObj[group] = valueStr === \"true\";\n        } else if (valueStr.startsWith(\"{\") || valueStr.startsWith(\"[\")) {\n          try {\n            summaryObj[group] = JSON.parse(valueStr);\n          } catch {\n            throw new M2Error(\n              `Failed to parse group value ${valueStr} as JSON for group ${group}`,\n            );\n            // alternative approach would be to swallow the error and keep as string\n            // summaryObj[group] = valueStr;\n          }\n        } else {\n          // Keep as string\n          summaryObj[group] = valueStr;\n        }\n      });\n\n      // Calculate summaries for this group\n      const groupDataCalc = new DataCalc(groupObs);\n\n      for (const [newVariable, value] of Object.entries(summarizations)) {\n        // Check if the value is a SummarizeOperation\n        if (\n          typeof value === \"object\" &&\n          value !== null &&\n          \"summarizeFunction\" in value\n        ) {\n          // It's a SummarizeOperation\n          const summarizeOperation = value as SummarizeOperation;\n          summaryObj[newVariable] = summarizeOperation.summarizeFunction(\n            groupDataCalc,\n            summarizeOperation.parameters,\n            summarizeOperation.options,\n          );\n        } else {\n          // It's a direct value\n          summaryObj[newVariable] = value;\n        }\n      }\n\n      summarizedObservations.push(summaryObj);\n    });\n\n    return new DataCalc(summarizedObservations, { groups: this._groups });\n  }\n\n  /**\n   * Selects specific variables to keep in the dataset.\n   * Variables prefixed with \"-\" will be excluded from the result.\n   *\n   * @param variables - Names of variables to select; prefix with '-' to exclude instead\n   * @returns A new DataCalc object with only the selected variables (minus excluded ones)\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3, d: 4 },\n   *   { a: 5, b: 6, c: 7, d: 8 }\n   * ];\n   * const dc = new DataCalc(d);\n   * // Keep a and c\n   * console.log(dc.select(\"a\", \"c\").observations);\n   * // [ { a: 1, c: 3 }, { a: 5, c: 7 } ]\n   * ```\n   */\n  select(...variables: string[]): DataCalc {\n    const includeVars: string[] = [];\n    const excludeVars: string[] = [];\n\n    variables.forEach((variable) => {\n      if (variable.startsWith(\"-\")) {\n        excludeVars.push(variable.substring(1));\n      } else {\n        includeVars.push(variable);\n      }\n    });\n\n    // Check if we have any includes - if not, include all variables except excludes\n    const allVars =\n      includeVars.length > 0\n        ? includeVars\n        : Object.keys(this._observations[0] || {});\n\n    [...allVars, ...excludeVars].forEach((variable) => {\n      this.verifyObservationsContainVariable(variable);\n    });\n\n    const excludeSet = new Set(excludeVars);\n\n    // Apply selections and exclusions\n    const newObservations = this._observations.map((observation) => {\n      const newObservation: Observation = {};\n\n      // If we specified includes, only include those\n      if (includeVars.length > 0) {\n        includeVars.forEach((variable) => {\n          if (!excludeSet.has(variable)) {\n            newObservation[variable] = observation[variable];\n          }\n        });\n      } else {\n        // Otherwise include all except excluded vars\n        Object.keys(observation).forEach((key) => {\n          if (!excludeSet.has(key)) {\n            newObservation[key] = observation[key];\n          }\n        });\n      }\n\n      return newObservation;\n    });\n\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n\n  /**\n   * Arranges (sorts) the observations based on one or more variables.\n   *\n   * @param variables - Names of variables to sort by, prefixed with '-' for descending order\n   * @returns A new DataCalc object with the observations sorted\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 5, b: 2 },\n   *   { a: 3, b: 7 },\n   *   { a: 5, b: 1 }\n   * ];\n   * const dc = new DataCalc(d);\n   * // Sort by a (ascending), then by b (descending)\n   * console.log(dc.arrange(\"a\", \"-b\").observations);\n   * // [ { a: 3, b: 7 }, { a: 5, b: 2 }, { a: 5, b: 1 } ]\n   * ```\n   */\n  arrange(...variables: string[]): DataCalc {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `arrange() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \",\n        )}. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    const sortedObservations = [...this._observations].sort((a, b) => {\n      for (const variable of variables) {\n        let varName = variable;\n        let direction = 1;\n\n        if (variable.startsWith(\"-\")) {\n          varName = variable.substring(1);\n          direction = -1;\n        }\n\n        if (!(varName in a) || !(varName in b)) {\n          throw new M2Error(\n            `arrange(): variable ${varName} does not exist in all observations`,\n          );\n        }\n\n        const aVal = a[varName];\n        const bVal = b[varName];\n\n        // Handle different types\n        if (typeof aVal !== typeof bVal) {\n          return direction * (String(aVal) < String(bVal) ? -1 : 1);\n        }\n\n        if (aVal < bVal) return -1 * direction;\n        if (aVal > bVal) return 1 * direction;\n      }\n      return 0;\n    });\n\n    return new DataCalc(sortedObservations, { groups: this._groups });\n  }\n\n  /**\n   * Keeps only unique/distinct observations.\n   *\n   * @returns A new `DataCalc` object with only unique observations\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 1, b: 2, c: 3 }, // Duplicate\n   *   { a: 2, b: 3, c: 5 },\n   *   { a: 1, b: 2, c: { name: \"dog\" } },\n   *   { a: 1, b: 2, c: { name: \"dog\" } } // Duplicate with nested object\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.distinct().observations);\n   * // [ { a: 1, b: 2, c: 3 }, { a: 2, b: 3, c: 5 }, { a: 1, b: 2, c: { name: \"dog\" } } ]\n   * ```\n   */\n  distinct(): DataCalc {\n    // Consider all variables for uniqueness with stable key generation\n    const seen = new Set<string>();\n    const uniqueObs = this._observations.filter((obs) => {\n      // Create a stable string representation for comparison\n      const key = JSON.stringify(this.normalizeForComparison(obs));\n      if (seen.has(key)) return false;\n      seen.add(key);\n      return true;\n    });\n    return new DataCalc(uniqueObs, { groups: this._groups });\n  }\n\n  /**\n   * Renames variables in the observations.\n   *\n   * @param renames - Object mapping new variable names to old variable names\n   * @returns A new DataCalc object with renamed variables\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 4, b: 5, c: 6 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.rename({ x: 'a', z: 'c' }).observations);\n   * // [ { x: 1, b: 2, z: 3 }, { x: 4, b: 5, z: 6 } ]\n   * ```\n   */\n  rename(renames: { [newName: string]: string }): DataCalc {\n    if (this._observations.length === 0) {\n      throw new M2Error(\"Cannot rename variables on an empty dataset\");\n    }\n\n    Object.values(renames).forEach((oldName) => {\n      this.verifyObservationsContainVariable(oldName);\n    });\n\n    const newObservations = this._observations.map((observation) => {\n      const newObservation: Observation = {};\n\n      // Copy all properties\n      for (const [key, value] of Object.entries(observation)) {\n        // If this is a property being renamed, use the new name\n        const newKey = Object.entries(renames).find(\n          ([, old]) => old === key,\n        )?.[0];\n        if (newKey) {\n          newObservation[newKey] = value;\n        } else if (!Object.values(renames).includes(key)) {\n          // Only copy if not a renamed property\n          newObservation[key] = value;\n        }\n      }\n\n      return newObservation;\n    });\n\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n\n  /**\n   * Performs an inner join with another DataCalc object.\n   * Only rows with matching keys in both datasets are included.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.innerJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 } ]\n   * ```\n   */\n  innerJoin(other: DataCalc, by: string[]): DataCalc {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `innerJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n\n    // Create a hash map for faster joining\n    const rightMap = new Map<string, Observation[]>();\n    other.observations.forEach((obs) => {\n      // Skip observations with null join keys for matching\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(obs[k])))\n        .join(\"|\");\n\n      // Get existing matches or create new array\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n\n    const result: Observation[] = [];\n\n    // Process inner join - only include matches\n    this._observations.forEach((leftObs) => {\n      // Skip observations with null join keys for matching\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k])))\n        .join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n\n      if (rightMatches.length > 0) {\n        // We have matches, create joined rows\n        rightMatches.forEach((rightObs) => {\n          const joinedObs: Observation = { ...leftObs };\n\n          // Add right values, but don't overwrite join keys\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n\n          result.push(joinedObs);\n        });\n      }\n    });\n\n    return new DataCalc(result);\n  }\n\n  /**\n   * Performs a left join with another DataCalc object.\n   * All rows from the left dataset are included, along with matching rows from the right.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.leftJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 }, { id: 3, x: 'c' } ]\n   * ```\n   */\n  leftJoin(other: DataCalc, by: string[]): DataCalc {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `leftJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n\n    // Create a hash map for faster joining\n    const rightMap = new Map<string, Observation[]>();\n    other.observations.forEach((obs) => {\n      // Skip observations with null join keys for matching\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(obs[k])))\n        .join(\"|\");\n\n      // Get existing matches or create new array\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n\n    const result: Observation[] = [];\n\n    // Process left join - include all left rows\n    this._observations.forEach((leftObs) => {\n      // For left join, we include the left observation even if it has null join keys\n      // But it won't match with any right observation\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        result.push({ ...leftObs });\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k])))\n        .join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n\n      if (rightMatches.length > 0) {\n        // We have matches, create joined rows\n        rightMatches.forEach((rightObs) => {\n          const joinedObs: Observation = { ...leftObs };\n\n          // Add right values, but don't overwrite join keys\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n\n          result.push(joinedObs);\n        });\n      } else {\n        // No matches but include left row anyway for left join\n        result.push({ ...leftObs });\n      }\n    });\n\n    return new DataCalc(result);\n  }\n  /**\n   * Performs a right join with another DataCalc object.\n   * All rows from the right dataset are included, along with matching rows from the left.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.rightJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 }, { id: 4, y: 400 } ]\n   * ```\n   */\n  rightJoin(other: DataCalc, by: string[]): DataCalc {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `rightJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n\n    // Create a hash map for faster joining\n    const rightMap = new Map<string, Observation[]>();\n    const rightObsWithNullKeys: Observation[] = [];\n\n    other.observations.forEach((obs) => {\n      // For right join, track right observations with null keys separately\n      if (this.hasNullJoinKeys(obs, by)) {\n        rightObsWithNullKeys.push(obs);\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(obs[k])))\n        .join(\"|\");\n\n      // Get existing matches or create new array\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n\n    const result: Observation[] = [];\n    const processedRightKeys = new Set<string>();\n\n    // Process right join - include matches\n    this._observations.forEach((leftObs) => {\n      // Skip observations with null join keys for matching\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k])))\n        .join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n\n      if (rightMatches.length > 0) {\n        // We have matches, create joined rows\n        rightMatches.forEach((rightObs) => {\n          const joinedObs: Observation = { ...leftObs };\n\n          // Add right values, but don't overwrite join keys\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n\n          result.push(joinedObs);\n        });\n\n        // Mark right key as processed\n        processedRightKeys.add(key);\n      }\n    });\n\n    // Add right rows that didn't match or have null keys\n    other.observations.forEach((rightObs) => {\n      if (this.hasNullJoinKeys(rightObs, by)) {\n        // Include right observations with null keys directly\n        result.push({ ...rightObs });\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(rightObs[k])))\n        .join(\"|\");\n\n      if (!processedRightKeys.has(key)) {\n        result.push({ ...rightObs });\n        processedRightKeys.add(key);\n      }\n    });\n\n    return new DataCalc(result);\n  }\n\n  /**\n   * Performs a full join with another DataCalc object.\n   * All rows from both datasets are included.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.fullJoin(dc2, [\"id\"]).observations);\n   * // [\n   * //   { id: 1, x: 'a', y: 100 },\n   * //   { id: 2, x: 'b', y: 200 },\n   * //   { id: 3, x: 'c' },\n   * //   { id: 4, y: 400 }\n   * // ]\n   * ```\n   */\n  fullJoin(other: DataCalc, by: string[]): DataCalc {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `fullJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n\n    // Create a hash map for faster joining\n    const rightMap = new Map<string, Observation[]>();\n    const rightObsWithNullKeys: Observation[] = [];\n\n    other.observations.forEach((obs) => {\n      // For full join, track right observations with null keys separately\n      if (this.hasNullJoinKeys(obs, by)) {\n        rightObsWithNullKeys.push(obs);\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(obs[k])))\n        .join(\"|\");\n\n      // Get existing matches or create new array\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n\n    const result: Observation[] = [];\n    const processedRightKeys = new Set<string>();\n\n    // Process full join - include all rows\n    this._observations.forEach((leftObs) => {\n      // For full join, we include the left observation even if it has null join keys\n      // But it won't match with any right observation\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        result.push({ ...leftObs });\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k])))\n        .join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n\n      if (rightMatches.length > 0) {\n        // We have matches, create joined rows\n        rightMatches.forEach((rightObs) => {\n          const joinedObs: Observation = { ...leftObs };\n\n          // Add right values, but don't overwrite join keys\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n\n          result.push(joinedObs);\n        });\n\n        // Mark right key as processed\n        processedRightKeys.add(key);\n      } else {\n        // No matches but include left row anyway for full join\n        result.push({ ...leftObs });\n      }\n    });\n\n    // Add right rows that didn't match or have null keys\n    other.observations.forEach((rightObs) => {\n      if (this.hasNullJoinKeys(rightObs, by)) {\n        // Include right observations with null keys directly\n        result.push({ ...rightObs });\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(rightObs[k])))\n        .join(\"|\");\n\n      if (!processedRightKeys.has(key)) {\n        result.push({ ...rightObs });\n        processedRightKeys.add(key);\n      }\n    });\n\n    return new DataCalc(result);\n  }\n\n  /**\n   * Slice observations by position.\n   *\n   * @param start - Starting position (0-based). Negative values count from\n   * the end.\n   * @param end - Ending position (exclusive)\n   * @returns A new DataCalc object with sliced observations\n   *\n   * @remarks If `end` is not provided, it will return a single observation at\n   * `start` position. If `start` is beyond the length of observations,\n   * it will return an empty DataCalc.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2 },\n   *   { a: 3, b: 4 },\n   *   { a: 5, b: 6 },\n   *   { a: 7, b: 8 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.slice(1, 3).observations);\n   * // [ { a: 3, b: 4 }, { a: 5, b: 6 } ]\n   * console.log(dc.slice(0).observations);\n   * // [ { a: 1, b: 2 } ]\n   * ```\n   */\n  slice(start: number, end?: number): DataCalc {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `slice() cannot be used on grouped data. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    let sliced: Observation[];\n\n    if (start >= this._observations.length) {\n      // If start is beyond the length of observations, return empty DataCalc\n      return new DataCalc([], { groups: this._groups });\n    }\n    if (end === undefined) {\n      // return a single observation at start position\n      const index = start < 0 ? this._observations.length + start : start;\n      sliced = [this._observations[index]];\n    } else {\n      sliced = this._observations.slice(start, end);\n    }\n    return new DataCalc(sliced, { groups: this._groups });\n  }\n\n  /**\n   * Combines observations from two DataCalc objects by rows.\n   *\n   * @param other - The other DataCalc object to bind with\n   * @returns A new DataCalc object with combined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { a: 1, b: 2 },\n   *   { a: 3, b: 4 }\n   * ];\n   * const d2 = [\n   *   { a: 5, b: 6 },\n   *   { a: 7, b: 8 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.bindRows(dc2).observations);\n   * // [ { a: 1, b: 2 }, { a: 3, b: 4 }, { a: 5, b: 6 }, { a: 7, b: 8 } ]\n   * ```\n   */\n  bindRows(other: DataCalc): DataCalc {\n    // Check for type mismatches in common variables\n    if (this._observations.length > 0 && other.observations.length > 0) {\n      const thisVariables = new Set(Object.keys(this._observations[0]));\n      const otherVariables = new Set(Object.keys(other.observations[0]));\n\n      // Find common variables\n      const commonVariables = [...thisVariables].filter((variable) =>\n        otherVariables.has(variable),\n      );\n\n      // For each common variable, check if types match\n      commonVariables.forEach((variable) => {\n        const thisType = this.getVariableType(variable);\n        const otherType = other.getVariableType(variable);\n\n        if (thisType !== otherType) {\n          console.warn(\n            `Warning: bindRows() is combining datasets with different data types for variable '${variable}'. ` +\n              `Left dataset has type '${thisType}' and right dataset has type '${otherType}'.`,\n          );\n        }\n      });\n    }\n\n    return new DataCalc([...this._observations, ...other.observations]);\n  }\n\n  /**\n   * Helper method to determine the primary type of a variable across observations\n   * @internal\n   *\n   * @param variable - The variable name to check\n   * @returns The most common type for the variable or 'mixed' if no clear type exists\n   */\n  private getVariableType(variable: string): string {\n    if (this._observations.length === 0) {\n      return \"unknown\";\n    }\n\n    // Count occurrences of each type\n    const typeCounts: Record<string, number> = {};\n\n    this._observations.forEach((obs) => {\n      if (variable in obs) {\n        const value = obs[variable];\n        const type =\n          value === null\n            ? \"null\"\n            : Array.isArray(value)\n              ? \"array\"\n              : typeof value;\n\n        typeCounts[type] = (typeCounts[type] || 0) + 1;\n      }\n    });\n\n    // Find the most common type\n    let maxCount = 0;\n    let dominantType = \"unknown\";\n\n    for (const [type, count] of Object.entries(typeCounts)) {\n      if (count > maxCount) {\n        maxCount = count;\n        dominantType = type;\n      }\n    }\n\n    return dominantType;\n  }\n\n  /**\n   * Verifies that the variable exists in each observation in the data.\n   *\n   * @remarks Throws an error if the variable does not exist in each\n   * observation. This is not meant to be called by users of the library, but\n   * is used internally.\n   * @internal\n   *\n   * @param variable - The variable to check for\n   */\n  verifyObservationsContainVariable(variable: string): void {\n    if (!this._observations.every((observation) => variable in observation)) {\n      throw new M2Error(\n        `Variable ${variable} does not exist for each item (row) in the data array.`,\n      );\n    }\n  }\n\n  /**\n   * Checks if the variable exists for at least one observation in the data.\n   *\n   * @remarks This is not meant to be called by users of the library, but\n   * is used internally.\n   * @internal\n   *\n   * @param variable - The variable to check for\n   * @returns true if the variable exists in at least one observation, false\n   * otherwise\n   */\n  variableExists(variable: string): boolean {\n    return this._observations.some((observation) => variable in observation);\n  }\n\n  /**\n   * Checks if a value is a non-missing numeric value.\n   *\n   * @remarks A non-missing numeric value is a value that is a number and is\n   * not NaN or infinite.\n   *\n   * @param value - The value to check\n   * @returns true if the value is a non-missing numeric value, false otherwise\n   */\n  isNonMissingNumeric(value: DataValue): boolean {\n    return typeof value === \"number\" && !isNaN(value) && isFinite(value);\n  }\n\n  /**\n   * Checks if a value is a missing numeric value.\n   *\n   * @remarks A missing numeric value is a number that is NaN or infinite, or any\n   * value that is null or undefined. Thus, a null or undefined value is\n   * considered to be a missing numeric value.\n   *\n   * @param value - The value to check\n   * @returns true if the value is a missing numeric value, false otherwise\n   */\n  isMissingNumeric(value: DataValue): boolean {\n    return (\n      (typeof value === \"number\" && (isNaN(value) || !isFinite(value))) ||\n      value === null ||\n      typeof value === \"undefined\"\n    );\n  }\n\n  /**\n   * Normalizes an object for stable comparison by sorting keys\n   * @internal\n   *\n   * @remarks Normalizing is needed to handle situations where objects have the\n   * same properties but in different orders because we are using\n   * JSON.stringify() for comparison.\n   */\n  private normalizeForComparison(obj: Observation): Observation {\n    // Handle non-objects\n    if (obj === null || typeof obj !== \"object\") {\n      return obj;\n    }\n\n    // Handle arrays: sort if primitive values, otherwise normalize each item\n    if (Array.isArray(obj)) {\n      return obj.map((item) => this.normalizeForComparison(item));\n    }\n\n    // For objects: create a new object with sorted keys\n    return Object.keys(obj)\n      .sort()\n      .reduce((result: Observation, key) => {\n        result[key] = this.normalizeForComparison(obj[key]);\n        return result;\n      }, {});\n  }\n\n  /**\n   * Creates a deep copy of an object.\n   * @internal\n   *\n   * @remarks We create a deep copy of the object, in our case an instance\n   * of `DataCalc`, to ensure that we are working with a new object\n   * without any references to the original object. This is important\n   * to avoid unintended side effects when modifying an object.\n   *\n   * @param source - object to copy\n   * @param map - map of objects that have already been copied\n   * @returns a deep copy of the object\n   */\n  private deepCopy<T>(source: T, map = new WeakMap()): T {\n    // Handle primitive values and null\n    if (source === null || typeof source !== \"object\") {\n      return source;\n    }\n\n    // Handle circular references\n    if (map.has(source as object)) {\n      return map.get(source as object);\n    }\n\n    // Create new instance of the same type\n    const copy = Array.isArray(source)\n      ? []\n      : Object.create(Object.getPrototypeOf(source));\n\n    // Add to map before recursing to handle circular references\n    map.set(source as object, copy);\n\n    // Copy all properties\n    const keys = [\n      ...Object.getOwnPropertyNames(source),\n      ...Object.getOwnPropertySymbols(source),\n    ];\n\n    for (const key of keys) {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        source,\n        key as keyof T,\n      );\n      if (descriptor) {\n        Object.defineProperty(copy, key, {\n          ...descriptor,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          value: this.deepCopy((source as any)[key], map),\n        });\n      }\n    }\n\n    return copy;\n  }\n\n  /**\n   * Checks if an observation has null or undefined values in any of the join columns.\n   * @internal\n   *\n   * @param obs - The observation to check\n   * @param keys - The join columns to check\n   * @returns true if any join column has a null or undefined value\n   */\n  private hasNullJoinKeys(obs: Observation, keys: string[]): boolean {\n    return keys.some((key) => obs[key] === null || obs[key] === undefined);\n  }\n}\n","import { DataCalc } from \"./DataCalc\";\nimport { DataValue } from \"./DataValue\";\nimport { SummarizeOperation } from \"./SummarizeOperation\";\nimport { SummarizeFunction } from \"./SummarizeFunction\";\nimport { SummarizeOptions } from \"./SummarizeOptions\";\nimport { M2Error } from \"./M2Error\";\n\n/**\n * Default options for summarize operations\n */\nconst DEFAULT_SUMMARIZE_OPTIONS: SummarizeOptions = {\n  coerceBooleans: true,\n  skipMissing: false,\n} as const;\n\n/**\n * Applies default options to user-provided options\n *\n * @param options - User provided options (may be undefined)\n * @returns Options with defaults applied\n */\nfunction applyDefaultOptions(options?: SummarizeOptions): SummarizeOptions {\n  return { ...DEFAULT_SUMMARIZE_OPTIONS, ...options };\n}\n\n/**\n * Helper function to process numeric values in a variable across observations\n * Handles error checking, type coercion and missing values in a consistent way\n *\n * @param dataCalc - The DataCalc instance to process\n * @param variable - The variable name to process\n * @param options - Summarize options for the operation\n * @param collector - Function that collects values (e.g., sum, max comparison)\n * @param errorPrefix - Prefix for error messages\n * @param initialState - Initial state for the collector function\n * @returns An object containing the processed numeric values and count\n */\nfunction processNumericValues<T>(\n  dataCalc: DataCalc,\n  variable: string,\n  options: SummarizeOptions | undefined,\n  collector: (value: number, state: T) => T,\n  errorPrefix: string,\n  initialState: T,\n): { state: T; count: number; containsMissing: boolean } {\n  const mergedOptions = applyDefaultOptions(options);\n\n  dataCalc.verifyObservationsContainVariable(variable);\n\n  let count = 0;\n  let state = initialState;\n  let containsMissing = false;\n\n  dataCalc.observations.forEach((o) => {\n    if (dataCalc.isNonMissingNumeric(o[variable])) {\n      state = collector(o[variable], state);\n      count++;\n      return;\n    }\n\n    if (typeof o[variable] === \"boolean\" && mergedOptions.coerceBooleans) {\n      state = collector(o[variable] ? 1 : 0, state);\n      count++;\n      return;\n    }\n\n    if (dataCalc.isMissingNumeric(o[variable])) {\n      containsMissing = true;\n      return;\n    }\n\n    // For non-numeric, non-missing values that can't be coerced\n    throw new M2Error(\n      `${errorPrefix}: variable ${variable} has non-numeric value ${o[variable]} in this observation: ${JSON.stringify(o)}`,\n    );\n  });\n\n  return { state, count, containsMissing };\n}\n\n/**\n * Processes an array of numeric values directly rather than through a\n * variable name.\n */\nfunction processDirectValues<T>(\n  values: DataValue[],\n  options: SummarizeOptions | undefined,\n  collector: (value: number, state: T) => T,\n  errorPrefix: string,\n  initialState: T,\n): { state: T; count: number; containsMissing: boolean } {\n  const mergedOptions = applyDefaultOptions(options);\n  let state = initialState;\n  let count = 0;\n  let containsMissing = false;\n\n  for (const value of values) {\n    if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n      state = collector(value, state);\n      count++;\n    } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n      state = collector(value ? 1 : 0, state);\n      count++;\n    } else if (\n      value === null ||\n      value === undefined ||\n      (typeof value === \"number\" && (isNaN(value) || !isFinite(value)))\n    ) {\n      containsMissing = true;\n    } else {\n      throw new M2Error(`${errorPrefix}: has non-numeric value ${value}`);\n    }\n  }\n\n  return { state, count, containsMissing };\n}\n\n/**\n * Processes a single value for summarize operations rather than through a\n * variable name.\n */\nfunction processSingleValue(\n  value: DataValue,\n  options: SummarizeOptions | undefined,\n  errorPrefix: string,\n): { value: number; isMissing: boolean } {\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n    return { value, isMissing: false };\n  } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n    return { value: value ? 1 : 0, isMissing: false };\n  } else if (\n    value === null ||\n    value === undefined ||\n    (typeof value === \"number\" && (isNaN(value) || !isFinite(value)))\n  ) {\n    return { value: 0, isMissing: true };\n  } else {\n    throw new M2Error(`${errorPrefix}: has non-numeric value ${value}`);\n  }\n}\n\nconst nInternal: SummarizeFunction = (dataCalc: DataCalc): number => {\n  return dataCalc.length;\n};\n/**\n * Calculates the number of observations.\n *\n * @returns summarize operation calculating the number of observations\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     count: n()\n *   }).observations\n * );\n * // [ { count: 3 } ]\n * ```\n */\n\nexport function n(): SummarizeOperation {\n  return {\n    summarizeFunction: nInternal,\n    parameters: [],\n  };\n}\n\nconst sumInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum) => sum + value,\n      \"sum()\",\n      0,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, sum) => sum + value,\n      \"sum()\",\n      0,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"sum()\");\n\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    return result.isMissing ? null : result.value;\n  }\n};\n\n/**\n * Calculates the sum of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the sum\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     totalB: sum(\"b\")\n *   }).observations\n * );\n * // [ { totalB: 14 } ]\n * ```\n */\nexport function sum(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: sumInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst meanInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum) => sum + value,\n      \"mean()\",\n      0,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state / result.count;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, sum) => sum + value,\n      \"mean()\",\n      0,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state / result.count;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"mean()\");\n    return result.isMissing && !mergedOptions.skipMissing ? null : result.value;\n  }\n};\n/**\n * Calculates the mean of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the mean\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     meanA: mean(\"a\")\n *   }).observations\n * );\n * // [ { meanA: 3.3333333333333335 } ]\n * ```\n */\nexport function mean(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: meanInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst varianceInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n\n    // First pass: calculate mean\n    const meanResult = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum) => sum + value,\n      \"variance()\",\n      0,\n    );\n\n    if (meanResult.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (meanResult.count <= 1) {\n      return null; // Need at least two values for variance\n    }\n\n    const meanValue = meanResult.state / meanResult.count;\n\n    // Second pass: sum of squared deviations\n    const varianceResult = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum) => {\n        const actualValue =\n          typeof value === \"boolean\" && mergedOptions.coerceBooleans\n            ? value\n              ? 1\n              : 0\n            : value;\n        return sum + Math.pow(actualValue - meanValue, 2);\n      },\n      \"variance()\",\n      0,\n    );\n\n    return varianceResult.state / (meanResult.count - 1);\n  } else if (Array.isArray(variableOrValues)) {\n    // First collect valid values\n    const validValues: number[] = [];\n    let containsMissing = false;\n\n    for (const value of variableOrValues) {\n      if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n        validValues.push(value);\n      } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n        validValues.push(value ? 1 : 0);\n      } else if (\n        value === null ||\n        value === undefined ||\n        (typeof value === \"number\" && (isNaN(value) || !isFinite(value)))\n      ) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(`variance(): has non-numeric value ${value}`);\n      }\n    }\n\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (validValues.length <= 1) {\n      return null; // Need at least two values for variance\n    }\n\n    // Calculate mean\n    const sum = validValues.reduce((acc, val) => acc + val, 0);\n    const mean = sum / validValues.length;\n\n    // Calculate variance\n    const sumSquaredDiffs = validValues.reduce(\n      (acc, val) => acc + Math.pow(val - mean, 2),\n      0,\n    );\n\n    return sumSquaredDiffs / (validValues.length - 1);\n  }\n  // return null as variance requires at least 2 values\n  else {\n    return null;\n  }\n};\n\n/**\n * Calculates the variance of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the variance\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n *   { a: 5, b: 0, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     varA: variance(\"a\")\n *   }).observations\n * );\n * // [ { varA: 16.916666666666668 } ]\n * ```\n */\nexport function variance(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: varianceInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst minInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, min) =>\n        min === Number.POSITIVE_INFINITY || value < min ? value : min,\n      \"min()\",\n      Number.POSITIVE_INFINITY,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, min) =>\n        min === Number.POSITIVE_INFINITY || value < min ? value : min,\n      \"min()\",\n      Number.POSITIVE_INFINITY,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"min()\");\n\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    return result.isMissing ? null : result.value;\n  }\n};\n\n/**\n * Calculates the minimum value of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the minimum\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n *   { a: 5, b: 0, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     minA: min(\"a\")\n *   }).observations\n * );\n * // [ { minA: 0 } ]\n * ```\n */\nexport function min(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: minInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst maxInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, max) =>\n        max === Number.NEGATIVE_INFINITY || value > max ? value : max,\n      \"max()\",\n      Number.NEGATIVE_INFINITY,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, max) =>\n        max === Number.NEGATIVE_INFINITY || value > max ? value : max,\n      \"max()\",\n      Number.NEGATIVE_INFINITY,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"max()\");\n\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    return result.isMissing ? null : result.value;\n  }\n};\n\n/**\n * Calculates the maximum value of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the maximum\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n *   { a: 5, b: 0, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     maxA: max(\"a\")\n *   }).observations\n * );\n * // [ { maxA: 9 } ]\n * ```\n */\nexport function max(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: maxInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst medianInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    dataCalc.verifyObservationsContainVariable(variable);\n\n    // Collect all valid values into an array\n    const values: number[] = [];\n    let containsMissing = false;\n\n    dataCalc.observations.forEach((o) => {\n      if (dataCalc.isNonMissingNumeric(o[variable])) {\n        values.push(o[variable]);\n      } else if (\n        typeof o[variable] === \"boolean\" &&\n        mergedOptions.coerceBooleans\n      ) {\n        values.push(o[variable] ? 1 : 0);\n      } else if (dataCalc.isMissingNumeric(o[variable])) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(\n          `median(): variable ${variable} has non-numeric value ${o[variable]} in this observation: ${JSON.stringify(o)}`,\n        );\n      }\n    });\n\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (values.length === 0) {\n      return null;\n    }\n\n    values.sort((a, b) => a - b);\n    const mid = Math.floor(values.length / 2);\n\n    if (values.length % 2 === 0) {\n      return (values[mid - 1] + values[mid]) / 2;\n    } else {\n      return values[mid];\n    }\n  } else if (Array.isArray(variableOrValues)) {\n    // Collect valid values\n    const values: number[] = [];\n    let containsMissing = false;\n\n    for (const value of variableOrValues) {\n      if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n        values.push(value);\n      } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n        values.push(value ? 1 : 0);\n      } else if (\n        value === null ||\n        value === undefined ||\n        (typeof value === \"number\" && (isNaN(value) || !isFinite(value)))\n      ) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(`median(): has non-numeric value ${value}`);\n      }\n    }\n\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (values.length === 0) {\n      return null;\n    }\n\n    values.sort((a, b) => a - b);\n    const mid = Math.floor(values.length / 2);\n\n    if (values.length % 2 === 0) {\n      return (values[mid - 1] + values[mid]) / 2;\n    } else {\n      return values[mid];\n    }\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"median()\");\n\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    return result.isMissing ? null : result.value;\n  }\n};\n\n/**\n * Calculates the median value of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the median\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n *   { a: 5, b: 0, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     medA: median(\"a\")\n *   }).observations\n * );\n * // [ { medA: 3 } ]\n * ```\n */\nexport function median(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: medianInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst sdInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    // Reuse the variance calculation and take the square root\n    const varianceValue = varianceInternal(dataCalc, params, options);\n\n    // If variance returned null, sd should also return null\n    if (varianceValue === null) {\n      return null;\n    }\n\n    return Math.sqrt(varianceValue as number);\n  } else if (Array.isArray(variableOrValues)) {\n    // Modify params to pass to varianceInternal\n    const newParams = [...params];\n\n    // Reuse the variance calculation and take the square root\n    const varianceValue = varianceInternal(dataCalc, newParams, options);\n\n    // If variance returned null, sd should also return null\n    if (varianceValue === null) {\n      return null;\n    }\n\n    return Math.sqrt(varianceValue as number);\n  }\n  // return null as sd requires at least 2 values\n  else {\n    return null;\n  }\n};\n\n/**\n * Calculates the standard deviation of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the standard deviation\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n *   { a: 5, b: 0, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     sdA: sd(\"a\")\n *   }).observations\n * );\n * // [ { sdA: 4.112987559751022 } ]\n * ```\n */\nexport function sd(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: sdInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n","export * from \"./DataCalc\";\nexport * from \"./DataCalcOptions\";\nexport * from \"./DataValue\";\nexport * from \"./Mutations\";\nexport * from \"./Observation\";\nexport * from \"./SummarizeFunction\";\nexport * from \"./SummarizeOperation\";\nexport * from \"./SummarizeOperations\";\nexport * from \"./SummarizeOptions\";\n\nconsole.log(\" @m2c2kit/data-calc version __PACKAGE_JSON_VERSION__\");\n"],"names":["sum","mean","min","max"],"mappings":"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"}