{"version":3,"file":"index.js","sources":["../src/M2Error.ts","../src/DataCalc.ts","../src/SummarizeOperations.ts","../src/index.ts"],"sourcesContent":["/**\n * Custom error class for m2c2kit errors.\n *\n * @remarks This is the same class as in the m2c2kit core package. This simple\n * code is copied from that package to avoid taking a dependency on it.\n */\nexport class M2Error extends Error {\n  constructor(...params: string[]) {\n    super(...params);\n    this.name = \"M2Error\";\n    // Set the prototype explicitly to ensure prototype chain is correct.\n    Object.setPrototypeOf(this, M2Error.prototype);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, M2Error);\n    }\n  }\n}\n","import { DataCalcOptions } from \"./DataCalcOptions\";\nimport { DataValue } from \"./DataValue\";\nimport { M2Error } from \"./M2Error\";\nimport { Mutations } from \"./Mutations\";\nimport { Observation } from \"./Observation\";\nimport { SummarizeOperation } from \"./SummarizeOperation\";\n\nexport class DataCalc {\n  private _observations: Array<Observation>;\n  private _groups = new Array<string>();\n\n  /**\n   * A class for transformation and calculation of m2c2kit data.\n   *\n   * @remarks The purpose is to provide a simple and intuitive interface for\n   * assessments to score and summarize their own data. It is not meant for\n   * data analysis or statistical modeling. The idiomatic approach is based on the\n   * dplyr R package.\n   *\n   * @param data - An array of observations, where each observation is a set of\n   * key-value pairs of variable names and values.\n   * @param options - Options, such as groups to group the data by\n   * @example\n   * ```js\n   * const dc = new DataCalc(gameData.trials);\n   * const mean_response_time_correct_trials = dc\n   *  .filter((obs) => obs.correct_response_index === obs.user_response_index)\n   *  .summarize({ mean_rt: mean(\"response_time_duration_ms\") })\n   *  .pull(\"mean_rt\");\n   * ```\n   */\n  constructor(data: Array<Observation>, options?: DataCalcOptions) {\n    // Validate that data is an array\n    if (!Array.isArray(data)) {\n      throw new M2Error(\n        \"DataCalc constructor expects an array of observations as first argument\",\n      );\n    }\n\n    // Validate that all elements in the array are objects (Observations)\n    for (let i = 0; i < data.length; i++) {\n      if (\n        data[i] === null ||\n        typeof data[i] !== \"object\" ||\n        Array.isArray(data[i])\n      ) {\n        throw new M2Error(\n          `DataCalc constructor expects all elements to be objects (observations). Element at index ${i} is ${typeof data[i]}. Element: ${JSON.stringify(data[i])}`,\n        );\n      }\n    }\n\n    this._observations = this.deepCopy(data);\n\n    // Collect all unique variable names across observations\n    const allVariables = new Set<string>();\n    for (const observation of data) {\n      for (const key of Object.keys(observation)) {\n        allVariables.add(key);\n      }\n    }\n\n    // Ensure all observations have all variables, and assign null if missing\n    for (const observation of this._observations) {\n      for (const variable of allVariables) {\n        if (!(variable in observation)) {\n          observation[variable] = null;\n        }\n      }\n    }\n\n    if (options?.groups) {\n      this._groups = Array.from(options.groups);\n    }\n  }\n\n  /**\n   * Returns the groups in the data.\n   */\n  get groups() {\n    return this._groups;\n  }\n\n  /**\n   * Returns the observations in the data.\n   *\n   * @remarks An observation is conceptually similar to a row in a dataset,\n   * where the keys are the variable names and the values are the variable values.\n   */\n  get observations() {\n    return this._observations;\n  }\n\n  /**\n   * Alias for the observations property.\n   */\n  get rows() {\n    return this._observations;\n  }\n\n  /**\n   * Returns a single variable from the data.\n   *\n   * @remarks If the variable length is 1, the value is returned. If the\n   * variable has length > 1, an array of values is returned.\n   *\n   * @param variable - Name of variable to pull from the data\n   * @returns the value of the variable\n   *\n   * @example\n   * ```js\n   * const d = [{ a: 1, b: 2, c: 3 }];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.pull(\"c\")\n   * ); // 3\n   * ```\n   */\n  pull(variable: string): DataValue | DataValue[] {\n    if (this._observations.length === 0) {\n      // Instead of throwing an error, we return null and log a warning. When\n      // filtering datasets, it is common to end up with no observations. Thus,\n      // throwing an error would be too disruptive.\n      console.warn(\n        `DataCalc.pull(): No observations available to pull variable \"${variable}\" from. Returning null.`,\n      );\n      return null;\n    }\n    this.verifyObservationsContainVariable(variable);\n    const values = this._observations.map((o) => o[variable]);\n    if (values.length === 1) {\n      return values[0];\n    }\n    return values;\n  }\n\n  /**\n   * Returns the number of observations in the data.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.length\n   * ); // 2\n   * ```\n   */\n  get length() {\n    return this._observations.length;\n  }\n\n  /**\n   * Filters observations based on a predicate function.\n   *\n   * @param predicate - A function that returns true for observations to keep and\n   * false for observations to discard\n   * @returns A new `DataCalc` object with only the observations that pass the\n   * predicate function\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.filter((obs) => obs.b >= 3).observations);\n   * // [ { a: 0, b: 8, c: 3 }, { a: 9, b: 4, c: 7 } ]\n   * ```\n   */\n  filter(predicate: (observation: Observation) => boolean) {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `filter() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \",\n        )}. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    return new DataCalc(\n      this._observations.filter(\n        predicate as (observation: Observation) => boolean,\n      ),\n      { groups: this._groups },\n    );\n  }\n\n  /**\n   * Groups observations by one or more variables.\n   *\n   * @remarks This is used with the `summarize()` method to calculate summaries\n   * by group.\n   *\n   * @param groups - variable names to group by\n   * @returns A new `DataCalc` object with the observations grouped by one or\n   * more variables\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   *   { a: 5, b: 0, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * const grouped = dc.groupBy(\"c\");\n   * // subsequent summarize operations will be performed separately by\n   * // each unique level of c, in this case, 3 and 7\n   * ```\n   */\n  groupBy(...groups: Array<string>): DataCalc {\n    groups.forEach((group) => {\n      this.verifyObservationsContainVariable(group);\n    });\n    return new DataCalc(this._observations, { groups });\n  }\n\n  /**\n   * Ungroups observations.\n   *\n   * @returns A new DataCalc object with the observations ungrouped\n   */\n  ungroup(): DataCalc {\n    return new DataCalc(this._observations);\n  }\n\n  /**\n   * Adds new variables to the observations based on the provided mutation options.\n   *\n   * @param mutations - An object where the keys are the names of the new variables\n   * and the values are functions that take an observation and return the value\n   * for the new variable.\n   * @returns A new DataCalc object with the new variables added to the observations.\n   *\n   * @example\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.mutate({ doubledA: (obs) => obs.a * 2 }).observations\n   * );\n   * // [ { a: 1, b: 2, c: 3, doubledA: 2 },\n   * //   { a: 0, b: 8, c: 3, doubledA: 0 },\n   * //   { a: 9, b: 4, c: 7, doubledA: 18 } ]\n   */\n  mutate(mutations: Mutations): DataCalc {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `mutate() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \",\n        )}. Ungroup the data first using ungroup().`,\n      );\n    }\n    const newObservations = this._observations.map((observation) => {\n      let newObservation = { ...observation };\n      for (const [newVariable, transformFunction] of Object.entries(\n        mutations,\n      )) {\n        newObservation = {\n          ...newObservation,\n          [newVariable]: transformFunction(observation),\n        };\n      }\n      return newObservation;\n    });\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n\n  /**\n   * Calculates summaries of the data.\n   *\n   * @param summarizations - An object where the keys are the names of the new\n   * variables and the values are `DataCalc` summary functions: `sum()`,\n   * `mean()`, `median()`, `variance()`, `sd()`, `min()`, `max()`, or `n()`.\n   * The summary functions take a variable name as a string, or alternatively,\n   * a value or array of values to summarize.\n   * @returns A new `DataCalc` object with the new summary variables.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   *   { a: 5, b: 0, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.summarize({\n   *     meanA: mean(\"a\"),\n   *     varA: variance(\"a\"),\n   *     totalB: sum(\"b\")\n   *   }).observations\n   * );\n   * // [ { meanA: 3.75, varA: 16.916666666666668, totalB: 14 } ]\n   *\n   * console.log(\n   *   dc.summarize({\n   *    filteredTotalC: sum(dc.filter(obs => obs.b > 2).pull(\"c\"))\n   *  }).observations\n   * );\n   * // [ { filteredTotalC: 10 } ]\n   * ```\n   */\n  summarize(summarizations: {\n    [newVariable: string]: SummarizeOperation | DataValue;\n  }): DataCalc {\n    if (this._groups.length === 0) {\n      const obs: Observation = {};\n      for (const [newVariable, value] of Object.entries(summarizations)) {\n        // Check if the value is a SummarizeOperation\n        if (\n          typeof value === \"object\" &&\n          value !== null &&\n          \"summarizeFunction\" in value\n        ) {\n          // It's a SummarizeOperation\n          const summarizeOperation = value as SummarizeOperation;\n          obs[newVariable] = summarizeOperation.summarizeFunction(\n            this,\n            summarizeOperation.parameters,\n            summarizeOperation.options,\n          );\n        } else {\n          // It's a direct value\n          obs[newVariable] = value;\n        }\n      }\n      return new DataCalc([obs], { groups: this._groups });\n    }\n\n    // Optimized implementation of groupBy summarization\n    return this.summarizeByGroups(summarizations);\n  }\n\n  private summarizeByGroups(summarizations: {\n    [newVariable: string]: SummarizeOperation | DataValue;\n  }): DataCalc {\n    const groupMap = new Map<string, Array<Observation>>();\n\n    this._observations.forEach((obs) => {\n      const groupKey = this._groups\n        .map((g) =>\n          typeof obs[g] === \"object\" ? JSON.stringify(obs[g]) : obs[g],\n        )\n        .join(\"|\");\n\n      if (!groupMap.has(groupKey)) {\n        groupMap.set(groupKey, []);\n      }\n      const groupArray = groupMap.get(groupKey);\n      if (groupArray) {\n        groupArray.push(obs);\n      } else {\n        // This should never happen due to the check above, but handles the case safely\n        groupMap.set(groupKey, [obs]);\n      }\n    });\n\n    const summarizedObservations: Array<Observation> = [];\n    groupMap.forEach((groupObs, groupKey) => {\n      const groupValues = groupKey.split(\"|\");\n      // Use first observation to determine original types\n      const firstObs = groupObs[0];\n\n      // Create summary object with group identifiers\n      const summaryObj: Observation = {};\n      this._groups.forEach((group, i) => {\n        // Get original value as string\n        const valueStr = groupValues[i];\n        const originalType = typeof firstObs[group];\n\n        if (originalType === \"number\") {\n          summaryObj[group] = Number(valueStr);\n        } else if (originalType === \"boolean\") {\n          summaryObj[group] = valueStr === \"true\";\n        } else if (valueStr.startsWith(\"{\") || valueStr.startsWith(\"[\")) {\n          try {\n            summaryObj[group] = JSON.parse(valueStr);\n          } catch {\n            throw new M2Error(\n              `Failed to parse group value ${valueStr} as JSON for group ${group}`,\n            );\n            // alternative approach would be to swallow the error and keep as string\n            // summaryObj[group] = valueStr;\n          }\n        } else {\n          // Keep as string\n          summaryObj[group] = valueStr;\n        }\n      });\n\n      // Calculate summaries for this group\n      const groupDataCalc = new DataCalc(groupObs);\n\n      for (const [newVariable, value] of Object.entries(summarizations)) {\n        // Check if the value is a SummarizeOperation\n        if (\n          typeof value === \"object\" &&\n          value !== null &&\n          \"summarizeFunction\" in value\n        ) {\n          // It's a SummarizeOperation\n          const summarizeOperation = value as SummarizeOperation;\n          summaryObj[newVariable] = summarizeOperation.summarizeFunction(\n            groupDataCalc,\n            summarizeOperation.parameters,\n            summarizeOperation.options,\n          );\n        } else {\n          // It's a direct value\n          summaryObj[newVariable] = value;\n        }\n      }\n\n      summarizedObservations.push(summaryObj);\n    });\n\n    return new DataCalc(summarizedObservations, { groups: this._groups });\n  }\n\n  /**\n   * Selects specific variables to keep in the dataset.\n   * Variables prefixed with \"-\" will be excluded from the result.\n   *\n   * @param variables - Names of variables to select; prefix with '-' to exclude instead\n   * @returns A new DataCalc object with only the selected variables (minus excluded ones)\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3, d: 4 },\n   *   { a: 5, b: 6, c: 7, d: 8 }\n   * ];\n   * const dc = new DataCalc(d);\n   * // Keep a and c\n   * console.log(dc.select(\"a\", \"c\").observations);\n   * // [ { a: 1, c: 3 }, { a: 5, c: 7 } ]\n   * ```\n   */\n  select(...variables: string[]): DataCalc {\n    const includeVars: string[] = [];\n    const excludeVars: string[] = [];\n\n    variables.forEach((variable) => {\n      if (variable.startsWith(\"-\")) {\n        excludeVars.push(variable.substring(1));\n      } else {\n        includeVars.push(variable);\n      }\n    });\n\n    // Check if we have any includes - if not, include all variables except excludes\n    const allVars =\n      includeVars.length > 0\n        ? includeVars\n        : Object.keys(this._observations[0] || {});\n\n    [...allVars, ...excludeVars].forEach((variable) => {\n      this.verifyObservationsContainVariable(variable);\n    });\n\n    const excludeSet = new Set(excludeVars);\n\n    // Apply selections and exclusions\n    const newObservations = this._observations.map((observation) => {\n      const newObservation: Observation = {};\n\n      // If we specified includes, only include those\n      if (includeVars.length > 0) {\n        includeVars.forEach((variable) => {\n          if (!excludeSet.has(variable)) {\n            newObservation[variable] = observation[variable];\n          }\n        });\n      } else {\n        // Otherwise include all except excluded vars\n        Object.keys(observation).forEach((key) => {\n          if (!excludeSet.has(key)) {\n            newObservation[key] = observation[key];\n          }\n        });\n      }\n\n      return newObservation;\n    });\n\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n\n  /**\n   * Arranges (sorts) the observations based on one or more variables.\n   *\n   * @param variables - Names of variables to sort by, prefixed with '-' for descending order\n   * @returns A new DataCalc object with the observations sorted\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 5, b: 2 },\n   *   { a: 3, b: 7 },\n   *   { a: 5, b: 1 }\n   * ];\n   * const dc = new DataCalc(d);\n   * // Sort by a (ascending), then by b (descending)\n   * console.log(dc.arrange(\"a\", \"-b\").observations);\n   * // [ { a: 3, b: 7 }, { a: 5, b: 2 }, { a: 5, b: 1 } ]\n   * ```\n   */\n  arrange(...variables: string[]): DataCalc {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `arrange() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \",\n        )}. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    const sortedObservations = [...this._observations].sort((a, b) => {\n      for (const variable of variables) {\n        let varName = variable;\n        let direction = 1;\n\n        if (variable.startsWith(\"-\")) {\n          varName = variable.substring(1);\n          direction = -1;\n        }\n\n        if (!(varName in a) || !(varName in b)) {\n          throw new M2Error(\n            `arrange(): variable ${varName} does not exist in all observations`,\n          );\n        }\n\n        const aVal = a[varName];\n        const bVal = b[varName];\n\n        // Handle different types\n        if (typeof aVal !== typeof bVal) {\n          return direction * (String(aVal) < String(bVal) ? -1 : 1);\n        }\n\n        if (aVal < bVal) return -1 * direction;\n        if (aVal > bVal) return 1 * direction;\n      }\n      return 0;\n    });\n\n    return new DataCalc(sortedObservations, { groups: this._groups });\n  }\n\n  /**\n   * Keeps only unique/distinct observations.\n   *\n   * @returns A new `DataCalc` object with only unique observations\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 1, b: 2, c: 3 }, // Duplicate\n   *   { a: 2, b: 3, c: 5 },\n   *   { a: 1, b: 2, c: { name: \"dog\" } },\n   *   { a: 1, b: 2, c: { name: \"dog\" } } // Duplicate with nested object\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.distinct().observations);\n   * // [ { a: 1, b: 2, c: 3 }, { a: 2, b: 3, c: 5 }, { a: 1, b: 2, c: { name: \"dog\" } } ]\n   * ```\n   */\n  distinct(): DataCalc {\n    // Consider all variables for uniqueness with stable key generation\n    const seen = new Set<string>();\n    const uniqueObs = this._observations.filter((obs) => {\n      // Create a stable string representation for comparison\n      const key = JSON.stringify(this.normalizeForComparison(obs));\n      if (seen.has(key)) return false;\n      seen.add(key);\n      return true;\n    });\n    return new DataCalc(uniqueObs, { groups: this._groups });\n  }\n\n  /**\n   * Renames variables in the observations.\n   *\n   * @param renames - Object mapping new variable names to old variable names\n   * @returns A new DataCalc object with renamed variables\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 4, b: 5, c: 6 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.rename({ x: 'a', z: 'c' }).observations);\n   * // [ { x: 1, b: 2, z: 3 }, { x: 4, b: 5, z: 6 } ]\n   * ```\n   */\n  rename(renames: { [newName: string]: string }): DataCalc {\n    if (this._observations.length === 0) {\n      throw new M2Error(\"Cannot rename variables on an empty dataset\");\n    }\n\n    Object.values(renames).forEach((oldName) => {\n      this.verifyObservationsContainVariable(oldName);\n    });\n\n    const newObservations = this._observations.map((observation) => {\n      const newObservation: Observation = {};\n\n      // Copy all properties\n      for (const [key, value] of Object.entries(observation)) {\n        // If this is a property being renamed, use the new name\n        const newKey = Object.entries(renames).find(\n          ([, old]) => old === key,\n        )?.[0];\n        if (newKey) {\n          newObservation[newKey] = value;\n        } else if (!Object.values(renames).includes(key)) {\n          // Only copy if not a renamed property\n          newObservation[key] = value;\n        }\n      }\n\n      return newObservation;\n    });\n\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n\n  /**\n   * Performs an inner join with another DataCalc object.\n   * Only rows with matching keys in both datasets are included.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.innerJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 } ]\n   * ```\n   */\n  innerJoin(other: DataCalc, by: string[]): DataCalc {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `innerJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n\n    // Create a hash map for faster joining\n    const rightMap = new Map<string, Observation[]>();\n    other.observations.forEach((obs) => {\n      // Skip observations with null join keys for matching\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(obs[k])))\n        .join(\"|\");\n\n      // Get existing matches or create new array\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n\n    const result: Observation[] = [];\n\n    // Process inner join - only include matches\n    this._observations.forEach((leftObs) => {\n      // Skip observations with null join keys for matching\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k])))\n        .join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n\n      if (rightMatches.length > 0) {\n        // We have matches, create joined rows\n        rightMatches.forEach((rightObs) => {\n          const joinedObs: Observation = { ...leftObs };\n\n          // Add right values, but don't overwrite join keys\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n\n          result.push(joinedObs);\n        });\n      }\n    });\n\n    return new DataCalc(result);\n  }\n\n  /**\n   * Performs a left join with another DataCalc object.\n   * All rows from the left dataset are included, along with matching rows from the right.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.leftJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 }, { id: 3, x: 'c' } ]\n   * ```\n   */\n  leftJoin(other: DataCalc, by: string[]): DataCalc {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `leftJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n\n    // Create a hash map for faster joining\n    const rightMap = new Map<string, Observation[]>();\n    other.observations.forEach((obs) => {\n      // Skip observations with null join keys for matching\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(obs[k])))\n        .join(\"|\");\n\n      // Get existing matches or create new array\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n\n    const result: Observation[] = [];\n\n    // Process left join - include all left rows\n    this._observations.forEach((leftObs) => {\n      // For left join, we include the left observation even if it has null join keys\n      // But it won't match with any right observation\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        result.push({ ...leftObs });\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k])))\n        .join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n\n      if (rightMatches.length > 0) {\n        // We have matches, create joined rows\n        rightMatches.forEach((rightObs) => {\n          const joinedObs: Observation = { ...leftObs };\n\n          // Add right values, but don't overwrite join keys\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n\n          result.push(joinedObs);\n        });\n      } else {\n        // No matches but include left row anyway for left join\n        result.push({ ...leftObs });\n      }\n    });\n\n    return new DataCalc(result);\n  }\n  /**\n   * Performs a right join with another DataCalc object.\n   * All rows from the right dataset are included, along with matching rows from the left.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.rightJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 }, { id: 4, y: 400 } ]\n   * ```\n   */\n  rightJoin(other: DataCalc, by: string[]): DataCalc {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `rightJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n\n    // Create a hash map for faster joining\n    const rightMap = new Map<string, Observation[]>();\n    const rightObsWithNullKeys: Observation[] = [];\n\n    other.observations.forEach((obs) => {\n      // For right join, track right observations with null keys separately\n      if (this.hasNullJoinKeys(obs, by)) {\n        rightObsWithNullKeys.push(obs);\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(obs[k])))\n        .join(\"|\");\n\n      // Get existing matches or create new array\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n\n    const result: Observation[] = [];\n    const processedRightKeys = new Set<string>();\n\n    // Process right join - include matches\n    this._observations.forEach((leftObs) => {\n      // Skip observations with null join keys for matching\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k])))\n        .join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n\n      if (rightMatches.length > 0) {\n        // We have matches, create joined rows\n        rightMatches.forEach((rightObs) => {\n          const joinedObs: Observation = { ...leftObs };\n\n          // Add right values, but don't overwrite join keys\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n\n          result.push(joinedObs);\n        });\n\n        // Mark right key as processed\n        processedRightKeys.add(key);\n      }\n    });\n\n    // Add right rows that didn't match or have null keys\n    other.observations.forEach((rightObs) => {\n      if (this.hasNullJoinKeys(rightObs, by)) {\n        // Include right observations with null keys directly\n        result.push({ ...rightObs });\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(rightObs[k])))\n        .join(\"|\");\n\n      if (!processedRightKeys.has(key)) {\n        result.push({ ...rightObs });\n        processedRightKeys.add(key);\n      }\n    });\n\n    return new DataCalc(result);\n  }\n\n  /**\n   * Performs a full join with another DataCalc object.\n   * All rows from both datasets are included.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.fullJoin(dc2, [\"id\"]).observations);\n   * // [\n   * //   { id: 1, x: 'a', y: 100 },\n   * //   { id: 2, x: 'b', y: 200 },\n   * //   { id: 3, x: 'c' },\n   * //   { id: 4, y: 400 }\n   * // ]\n   * ```\n   */\n  fullJoin(other: DataCalc, by: string[]): DataCalc {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `fullJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n\n    // Create a hash map for faster joining\n    const rightMap = new Map<string, Observation[]>();\n    const rightObsWithNullKeys: Observation[] = [];\n\n    other.observations.forEach((obs) => {\n      // For full join, track right observations with null keys separately\n      if (this.hasNullJoinKeys(obs, by)) {\n        rightObsWithNullKeys.push(obs);\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(obs[k])))\n        .join(\"|\");\n\n      // Get existing matches or create new array\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n\n    const result: Observation[] = [];\n    const processedRightKeys = new Set<string>();\n\n    // Process full join - include all rows\n    this._observations.forEach((leftObs) => {\n      // For full join, we include the left observation even if it has null join keys\n      // But it won't match with any right observation\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        result.push({ ...leftObs });\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k])))\n        .join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n\n      if (rightMatches.length > 0) {\n        // We have matches, create joined rows\n        rightMatches.forEach((rightObs) => {\n          const joinedObs: Observation = { ...leftObs };\n\n          // Add right values, but don't overwrite join keys\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n\n          result.push(joinedObs);\n        });\n\n        // Mark right key as processed\n        processedRightKeys.add(key);\n      } else {\n        // No matches but include left row anyway for full join\n        result.push({ ...leftObs });\n      }\n    });\n\n    // Add right rows that didn't match or have null keys\n    other.observations.forEach((rightObs) => {\n      if (this.hasNullJoinKeys(rightObs, by)) {\n        // Include right observations with null keys directly\n        result.push({ ...rightObs });\n        return;\n      }\n\n      const key = by\n        .map((k) => JSON.stringify(this.normalizeForComparison(rightObs[k])))\n        .join(\"|\");\n\n      if (!processedRightKeys.has(key)) {\n        result.push({ ...rightObs });\n        processedRightKeys.add(key);\n      }\n    });\n\n    return new DataCalc(result);\n  }\n\n  /**\n   * Slice observations by position.\n   *\n   * @param start - Starting position (0-based). Negative values count from\n   * the end.\n   * @param end - Ending position (exclusive)\n   * @returns A new DataCalc object with sliced observations\n   *\n   * @remarks If `end` is not provided, it will return a single observation at\n   * `start` position. If `start` is beyond the length of observations,\n   * it will return an empty DataCalc.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2 },\n   *   { a: 3, b: 4 },\n   *   { a: 5, b: 6 },\n   *   { a: 7, b: 8 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.slice(1, 3).observations);\n   * // [ { a: 3, b: 4 }, { a: 5, b: 6 } ]\n   * console.log(dc.slice(0).observations);\n   * // [ { a: 1, b: 2 } ]\n   * ```\n   */\n  slice(start: number, end?: number): DataCalc {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `slice() cannot be used on grouped data. Ungroup the data first using ungroup().`,\n      );\n    }\n\n    let sliced: Observation[];\n\n    if (start >= this._observations.length) {\n      // If start is beyond the length of observations, return empty DataCalc\n      return new DataCalc([], { groups: this._groups });\n    }\n    if (end === undefined) {\n      // return a single observation at start position\n      const index = start < 0 ? this._observations.length + start : start;\n      sliced = [this._observations[index]];\n    } else {\n      sliced = this._observations.slice(start, end);\n    }\n    return new DataCalc(sliced, { groups: this._groups });\n  }\n\n  /**\n   * Combines observations from two DataCalc objects by rows.\n   *\n   * @param other - The other DataCalc object to bind with\n   * @returns A new DataCalc object with combined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { a: 1, b: 2 },\n   *   { a: 3, b: 4 }\n   * ];\n   * const d2 = [\n   *   { a: 5, b: 6 },\n   *   { a: 7, b: 8 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.bindRows(dc2).observations);\n   * // [ { a: 1, b: 2 }, { a: 3, b: 4 }, { a: 5, b: 6 }, { a: 7, b: 8 } ]\n   * ```\n   */\n  bindRows(other: DataCalc): DataCalc {\n    // Check for type mismatches in common variables\n    if (this._observations.length > 0 && other.observations.length > 0) {\n      const thisVariables = new Set(Object.keys(this._observations[0]));\n      const otherVariables = new Set(Object.keys(other.observations[0]));\n\n      // Find common variables\n      const commonVariables = [...thisVariables].filter((variable) =>\n        otherVariables.has(variable),\n      );\n\n      // For each common variable, check if types match\n      commonVariables.forEach((variable) => {\n        const thisType = this.getVariableType(variable);\n        const otherType = other.getVariableType(variable);\n\n        if (thisType !== otherType) {\n          console.warn(\n            `Warning: bindRows() is combining datasets with different data types for variable '${variable}'. ` +\n              `Left dataset has type '${thisType}' and right dataset has type '${otherType}'.`,\n          );\n        }\n      });\n    }\n\n    return new DataCalc([...this._observations, ...other.observations]);\n  }\n\n  /**\n   * Helper method to determine the primary type of a variable across observations\n   * @internal\n   *\n   * @param variable - The variable name to check\n   * @returns The most common type for the variable or 'mixed' if no clear type exists\n   */\n  private getVariableType(variable: string): string {\n    if (this._observations.length === 0) {\n      return \"unknown\";\n    }\n\n    // Count occurrences of each type\n    const typeCounts: Record<string, number> = {};\n\n    this._observations.forEach((obs) => {\n      if (variable in obs) {\n        const value = obs[variable];\n        const type =\n          value === null\n            ? \"null\"\n            : Array.isArray(value)\n              ? \"array\"\n              : typeof value;\n\n        typeCounts[type] = (typeCounts[type] || 0) + 1;\n      }\n    });\n\n    // Find the most common type\n    let maxCount = 0;\n    let dominantType = \"unknown\";\n\n    for (const [type, count] of Object.entries(typeCounts)) {\n      if (count > maxCount) {\n        maxCount = count;\n        dominantType = type;\n      }\n    }\n\n    return dominantType;\n  }\n\n  /**\n   * Verifies that the variable exists in each observation in the data.\n   *\n   * @remarks Throws an error if the variable does not exist in each\n   * observation. This is not meant to be called by users of the library, but\n   * is used internally.\n   * @internal\n   *\n   * @param variable - The variable to check for\n   */\n  verifyObservationsContainVariable(variable: string): void {\n    if (!this._observations.every((observation) => variable in observation)) {\n      throw new M2Error(\n        `Variable ${variable} does not exist for each item (row) in the data array.`,\n      );\n    }\n  }\n\n  /**\n   * Checks if the variable exists for at least one observation in the data.\n   *\n   * @remarks This is not meant to be called by users of the library, but\n   * is used internally.\n   * @internal\n   *\n   * @param variable - The variable to check for\n   * @returns true if the variable exists in at least one observation, false\n   * otherwise\n   */\n  variableExists(variable: string): boolean {\n    return this._observations.some((observation) => variable in observation);\n  }\n\n  /**\n   * Checks if a value is a non-missing numeric value.\n   *\n   * @remarks A non-missing numeric value is a value that is a number and is\n   * not NaN or infinite.\n   *\n   * @param value - The value to check\n   * @returns true if the value is a non-missing numeric value, false otherwise\n   */\n  isNonMissingNumeric(value: DataValue): boolean {\n    return typeof value === \"number\" && !isNaN(value) && isFinite(value);\n  }\n\n  /**\n   * Checks if a value is a missing numeric value.\n   *\n   * @remarks A missing numeric value is a number that is NaN or infinite, or any\n   * value that is null or undefined. Thus, a null or undefined value is\n   * considered to be a missing numeric value.\n   *\n   * @param value - The value to check\n   * @returns true if the value is a missing numeric value, false otherwise\n   */\n  isMissingNumeric(value: DataValue): boolean {\n    return (\n      (typeof value === \"number\" && (isNaN(value) || !isFinite(value))) ||\n      value === null ||\n      typeof value === \"undefined\"\n    );\n  }\n\n  /**\n   * Normalizes an object for stable comparison by sorting keys\n   * @internal\n   *\n   * @remarks Normalizing is needed to handle situations where objects have the\n   * same properties but in different orders because we are using\n   * JSON.stringify() for comparison.\n   */\n  private normalizeForComparison(obj: Observation): Observation {\n    // Handle non-objects\n    if (obj === null || typeof obj !== \"object\") {\n      return obj;\n    }\n\n    // Handle arrays: sort if primitive values, otherwise normalize each item\n    if (Array.isArray(obj)) {\n      return obj.map((item) => this.normalizeForComparison(item));\n    }\n\n    // For objects: create a new object with sorted keys\n    return Object.keys(obj)\n      .sort()\n      .reduce((result: Observation, key) => {\n        result[key] = this.normalizeForComparison(obj[key]);\n        return result;\n      }, {});\n  }\n\n  /**\n   * Creates a deep copy of an object.\n   * @internal\n   *\n   * @remarks We create a deep copy of the object, in our case an instance\n   * of `DataCalc`, to ensure that we are working with a new object\n   * without any references to the original object. This is important\n   * to avoid unintended side effects when modifying an object.\n   *\n   * @param source - object to copy\n   * @param map - map of objects that have already been copied\n   * @returns a deep copy of the object\n   */\n  private deepCopy<T>(source: T, map = new WeakMap()): T {\n    // Handle primitive values and null\n    if (source === null || typeof source !== \"object\") {\n      return source;\n    }\n\n    // Handle circular references\n    if (map.has(source as object)) {\n      return map.get(source as object);\n    }\n\n    // Create new instance of the same type\n    const copy = Array.isArray(source)\n      ? []\n      : Object.create(Object.getPrototypeOf(source));\n\n    // Add to map before recursing to handle circular references\n    map.set(source as object, copy);\n\n    // Copy all properties\n    const keys = [\n      ...Object.getOwnPropertyNames(source),\n      ...Object.getOwnPropertySymbols(source),\n    ];\n\n    for (const key of keys) {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        source,\n        key as keyof T,\n      );\n      if (descriptor) {\n        Object.defineProperty(copy, key, {\n          ...descriptor,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          value: this.deepCopy((source as any)[key], map),\n        });\n      }\n    }\n\n    return copy;\n  }\n\n  /**\n   * Checks if an observation has null or undefined values in any of the join columns.\n   * @internal\n   *\n   * @param obs - The observation to check\n   * @param keys - The join columns to check\n   * @returns true if any join column has a null or undefined value\n   */\n  private hasNullJoinKeys(obs: Observation, keys: string[]): boolean {\n    return keys.some((key) => obs[key] === null || obs[key] === undefined);\n  }\n}\n","import { DataCalc } from \"./DataCalc\";\nimport { DataValue } from \"./DataValue\";\nimport { SummarizeOperation } from \"./SummarizeOperation\";\nimport { SummarizeFunction } from \"./SummarizeFunction\";\nimport { SummarizeOptions } from \"./SummarizeOptions\";\nimport { M2Error } from \"./M2Error\";\n\n/**\n * Default options for summarize operations\n */\nconst DEFAULT_SUMMARIZE_OPTIONS: SummarizeOptions = {\n  coerceBooleans: true,\n  skipMissing: false,\n} as const;\n\n/**\n * Applies default options to user-provided options\n *\n * @param options - User provided options (may be undefined)\n * @returns Options with defaults applied\n */\nfunction applyDefaultOptions(options?: SummarizeOptions): SummarizeOptions {\n  return { ...DEFAULT_SUMMARIZE_OPTIONS, ...options };\n}\n\n/**\n * Helper function to process numeric values in a variable across observations\n * Handles error checking, type coercion and missing values in a consistent way\n *\n * @param dataCalc - The DataCalc instance to process\n * @param variable - The variable name to process\n * @param options - Summarize options for the operation\n * @param collector - Function that collects values (e.g., sum, max comparison)\n * @param errorPrefix - Prefix for error messages\n * @param initialState - Initial state for the collector function\n * @returns An object containing the processed numeric values and count\n */\nfunction processNumericValues<T>(\n  dataCalc: DataCalc,\n  variable: string,\n  options: SummarizeOptions | undefined,\n  collector: (value: number, state: T) => T,\n  errorPrefix: string,\n  initialState: T,\n): { state: T; count: number; containsMissing: boolean } {\n  const mergedOptions = applyDefaultOptions(options);\n\n  dataCalc.verifyObservationsContainVariable(variable);\n\n  let count = 0;\n  let state = initialState;\n  let containsMissing = false;\n\n  dataCalc.observations.forEach((o) => {\n    if (dataCalc.isNonMissingNumeric(o[variable])) {\n      state = collector(o[variable], state);\n      count++;\n      return;\n    }\n\n    if (typeof o[variable] === \"boolean\" && mergedOptions.coerceBooleans) {\n      state = collector(o[variable] ? 1 : 0, state);\n      count++;\n      return;\n    }\n\n    if (dataCalc.isMissingNumeric(o[variable])) {\n      containsMissing = true;\n      return;\n    }\n\n    // For non-numeric, non-missing values that can't be coerced\n    throw new M2Error(\n      `${errorPrefix}: variable ${variable} has non-numeric value ${o[variable]} in this observation: ${JSON.stringify(o)}`,\n    );\n  });\n\n  return { state, count, containsMissing };\n}\n\n/**\n * Processes an array of numeric values directly rather than through a\n * variable name.\n */\nfunction processDirectValues<T>(\n  values: DataValue[],\n  options: SummarizeOptions | undefined,\n  collector: (value: number, state: T) => T,\n  errorPrefix: string,\n  initialState: T,\n): { state: T; count: number; containsMissing: boolean } {\n  const mergedOptions = applyDefaultOptions(options);\n  let state = initialState;\n  let count = 0;\n  let containsMissing = false;\n\n  for (const value of values) {\n    if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n      state = collector(value, state);\n      count++;\n    } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n      state = collector(value ? 1 : 0, state);\n      count++;\n    } else if (\n      value === null ||\n      value === undefined ||\n      (typeof value === \"number\" && (isNaN(value) || !isFinite(value)))\n    ) {\n      containsMissing = true;\n    } else {\n      throw new M2Error(`${errorPrefix}: has non-numeric value ${value}`);\n    }\n  }\n\n  return { state, count, containsMissing };\n}\n\n/**\n * Processes a single value for summarize operations rather than through a\n * variable name.\n */\nfunction processSingleValue(\n  value: DataValue,\n  options: SummarizeOptions | undefined,\n  errorPrefix: string,\n): { value: number; isMissing: boolean } {\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n    return { value, isMissing: false };\n  } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n    return { value: value ? 1 : 0, isMissing: false };\n  } else if (\n    value === null ||\n    value === undefined ||\n    (typeof value === \"number\" && (isNaN(value) || !isFinite(value)))\n  ) {\n    return { value: 0, isMissing: true };\n  } else {\n    throw new M2Error(`${errorPrefix}: has non-numeric value ${value}`);\n  }\n}\n\nconst nInternal: SummarizeFunction = (dataCalc: DataCalc): number => {\n  return dataCalc.length;\n};\n/**\n * Calculates the number of observations.\n *\n * @returns summarize operation calculating the number of observations\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     count: n()\n *   }).observations\n * );\n * // [ { count: 3 } ]\n * ```\n */\n\nexport function n(): SummarizeOperation {\n  return {\n    summarizeFunction: nInternal,\n    parameters: [],\n  };\n}\n\nconst sumInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum) => sum + value,\n      \"sum()\",\n      0,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, sum) => sum + value,\n      \"sum()\",\n      0,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"sum()\");\n\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    return result.isMissing ? null : result.value;\n  }\n};\n\n/**\n * Calculates the sum of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the sum\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     totalB: sum(\"b\")\n *   }).observations\n * );\n * // [ { totalB: 14 } ]\n * ```\n */\nexport function sum(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: sumInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst meanInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum) => sum + value,\n      \"mean()\",\n      0,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state / result.count;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, sum) => sum + value,\n      \"mean()\",\n      0,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state / result.count;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"mean()\");\n    return result.isMissing && !mergedOptions.skipMissing ? null : result.value;\n  }\n};\n/**\n * Calculates the mean of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the mean\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     meanA: mean(\"a\")\n *   }).observations\n * );\n * // [ { meanA: 3.3333333333333335 } ]\n * ```\n */\nexport function mean(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: meanInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst varianceInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n\n    // First pass: calculate mean\n    const meanResult = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum) => sum + value,\n      \"variance()\",\n      0,\n    );\n\n    if (meanResult.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (meanResult.count <= 1) {\n      return null; // Need at least two values for variance\n    }\n\n    const meanValue = meanResult.state / meanResult.count;\n\n    // Second pass: sum of squared deviations\n    const varianceResult = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum) => {\n        const actualValue =\n          typeof value === \"boolean\" && mergedOptions.coerceBooleans\n            ? value\n              ? 1\n              : 0\n            : value;\n        return sum + Math.pow(actualValue - meanValue, 2);\n      },\n      \"variance()\",\n      0,\n    );\n\n    return varianceResult.state / (meanResult.count - 1);\n  } else if (Array.isArray(variableOrValues)) {\n    // First collect valid values\n    const validValues: number[] = [];\n    let containsMissing = false;\n\n    for (const value of variableOrValues) {\n      if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n        validValues.push(value);\n      } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n        validValues.push(value ? 1 : 0);\n      } else if (\n        value === null ||\n        value === undefined ||\n        (typeof value === \"number\" && (isNaN(value) || !isFinite(value)))\n      ) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(`variance(): has non-numeric value ${value}`);\n      }\n    }\n\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (validValues.length <= 1) {\n      return null; // Need at least two values for variance\n    }\n\n    // Calculate mean\n    const sum = validValues.reduce((acc, val) => acc + val, 0);\n    const mean = sum / validValues.length;\n\n    // Calculate variance\n    const sumSquaredDiffs = validValues.reduce(\n      (acc, val) => acc + Math.pow(val - mean, 2),\n      0,\n    );\n\n    return sumSquaredDiffs / (validValues.length - 1);\n  }\n  // return null as variance requires at least 2 values\n  else {\n    return null;\n  }\n};\n\n/**\n * Calculates the variance of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the variance\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n *   { a: 5, b: 0, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     varA: variance(\"a\")\n *   }).observations\n * );\n * // [ { varA: 16.916666666666668 } ]\n * ```\n */\nexport function variance(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: varianceInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst minInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, min) =>\n        min === Number.POSITIVE_INFINITY || value < min ? value : min,\n      \"min()\",\n      Number.POSITIVE_INFINITY,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, min) =>\n        min === Number.POSITIVE_INFINITY || value < min ? value : min,\n      \"min()\",\n      Number.POSITIVE_INFINITY,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"min()\");\n\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    return result.isMissing ? null : result.value;\n  }\n};\n\n/**\n * Calculates the minimum value of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the minimum\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n *   { a: 5, b: 0, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     minA: min(\"a\")\n *   }).observations\n * );\n * // [ { minA: 0 } ]\n * ```\n */\nexport function min(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: minInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst maxInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, max) =>\n        max === Number.NEGATIVE_INFINITY || value > max ? value : max,\n      \"max()\",\n      Number.NEGATIVE_INFINITY,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, max) =>\n        max === Number.NEGATIVE_INFINITY || value > max ? value : max,\n      \"max()\",\n      Number.NEGATIVE_INFINITY,\n    );\n\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (result.count === 0) {\n      return null;\n    }\n\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"max()\");\n\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    return result.isMissing ? null : result.value;\n  }\n};\n\n/**\n * Calculates the maximum value of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the maximum\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n *   { a: 5, b: 0, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     maxA: max(\"a\")\n *   }).observations\n * );\n * // [ { maxA: 9 } ]\n * ```\n */\nexport function max(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: maxInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst medianInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    dataCalc.verifyObservationsContainVariable(variable);\n\n    // Collect all valid values into an array\n    const values: number[] = [];\n    let containsMissing = false;\n\n    dataCalc.observations.forEach((o) => {\n      if (dataCalc.isNonMissingNumeric(o[variable])) {\n        values.push(o[variable]);\n      } else if (\n        typeof o[variable] === \"boolean\" &&\n        mergedOptions.coerceBooleans\n      ) {\n        values.push(o[variable] ? 1 : 0);\n      } else if (dataCalc.isMissingNumeric(o[variable])) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(\n          `median(): variable ${variable} has non-numeric value ${o[variable]} in this observation: ${JSON.stringify(o)}`,\n        );\n      }\n    });\n\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (values.length === 0) {\n      return null;\n    }\n\n    values.sort((a, b) => a - b);\n    const mid = Math.floor(values.length / 2);\n\n    if (values.length % 2 === 0) {\n      return (values[mid - 1] + values[mid]) / 2;\n    } else {\n      return values[mid];\n    }\n  } else if (Array.isArray(variableOrValues)) {\n    // Collect valid values\n    const values: number[] = [];\n    let containsMissing = false;\n\n    for (const value of variableOrValues) {\n      if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n        values.push(value);\n      } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n        values.push(value ? 1 : 0);\n      } else if (\n        value === null ||\n        value === undefined ||\n        (typeof value === \"number\" && (isNaN(value) || !isFinite(value)))\n      ) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(`median(): has non-numeric value ${value}`);\n      }\n    }\n\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    if (values.length === 0) {\n      return null;\n    }\n\n    values.sort((a, b) => a - b);\n    const mid = Math.floor(values.length / 2);\n\n    if (values.length % 2 === 0) {\n      return (values[mid - 1] + values[mid]) / 2;\n    } else {\n      return values[mid];\n    }\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"median()\");\n\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n\n    return result.isMissing ? null : result.value;\n  }\n};\n\n/**\n * Calculates the median value of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the median\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n *   { a: 5, b: 0, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     medA: median(\"a\")\n *   }).observations\n * );\n * // [ { medA: 3 } ]\n * ```\n */\nexport function median(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: medianInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n\nconst sdInternal: SummarizeFunction = (\n  dataCalc: DataCalc,\n  params: Array<DataValue>,\n  options?: SummarizeOptions,\n): DataValue => {\n  const variableOrValues = params[0];\n\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    // Reuse the variance calculation and take the square root\n    const varianceValue = varianceInternal(dataCalc, params, options);\n\n    // If variance returned null, sd should also return null\n    if (varianceValue === null) {\n      return null;\n    }\n\n    return Math.sqrt(varianceValue as number);\n  } else if (Array.isArray(variableOrValues)) {\n    // Modify params to pass to varianceInternal\n    const newParams = [...params];\n\n    // Reuse the variance calculation and take the square root\n    const varianceValue = varianceInternal(dataCalc, newParams, options);\n\n    // If variance returned null, sd should also return null\n    if (varianceValue === null) {\n      return null;\n    }\n\n    return Math.sqrt(varianceValue as number);\n  }\n  // return null as sd requires at least 2 values\n  else {\n    return null;\n  }\n};\n\n/**\n * Calculates the standard deviation of a variable, value, or array of values\n *\n * @param variableOrValues - name of variable, or alternatively, a value or\n * array of values\n * @param options - options for handling missing values and boolean coercion\n * @returns summarize operation calculating the standard deviation\n *\n * @example\n * ```js\n * const d = [\n *   { a: 1, b: 2, c: 3 },\n *   { a: 0, b: 8, c: 3 },\n *   { a: 9, b: 4, c: 7 },\n *   { a: 5, b: 0, c: 7 },\n * ];\n * const dc = new DataCalc(d);\n * console.log(\n *   dc.summarize({\n *     sdA: sd(\"a\")\n *   }).observations\n * );\n * // [ { sdA: 4.112987559751022 } ]\n * ```\n */\nexport function sd(\n  variableOrValues: string | DataValue | DataValue[],\n  options?: SummarizeOptions,\n): SummarizeOperation {\n  return {\n    summarizeFunction: sdInternal,\n    parameters: [variableOrValues],\n    options: options,\n  };\n}\n","export * from \"./DataCalc\";\nexport * from \"./DataCalcOptions\";\nexport * from \"./DataValue\";\nexport * from \"./Mutations\";\nexport * from \"./Observation\";\nexport * from \"./SummarizeFunction\";\nexport * from \"./SummarizeOperation\";\nexport * from \"./SummarizeOperations\";\nexport * from \"./SummarizeOptions\";\n\nconsole.log(\" @m2c2kit/data-calc version __PACKAGE_JSON_VERSION__\");\n"],"names":["sum","mean","min","max"],"mappings":"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"}