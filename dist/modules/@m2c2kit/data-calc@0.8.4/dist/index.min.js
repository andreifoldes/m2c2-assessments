class h extends Error{constructor(...e){super(...e),this.name="M2Error",Object.setPrototypeOf(this,h.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,h)}}class p{constructor(e,t){if(this._groups=new Array,!Array.isArray(e))throw new h("DataCalc constructor expects an array of observations as first argument");for(let i=0;i<e.length;i++)if(e[i]===null||typeof e[i]!="object"||Array.isArray(e[i]))throw new h(`DataCalc constructor expects all elements to be objects (observations). Element at index ${i} is ${typeof e[i]}. Element: ${JSON.stringify(e[i])}`);this._observations=this.deepCopy(e);const r=new Set;for(const i of e)for(const n of Object.keys(i))r.add(n);for(const i of this._observations)for(const n of r)n in i||(i[n]=null);t?.groups&&(this._groups=Array.from(t.groups))}get groups(){return this._groups}get observations(){return this._observations}get rows(){return this._observations}pull(e){if(this._observations.length===0)return console.warn(`DataCalc.pull(): No observations available to pull variable "${e}" from. Returning null.`),null;this.verifyObservationsContainVariable(e);const t=this._observations.map(r=>r[e]);return t.length===1?t[0]:t}get length(){return this._observations.length}filter(e){if(this._groups.length>0)throw new h(`filter() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(", ")}. Ungroup the data first using ungroup().`);return new p(this._observations.filter(e),{groups:this._groups})}groupBy(...e){return e.forEach(t=>{this.verifyObservationsContainVariable(t)}),new p(this._observations,{groups:e})}ungroup(){return new p(this._observations)}mutate(e){if(this._groups.length>0)throw new h(`mutate() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(", ")}. Ungroup the data first using ungroup().`);const t=this._observations.map(r=>{let i={...r};for(const[n,s]of Object.entries(e))i={...i,[n]:s(r)};return i});return new p(t,{groups:this._groups})}summarize(e){if(this._groups.length===0){const t={};for(const[r,i]of Object.entries(e))if(typeof i=="object"&&i!==null&&"summarizeFunction"in i){const n=i;t[r]=n.summarizeFunction(this,n.parameters,n.options)}else t[r]=i;return new p([t],{groups:this._groups})}return this.summarizeByGroups(e)}summarizeByGroups(e){const t=new Map;this._observations.forEach(i=>{const n=this._groups.map(o=>typeof i[o]=="object"?JSON.stringify(i[o]):i[o]).join("|");t.has(n)||t.set(n,[]);const s=t.get(n);s?s.push(i):t.set(n,[i])});const r=[];return t.forEach((i,n)=>{const s=n.split("|"),o=i[0],a={};this._groups.forEach((c,f)=>{const g=s[f],w=typeof o[c];if(w==="number")a[c]=Number(g);else if(w==="boolean")a[c]=g==="true";else if(g.startsWith("{")||g.startsWith("["))try{a[c]=JSON.parse(g)}catch{throw new h(`Failed to parse group value ${g} as JSON for group ${c}`)}else a[c]=g});const u=new p(i);for(const[c,f]of Object.entries(e))if(typeof f=="object"&&f!==null&&"summarizeFunction"in f){const g=f;a[c]=g.summarizeFunction(u,g.parameters,g.options)}else a[c]=f;r.push(a)}),new p(r,{groups:this._groups})}select(...e){const t=[],r=[];e.forEach(o=>{o.startsWith("-")?r.push(o.substring(1)):t.push(o)}),[...t.length>0?t:Object.keys(this._observations[0]||{}),...r].forEach(o=>{this.verifyObservationsContainVariable(o)});const n=new Set(r),s=this._observations.map(o=>{const a={};return t.length>0?t.forEach(u=>{n.has(u)||(a[u]=o[u])}):Object.keys(o).forEach(u=>{n.has(u)||(a[u]=o[u])}),a});return new p(s,{groups:this._groups})}arrange(...e){if(this._groups.length>0)throw new h(`arrange() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(", ")}. Ungroup the data first using ungroup().`);const t=[...this._observations].sort((r,i)=>{for(const n of e){let s=n,o=1;if(n.startsWith("-")&&(s=n.substring(1),o=-1),!(s in r)||!(s in i))throw new h(`arrange(): variable ${s} does not exist in all observations`);const a=r[s],u=i[s];if(typeof a!=typeof u)return o*(String(a)<String(u)?-1:1);if(a<u)return-1*o;if(a>u)return 1*o}return 0});return new p(t,{groups:this._groups})}distinct(){const e=new Set,t=this._observations.filter(r=>{const i=JSON.stringify(this.normalizeForComparison(r));return e.has(i)?!1:(e.add(i),!0)});return new p(t,{groups:this._groups})}rename(e){if(this._observations.length===0)throw new h("Cannot rename variables on an empty dataset");Object.values(e).forEach(r=>{this.verifyObservationsContainVariable(r)});const t=this._observations.map(r=>{const i={};for(const[n,s]of Object.entries(r)){const o=Object.entries(e).find(([,a])=>a===n)?.[0];o?i[o]=s:Object.values(e).includes(n)||(i[n]=s)}return i});return new p(t,{groups:this._groups})}innerJoin(e,t){if(this._groups.length>0||e._groups.length>0)throw new h("innerJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");t.forEach(n=>{this.verifyObservationsContainVariable(n),e.verifyObservationsContainVariable(n)});const r=new Map;e.observations.forEach(n=>{if(this.hasNullJoinKeys(n,t))return;const s=t.map(a=>JSON.stringify(this.normalizeForComparison(n[a]))).join("|"),o=r.get(s)||[];o.push(n),r.set(s,o)});const i=[];return this._observations.forEach(n=>{if(this.hasNullJoinKeys(n,t))return;const s=t.map(a=>JSON.stringify(this.normalizeForComparison(n[a]))).join("|"),o=r.get(s)||[];o.length>0&&o.forEach(a=>{const u={...n};Object.entries(a).forEach(([c,f])=>{t.includes(c)||(u[c]=f)}),i.push(u)})}),new p(i)}leftJoin(e,t){if(this._groups.length>0||e._groups.length>0)throw new h("leftJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");t.forEach(n=>{this.verifyObservationsContainVariable(n),e.verifyObservationsContainVariable(n)});const r=new Map;e.observations.forEach(n=>{if(this.hasNullJoinKeys(n,t))return;const s=t.map(a=>JSON.stringify(this.normalizeForComparison(n[a]))).join("|"),o=r.get(s)||[];o.push(n),r.set(s,o)});const i=[];return this._observations.forEach(n=>{if(this.hasNullJoinKeys(n,t)){i.push({...n});return}const s=t.map(a=>JSON.stringify(this.normalizeForComparison(n[a]))).join("|"),o=r.get(s)||[];o.length>0?o.forEach(a=>{const u={...n};Object.entries(a).forEach(([c,f])=>{t.includes(c)||(u[c]=f)}),i.push(u)}):i.push({...n})}),new p(i)}rightJoin(e,t){if(this._groups.length>0||e._groups.length>0)throw new h("rightJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");t.forEach(s=>{this.verifyObservationsContainVariable(s),e.verifyObservationsContainVariable(s)});const r=new Map;e.observations.forEach(s=>{if(this.hasNullJoinKeys(s,t))return;const o=t.map(u=>JSON.stringify(this.normalizeForComparison(s[u]))).join("|"),a=r.get(o)||[];a.push(s),r.set(o,a)});const i=[],n=new Set;return this._observations.forEach(s=>{if(this.hasNullJoinKeys(s,t))return;const o=t.map(u=>JSON.stringify(this.normalizeForComparison(s[u]))).join("|"),a=r.get(o)||[];a.length>0&&(a.forEach(u=>{const c={...s};Object.entries(u).forEach(([f,g])=>{t.includes(f)||(c[f]=g)}),i.push(c)}),n.add(o))}),e.observations.forEach(s=>{if(this.hasNullJoinKeys(s,t)){i.push({...s});return}const o=t.map(a=>JSON.stringify(this.normalizeForComparison(s[a]))).join("|");n.has(o)||(i.push({...s}),n.add(o))}),new p(i)}fullJoin(e,t){if(this._groups.length>0||e._groups.length>0)throw new h("fullJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");t.forEach(s=>{this.verifyObservationsContainVariable(s),e.verifyObservationsContainVariable(s)});const r=new Map;e.observations.forEach(s=>{if(this.hasNullJoinKeys(s,t))return;const o=t.map(u=>JSON.stringify(this.normalizeForComparison(s[u]))).join("|"),a=r.get(o)||[];a.push(s),r.set(o,a)});const i=[],n=new Set;return this._observations.forEach(s=>{if(this.hasNullJoinKeys(s,t)){i.push({...s});return}const o=t.map(u=>JSON.stringify(this.normalizeForComparison(s[u]))).join("|"),a=r.get(o)||[];a.length>0?(a.forEach(u=>{const c={...s};Object.entries(u).forEach(([f,g])=>{t.includes(f)||(c[f]=g)}),i.push(c)}),n.add(o)):i.push({...s})}),e.observations.forEach(s=>{if(this.hasNullJoinKeys(s,t)){i.push({...s});return}const o=t.map(a=>JSON.stringify(this.normalizeForComparison(s[a]))).join("|");n.has(o)||(i.push({...s}),n.add(o))}),new p(i)}slice(e,t){if(this._groups.length>0)throw new h("slice() cannot be used on grouped data. Ungroup the data first using ungroup().");let r;if(e>=this._observations.length)return new p([],{groups:this._groups});if(t===void 0){const i=e<0?this._observations.length+e:e;r=[this._observations[i]]}else r=this._observations.slice(e,t);return new p(r,{groups:this._groups})}bindRows(e){if(this._observations.length>0&&e.observations.length>0){const t=new Set(Object.keys(this._observations[0])),r=new Set(Object.keys(e.observations[0]));[...t].filter(n=>r.has(n)).forEach(n=>{const s=this.getVariableType(n),o=e.getVariableType(n);s!==o&&console.warn(`Warning: bindRows() is combining datasets with different data types for variable '${n}'. Left dataset has type '${s}' and right dataset has type '${o}'.`)})}return new p([...this._observations,...e.observations])}getVariableType(e){if(this._observations.length===0)return"unknown";const t={};this._observations.forEach(n=>{if(e in n){const s=n[e],o=s===null?"null":Array.isArray(s)?"array":typeof s;t[o]=(t[o]||0)+1}});let r=0,i="unknown";for(const[n,s]of Object.entries(t))s>r&&(r=s,i=n);return i}verifyObservationsContainVariable(e){if(!this._observations.every(t=>e in t))throw new h(`Variable ${e} does not exist for each item (row) in the data array.`)}variableExists(e){return this._observations.some(t=>e in t)}isNonMissingNumeric(e){return typeof e=="number"&&!isNaN(e)&&isFinite(e)}isMissingNumeric(e){return typeof e=="number"&&(isNaN(e)||!isFinite(e))||e===null||typeof e>"u"}normalizeForComparison(e){return e===null||typeof e!="object"?e:Array.isArray(e)?e.map(t=>this.normalizeForComparison(t)):Object.keys(e).sort().reduce((t,r)=>(t[r]=this.normalizeForComparison(e[r]),t),{})}deepCopy(e,t=new WeakMap){if(e===null||typeof e!="object")return e;if(t.has(e))return t.get(e);const r=Array.isArray(e)?[]:Object.create(Object.getPrototypeOf(e));t.set(e,r);const i=[...Object.getOwnPropertyNames(e),...Object.getOwnPropertySymbols(e)];for(const n of i){const s=Object.getOwnPropertyDescriptor(e,n);s&&Object.defineProperty(r,n,{...s,value:this.deepCopy(e[n],t)})}return r}hasNullJoinKeys(e,t){return t.some(r=>e[r]===null||e[r]===void 0)}}const N={coerceBooleans:!0,skipMissing:!1};function m(l){return{...N,...l}}function b(l,e,t,r,i,n){const s=m(t);l.verifyObservationsContainVariable(e);let o=0,a=n,u=!1;return l.observations.forEach(c=>{if(l.isNonMissingNumeric(c[e])){a=r(c[e],a),o++;return}if(typeof c[e]=="boolean"&&s.coerceBooleans){a=r(c[e]?1:0,a),o++;return}if(l.isMissingNumeric(c[e])){u=!0;return}throw new h(`${i}: variable ${e} has non-numeric value ${c[e]} in this observation: ${JSON.stringify(c)}`)}),{state:a,count:o,containsMissing:u}}function v(l,e,t,r,i){const n=m(e);let s=i,o=0,a=!1;for(const u of l)if(typeof u=="number"&&!isNaN(u)&&isFinite(u))s=t(u,s),o++;else if(typeof u=="boolean"&&n.coerceBooleans)s=t(u?1:0,s),o++;else if(u==null||typeof u=="number"&&(isNaN(u)||!isFinite(u)))a=!0;else throw new h(`${r}: has non-numeric value ${u}`);return{state:s,count:o,containsMissing:a}}function y(l,e,t){const r=m(e);if(typeof l=="number"&&!isNaN(l)&&isFinite(l))return{value:l,isMissing:!1};if(typeof l=="boolean"&&r.coerceBooleans)return{value:l?1:0,isMissing:!1};if(l==null||typeof l=="number"&&(isNaN(l)||!isFinite(l)))return{value:0,isMissing:!0};throw new h(`${t}: has non-numeric value ${l}`)}const O=l=>l.length;function M(){return{summarizeFunction:O,parameters:[]}}const E=(l,e,t)=>{const r=e[0],i=m(t);if(typeof r=="string"){if(!l.variableExists(r))return null;const s=b(l,r,t,(o,a)=>a+o,"sum()",0);return s.containsMissing&&!i.skipMissing||s.count===0?null:s.state}else if(Array.isArray(r)){const n=v(r,t,(s,o)=>o+s,"sum()",0);return n.containsMissing&&!i.skipMissing||n.count===0?null:n.state}else{const n=y(r,t,"sum()");return n.isMissing&&!i.skipMissing||n.isMissing?null:n.value}};function V(l,e){return{summarizeFunction:E,parameters:[l],options:e}}const _=(l,e,t)=>{const r=e[0],i=m(t);if(typeof r=="string"){if(!l.variableExists(r))return null;const s=b(l,r,t,(o,a)=>a+o,"mean()",0);return s.containsMissing&&!i.skipMissing||s.count===0?null:s.state/s.count}else if(Array.isArray(r)){const n=v(r,t,(s,o)=>o+s,"mean()",0);return n.containsMissing&&!i.skipMissing||n.count===0?null:n.state/n.count}else{const n=y(r,t,"mean()");return n.isMissing&&!i.skipMissing?null:n.value}};function F(l,e){return{summarizeFunction:_,parameters:[l],options:e}}const d=(l,e,t)=>{const r=e[0],i=m(t);if(typeof r=="string"){if(!l.variableExists(r))return null;const n=r,s=b(l,n,t,(u,c)=>c+u,"variance()",0);if(s.containsMissing&&!i.skipMissing||s.count<=1)return null;const o=s.state/s.count;return b(l,n,t,(u,c)=>{const f=typeof u=="boolean"&&i.coerceBooleans?u?1:0:u;return c+Math.pow(f-o,2)},"variance()",0).state/(s.count-1)}else if(Array.isArray(r)){const n=[];let s=!1;for(const c of r)if(typeof c=="number"&&!isNaN(c)&&isFinite(c))n.push(c);else if(typeof c=="boolean"&&i.coerceBooleans)n.push(c?1:0);else if(c==null||typeof c=="number"&&(isNaN(c)||!isFinite(c)))s=!0;else throw new h(`variance(): has non-numeric value ${c}`);if(s&&!i.skipMissing||n.length<=1)return null;const a=n.reduce((c,f)=>c+f,0)/n.length;return n.reduce((c,f)=>c+Math.pow(f-a,2),0)/(n.length-1)}else return null};function I(l,e){return{summarizeFunction:d,parameters:[l],options:e}}const j=(l,e,t)=>{const r=e[0],i=m(t);if(typeof r=="string"){if(!l.variableExists(r))return null;const s=b(l,r,t,(o,a)=>a===Number.POSITIVE_INFINITY||o<a?o:a,"min()",Number.POSITIVE_INFINITY);return s.containsMissing&&!i.skipMissing||s.count===0?null:s.state}else if(Array.isArray(r)){const n=v(r,t,(s,o)=>o===Number.POSITIVE_INFINITY||s<o?s:o,"min()",Number.POSITIVE_INFINITY);return n.containsMissing&&!i.skipMissing||n.count===0?null:n.state}else{const n=y(r,t,"min()");return n.isMissing&&!i.skipMissing||n.isMissing?null:n.value}};function S(l,e){return{summarizeFunction:j,parameters:[l],options:e}}const J=(l,e,t)=>{const r=e[0],i=m(t);if(typeof r=="string"){if(!l.variableExists(r))return null;const s=b(l,r,t,(o,a)=>a===Number.NEGATIVE_INFINITY||o>a?o:a,"max()",Number.NEGATIVE_INFINITY);return s.containsMissing&&!i.skipMissing||s.count===0?null:s.state}else if(Array.isArray(r)){const n=v(r,t,(s,o)=>o===Number.NEGATIVE_INFINITY||s>o?s:o,"max()",Number.NEGATIVE_INFINITY);return n.containsMissing&&!i.skipMissing||n.count===0?null:n.state}else{const n=y(r,t,"max()");return n.isMissing&&!i.skipMissing||n.isMissing?null:n.value}};function A(l,e){return{summarizeFunction:J,parameters:[l],options:e}}const k=(l,e,t)=>{const r=e[0],i=m(t);if(typeof r=="string"){if(!l.variableExists(r))return null;const n=r;l.verifyObservationsContainVariable(n);const s=[];let o=!1;if(l.observations.forEach(u=>{if(l.isNonMissingNumeric(u[n]))s.push(u[n]);else if(typeof u[n]=="boolean"&&i.coerceBooleans)s.push(u[n]?1:0);else if(l.isMissingNumeric(u[n]))o=!0;else throw new h(`median(): variable ${n} has non-numeric value ${u[n]} in this observation: ${JSON.stringify(u)}`)}),o&&!i.skipMissing||s.length===0)return null;s.sort((u,c)=>u-c);const a=Math.floor(s.length/2);return s.length%2===0?(s[a-1]+s[a])/2:s[a]}else if(Array.isArray(r)){const n=[];let s=!1;for(const a of r)if(typeof a=="number"&&!isNaN(a)&&isFinite(a))n.push(a);else if(typeof a=="boolean"&&i.coerceBooleans)n.push(a?1:0);else if(a==null||typeof a=="number"&&(isNaN(a)||!isFinite(a)))s=!0;else throw new h(`median(): has non-numeric value ${a}`);if(s&&!i.skipMissing||n.length===0)return null;n.sort((a,u)=>a-u);const o=Math.floor(n.length/2);return n.length%2===0?(n[o-1]+n[o])/2:n[o]}else{const n=y(r,t,"median()");return n.isMissing&&!i.skipMissing||n.isMissing?null:n.value}};function z(l,e){return{summarizeFunction:k,parameters:[l],options:e}}const T=(l,e,t)=>{const r=e[0];if(typeof r=="string"){if(!l.variableExists(r))return null;const i=d(l,e,t);return i===null?null:Math.sqrt(i)}else if(Array.isArray(r)){const i=[...e],n=d(l,i,t);return n===null?null:Math.sqrt(n)}else return null};function $(l,e){return{summarizeFunction:T,parameters:[l],options:e}}console.log("\u26AA @m2c2kit/data-calc version 0.8.4 (92cfffbe)");export{p as DataCalc,A as max,F as mean,z as median,S as min,M as n,$ as sd,V as sum,I as variance};
