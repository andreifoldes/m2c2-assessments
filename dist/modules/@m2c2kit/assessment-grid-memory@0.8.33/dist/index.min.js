import{Game as ce,RandomDraws as J,Sprite as ue,Scene as F,M2Error as de,WebColors as N,LabelHorizontalAlignmentMode as pe,Transition as W,Easings as Z,TransitionDirection as Q,Label as R,Action as _,Shape as $,Timer as S}from"@m2c2kit/core";import{LocalePicker as he,Instructions as ie,CountdownScene as fe,Grid as ee,Button as re}from"@m2c2kit/addons";class f extends Error{constructor(...e){super(...e),this.name="M2Error",Object.setPrototypeOf(this,f.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,f)}}class m{constructor(e,i){if(this._groups=new Array,!Array.isArray(e))throw new f("DataCalc constructor expects an array of observations as first argument");for(let s=0;s<e.length;s++)if(e[s]===null||typeof e[s]!="object"||Array.isArray(e[s]))throw new f(`DataCalc constructor expects all elements to be objects (observations). Element at index ${s} is ${typeof e[s]}. Element: ${JSON.stringify(e[s])}`);this._observations=this.deepCopy(e);const r=new Set;for(const s of e)for(const t of Object.keys(s))r.add(t);for(const s of this._observations)for(const t of r)t in s||(s[t]=null);i?.groups&&(this._groups=Array.from(i.groups))}get groups(){return this._groups}get observations(){return this._observations}get rows(){return this._observations}pull(e){if(this._observations.length===0)return console.warn(`DataCalc.pull(): No observations available to pull variable "${e}" from. Returning null.`),null;this.verifyObservationsContainVariable(e);const i=this._observations.map(r=>r[e]);return i.length===1?i[0]:i}get length(){return this._observations.length}filter(e){if(this._groups.length>0)throw new f(`filter() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(", ")}. Ungroup the data first using ungroup().`);return new m(this._observations.filter(e),{groups:this._groups})}groupBy(...e){return e.forEach(i=>{this.verifyObservationsContainVariable(i)}),new m(this._observations,{groups:e})}ungroup(){return new m(this._observations)}mutate(e){if(this._groups.length>0)throw new f(`mutate() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(", ")}. Ungroup the data first using ungroup().`);const i=this._observations.map(r=>{let s={...r};for(const[t,n]of Object.entries(e))s={...s,[t]:n(r)};return s});return new m(i,{groups:this._groups})}summarize(e){if(this._groups.length===0){const i={};for(const[r,s]of Object.entries(e))if(typeof s=="object"&&s!==null&&"summarizeFunction"in s){const t=s;i[r]=t.summarizeFunction(this,t.parameters,t.options)}else i[r]=s;return new m([i],{groups:this._groups})}return this.summarizeByGroups(e)}summarizeByGroups(e){const i=new Map;this._observations.forEach(s=>{const t=this._groups.map(o=>typeof s[o]=="object"?JSON.stringify(s[o]):s[o]).join("|");i.has(t)||i.set(t,[]);const n=i.get(t);n?n.push(s):i.set(t,[s])});const r=[];return i.forEach((s,t)=>{const n=t.split("|"),o=s[0],a={};this._groups.forEach((u,d)=>{const p=n[d],y=typeof o[u];if(y==="number")a[u]=Number(p);else if(y==="boolean")a[u]=p==="true";else if(p.startsWith("{")||p.startsWith("["))try{a[u]=JSON.parse(p)}catch{throw new f(`Failed to parse group value ${p} as JSON for group ${u}`)}else a[u]=p});const l=new m(s);for(const[u,d]of Object.entries(e))if(typeof d=="object"&&d!==null&&"summarizeFunction"in d){const p=d;a[u]=p.summarizeFunction(l,p.parameters,p.options)}else a[u]=d;r.push(a)}),new m(r,{groups:this._groups})}select(...e){const i=[],r=[];e.forEach(o=>{o.startsWith("-")?r.push(o.substring(1)):i.push(o)}),[...i.length>0?i:Object.keys(this._observations[0]||{}),...r].forEach(o=>{this.verifyObservationsContainVariable(o)});const t=new Set(r),n=this._observations.map(o=>{const a={};return i.length>0?i.forEach(l=>{t.has(l)||(a[l]=o[l])}):Object.keys(o).forEach(l=>{t.has(l)||(a[l]=o[l])}),a});return new m(n,{groups:this._groups})}arrange(...e){if(this._groups.length>0)throw new f(`arrange() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(", ")}. Ungroup the data first using ungroup().`);const i=[...this._observations].sort((r,s)=>{for(const t of e){let n=t,o=1;if(t.startsWith("-")&&(n=t.substring(1),o=-1),!(n in r)||!(n in s))throw new f(`arrange(): variable ${n} does not exist in all observations`);const a=r[n],l=s[n];if(typeof a!=typeof l)return o*(String(a)<String(l)?-1:1);if(a<l)return-1*o;if(a>l)return 1*o}return 0});return new m(i,{groups:this._groups})}distinct(){const e=new Set,i=this._observations.filter(r=>{const s=JSON.stringify(this.normalizeForComparison(r));return e.has(s)?!1:(e.add(s),!0)});return new m(i,{groups:this._groups})}rename(e){if(this._observations.length===0)throw new f("Cannot rename variables on an empty dataset");Object.values(e).forEach(r=>{this.verifyObservationsContainVariable(r)});const i=this._observations.map(r=>{const s={};for(const[t,n]of Object.entries(r)){const o=Object.entries(e).find(([,a])=>a===t)?.[0];o?s[o]=n:Object.values(e).includes(t)||(s[t]=n)}return s});return new m(i,{groups:this._groups})}innerJoin(e,i){if(this._groups.length>0||e._groups.length>0)throw new f("innerJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");i.forEach(t=>{this.verifyObservationsContainVariable(t),e.verifyObservationsContainVariable(t)});const r=new Map;e.observations.forEach(t=>{if(this.hasNullJoinKeys(t,i))return;const n=i.map(a=>JSON.stringify(this.normalizeForComparison(t[a]))).join("|"),o=r.get(n)||[];o.push(t),r.set(n,o)});const s=[];return this._observations.forEach(t=>{if(this.hasNullJoinKeys(t,i))return;const n=i.map(a=>JSON.stringify(this.normalizeForComparison(t[a]))).join("|"),o=r.get(n)||[];o.length>0&&o.forEach(a=>{const l={...t};Object.entries(a).forEach(([u,d])=>{i.includes(u)||(l[u]=d)}),s.push(l)})}),new m(s)}leftJoin(e,i){if(this._groups.length>0||e._groups.length>0)throw new f("leftJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");i.forEach(t=>{this.verifyObservationsContainVariable(t),e.verifyObservationsContainVariable(t)});const r=new Map;e.observations.forEach(t=>{if(this.hasNullJoinKeys(t,i))return;const n=i.map(a=>JSON.stringify(this.normalizeForComparison(t[a]))).join("|"),o=r.get(n)||[];o.push(t),r.set(n,o)});const s=[];return this._observations.forEach(t=>{if(this.hasNullJoinKeys(t,i)){s.push({...t});return}const n=i.map(a=>JSON.stringify(this.normalizeForComparison(t[a]))).join("|"),o=r.get(n)||[];o.length>0?o.forEach(a=>{const l={...t};Object.entries(a).forEach(([u,d])=>{i.includes(u)||(l[u]=d)}),s.push(l)}):s.push({...t})}),new m(s)}rightJoin(e,i){if(this._groups.length>0||e._groups.length>0)throw new f("rightJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");i.forEach(n=>{this.verifyObservationsContainVariable(n),e.verifyObservationsContainVariable(n)});const r=new Map;e.observations.forEach(n=>{if(this.hasNullJoinKeys(n,i))return;const o=i.map(l=>JSON.stringify(this.normalizeForComparison(n[l]))).join("|"),a=r.get(o)||[];a.push(n),r.set(o,a)});const s=[],t=new Set;return this._observations.forEach(n=>{if(this.hasNullJoinKeys(n,i))return;const o=i.map(l=>JSON.stringify(this.normalizeForComparison(n[l]))).join("|"),a=r.get(o)||[];a.length>0&&(a.forEach(l=>{const u={...n};Object.entries(l).forEach(([d,p])=>{i.includes(d)||(u[d]=p)}),s.push(u)}),t.add(o))}),e.observations.forEach(n=>{if(this.hasNullJoinKeys(n,i)){s.push({...n});return}const o=i.map(a=>JSON.stringify(this.normalizeForComparison(n[a]))).join("|");t.has(o)||(s.push({...n}),t.add(o))}),new m(s)}fullJoin(e,i){if(this._groups.length>0||e._groups.length>0)throw new f("fullJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");i.forEach(n=>{this.verifyObservationsContainVariable(n),e.verifyObservationsContainVariable(n)});const r=new Map;e.observations.forEach(n=>{if(this.hasNullJoinKeys(n,i))return;const o=i.map(l=>JSON.stringify(this.normalizeForComparison(n[l]))).join("|"),a=r.get(o)||[];a.push(n),r.set(o,a)});const s=[],t=new Set;return this._observations.forEach(n=>{if(this.hasNullJoinKeys(n,i)){s.push({...n});return}const o=i.map(l=>JSON.stringify(this.normalizeForComparison(n[l]))).join("|"),a=r.get(o)||[];a.length>0?(a.forEach(l=>{const u={...n};Object.entries(l).forEach(([d,p])=>{i.includes(d)||(u[d]=p)}),s.push(u)}),t.add(o)):s.push({...n})}),e.observations.forEach(n=>{if(this.hasNullJoinKeys(n,i)){s.push({...n});return}const o=i.map(a=>JSON.stringify(this.normalizeForComparison(n[a]))).join("|");t.has(o)||(s.push({...n}),t.add(o))}),new m(s)}slice(e,i){if(this._groups.length>0)throw new f("slice() cannot be used on grouped data. Ungroup the data first using ungroup().");let r;if(e>=this._observations.length)return new m([],{groups:this._groups});if(i===void 0){const s=e<0?this._observations.length+e:e;r=[this._observations[s]]}else r=this._observations.slice(e,i);return new m(r,{groups:this._groups})}bindRows(e){if(this._observations.length>0&&e.observations.length>0){const i=new Set(Object.keys(this._observations[0])),r=new Set(Object.keys(e.observations[0]));[...i].filter(t=>r.has(t)).forEach(t=>{const n=this.getVariableType(t),o=e.getVariableType(t);n!==o&&console.warn(`Warning: bindRows() is combining datasets with different data types for variable '${t}'. Left dataset has type '${n}' and right dataset has type '${o}'.`)})}return new m([...this._observations,...e.observations])}getVariableType(e){if(this._observations.length===0)return"unknown";const i={};this._observations.forEach(t=>{if(e in t){const n=t[e],o=n===null?"null":Array.isArray(n)?"array":typeof n;i[o]=(i[o]||0)+1}});let r=0,s="unknown";for(const[t,n]of Object.entries(i))n>r&&(r=n,s=t);return s}verifyObservationsContainVariable(e){if(!this._observations.every(i=>e in i))throw new f(`Variable ${e} does not exist for each item (row) in the data array.`)}variableExists(e){return this._observations.some(i=>e in i)}isNonMissingNumeric(e){return typeof e=="number"&&!isNaN(e)&&isFinite(e)}isMissingNumeric(e){return typeof e=="number"&&(isNaN(e)||!isFinite(e))||e===null||typeof e>"u"}normalizeForComparison(e){return e===null||typeof e!="object"?e:Array.isArray(e)?e.map(i=>this.normalizeForComparison(i)):Object.keys(e).sort().reduce((i,r)=>(i[r]=this.normalizeForComparison(e[r]),i),{})}deepCopy(e,i=new WeakMap){if(e===null||typeof e!="object")return e;if(i.has(e))return i.get(e);const r=Array.isArray(e)?[]:Object.create(Object.getPrototypeOf(e));i.set(e,r);const s=[...Object.getOwnPropertyNames(e),...Object.getOwnPropertySymbols(e)];for(const t of s){const n=Object.getOwnPropertyDescriptor(e,t);n&&Object.defineProperty(r,t,{...n,value:this.deepCopy(e[t],i)})}return r}hasNullJoinKeys(e,i){return i.some(r=>e[r]===null||e[r]===void 0)}}const se={"+":1,"-":1,"*":2,"/":2,"^":3};class B{constructor(e,i,r,s){this.leafFn=e,this.parameters=i,this.options=r,s&&s.length>0?this.tokens=s.slice():e?this.tokens=[{t:"operand",v:this}]:this.tokens=[],this.summarizeFunction=t=>this.evaluateAsValue(t)}static leaf(e,i,r){return new B(e,i,r)}cloneWithTokens(e){return new B(void 0,void 0,void 0,e)}appendOp(e,i){const r=this.tokens.slice();return r.push({t:"op",v:e}),r.push({t:"operand",v:i}),this.cloneWithTokens(r)}add(e){return this.appendOp("+",e)}sub(e){return this.appendOp("-",e)}mul(e){return this.appendOp("*",e)}div(e){return this.appendOp("/",e)}pow(e){return this.appendOp("^",e)}evaluateOperandToNumber(e,i){if(typeof e=="number")return e;const r=Array.isArray(e.parameters)?e.parameters:e.parameters===void 0?void 0:[e.parameters],s=e.leafFn?e.leafFn(i,r,e.options):e.evaluateAsValue(i);if(s==null)return NaN;const t=Number(s);return typeof t=="number"&&!isNaN(t)?t:NaN}evaluateFlatTokens(e,i){const r=[],s=[];for(const n of e)n.t==="operand"?r.push(n.v):s.push(n.v);if(r.length===0)return NaN;for(;s.length>0;){let n=0,o=se[s[0]]??0;for(let O=1;O<s.length;O++){const D=se[s[O]]??0;(D>o||D===o&&s[O]==="^")&&(o=D,n=O)}const a=s.splice(n,1)[0],l=r.splice(n,1)[0],u=r.splice(n,1)[0],d=this.evaluateOperandToNumber(l,i),p=this.evaluateOperandToNumber(u,i);let y=NaN;a==="+"?y=d+p:a==="-"?y=d-p:a==="*"?y=d*p:a==="/"?y=p===0?NaN:d/p:a==="^"&&(y=Math.pow(d,p)),r.splice(n,0,y)}const t=r[0];return typeof t=="number"?t:this.evaluateOperandToNumber(t,i)}parens(){return me(this)}evaluateAsValue(e){if(this.leafFn){const r=Array.isArray(this.parameters)?this.parameters:this.parameters===void 0?void 0:[this.parameters],s=this.leafFn(e,r,this.options);return typeof s=="number"&&Number.isNaN(s)?null:s}if(!this.tokens||this.tokens.length===0)return NaN;const i=this.evaluateFlatTokens(this.tokens,e);return typeof i=="number"&&Number.isNaN(i)?null:i}}function me(c){const e=[{t:"operand",v:c}];return new B(void 0,void 0,void 0,e)}const _e={coerceBooleans:!0,skipMissing:!1};function X(c){return{..._e,...c}}function ge(c,e,i,r,s,t){const n=X(i);c.verifyObservationsContainVariable(e);let o=0,a=t,l=!1;return c.observations.forEach(u=>{if(c.isNonMissingNumeric(u[e])){a=r(u[e],a),o++;return}if(typeof u[e]=="boolean"&&n.coerceBooleans){a=r(u[e]?1:0,a),o++;return}if(c.isMissingNumeric(u[e])){l=!0;return}throw new f(`${s}: variable ${e} has non-numeric value ${u[e]} in this observation: ${JSON.stringify(u)}`)}),{state:a,count:o,containsMissing:l}}function Te(c,e,i,r,s){const t=X(e);let n=s,o=0,a=!1;for(const l of c)if(typeof l=="number"&&!isNaN(l)&&isFinite(l))n=i(l,n),o++;else if(typeof l=="boolean"&&t.coerceBooleans)n=i(l?1:0,n),o++;else if(l==null||typeof l=="number"&&(isNaN(l)||!isFinite(l)))a=!0;else throw new f(`${r}: has non-numeric value ${l}`);return{state:n,count:o,containsMissing:a}}function oe(c,e,i){const r=X(e);if(typeof c=="number"&&!isNaN(c)&&isFinite(c))return{value:c,isMissing:!1};if(typeof c=="boolean"&&r.coerceBooleans)return{value:c?1:0,isMissing:!1};if(c==null||typeof c=="number"&&(isNaN(c)||!isFinite(c)))return{value:0,isMissing:!0};throw new f(`${i}: has non-numeric value ${c}`)}const Ee=(c,e,i)=>{const r=e?e[0]:void 0,s=X(i);if(typeof r=="string"){if(!c.variableExists(r))return null;const n=ge(c,r,i,(o,a)=>a+o,"sum()",0);return n.containsMissing&&!s.skipMissing||n.count===0?null:n.state}else if(Array.isArray(r)){const t=Te(r,i,(n,o)=>o+n,"sum()",0);return t.containsMissing&&!s.skipMissing||t.count===0?null:t.state}else{const t=oe(r,i,"sum()");return t.isMissing&&!s.skipMissing||t.isMissing?null:t.value}};function be(c,e){return B.leaf(Ee,[c],e)}const ye=(c,e,i)=>{const r=e?e[0]:void 0,s=X(i);if(typeof r=="string"){if(!c.variableExists(r))return null;const t=r;c.verifyObservationsContainVariable(t);const n=[];let o=!1;if(c.observations.forEach(l=>{if(c.isNonMissingNumeric(l[t]))n.push(l[t]);else if(typeof l[t]=="boolean"&&s.coerceBooleans)n.push(l[t]?1:0);else if(c.isMissingNumeric(l[t]))o=!0;else throw new f(`median(): variable ${t} has non-numeric value ${l[t]} in this observation: ${JSON.stringify(l)}`)}),o&&!s.skipMissing||n.length===0)return null;n.sort((l,u)=>l-u);const a=Math.floor(n.length/2);return n.length%2===0?(n[a-1]+n[a])/2:n[a]}else if(Array.isArray(r)){const t=[];let n=!1;for(const a of r)if(typeof a=="number"&&!isNaN(a)&&isFinite(a))t.push(a);else if(typeof a=="boolean"&&s.coerceBooleans)t.push(a?1:0);else if(a==null||typeof a=="number"&&(isNaN(a)||!isFinite(a)))n=!0;else throw new f(`median(): has non-numeric value ${a}`);if(n&&!s.skipMissing||t.length===0)return null;t.sort((a,l)=>a-l);const o=Math.floor(t.length/2);return t.length%2===0?(t[o-1]+t[o])/2:t[o]}else{const t=oe(r,i,"median()");return t.isMissing&&!s.skipMissing||t.isMissing?null:t.value}};function we(c,e){return B.leaf(ye,[c],e)}console.log("\u26AA @m2c2kit/data-calc version 0.8.6 (c86b5047)");class Ne extends ce{constructor(){const e={number_of_dots:{type:"integer",default:3,description:"Number of dots to present."},preparation_duration_ms:{type:"number",default:500,description:"How long the 'get ready' message before each trial is shown, milliseconds."},blank_grid_duration_ms:{type:"number",default:500,description:"How long a blank grid is shown before the dots appear, milliseconds."},interference_duration_ms:{type:"number",default:8e3,description:"How long the grid of interference targets is shown, milliseconds."},interference_transition_animation:{type:"boolean",default:!0,description:"Should the transitions between dot presentation, interference, and recall be animated slide transitions?"},dot_present_duration_ms:{type:"number",default:3e3,description:"How long the dots are shown, milliseconds."},number_of_interference_targets:{type:"integer",default:5,description:"How many targets to show in the interference phase."},number_of_trials:{type:"integer",default:4,description:"How many trials to run."},show_trials_complete_scene:{default:!0,type:"boolean",description:"After the final trial, should a completion scene be shown? Otherwise, the game will immediately end."},instruction_type:{type:"string",default:"long",description:"Type of instructions to show, 'short' or 'long'."},instructions:{default:null,type:["object","null"],description:"When non-null, an InstructionsOptions object that will completely override the built-in instructions."},show_quit_button:{type:"boolean",default:!1,description:"Should the activity quit button be shown?"},show_fps:{type:"boolean",default:!1,description:"Should the FPS be shown?"},show_locale_picker:{type:"boolean",default:!1,description:"Should the icon that allows the participant to switch the locale be shown?"},scoring:{type:"boolean",default:!1,description:"Should scoring data be generated? Default is false."},seed:{type:["string","null"],default:null,description:"Optional seed for the seeded pseudo-random number generator. When null, the default Math.random() is used."}},i={activity_begin_iso8601_timestamp:{type:"string",format:"date-time",description:"ISO 8601 timestamp at the beginning of the game activity."},trial_begin_iso8601_timestamp:{type:["string","null"],format:"date-time",description:"ISO 8601 timestamp at the beginning of the trial. Null if trial was skipped."},trial_end_iso8601_timestamp:{type:["string","null"],format:"date-time",description:"ISO 8601 timestamp at the end of the trial (when user presses 'Done' after placing the three objects). Null if trial was skipped."},trial_index:{type:["integer","null"],description:"Index of the trial within this assessment, 0-based."},response_time_duration_ms:{type:["number","null"],description:"Milliseconds from the when the empty grid is shown in the recall phase until the user has placed all dots and taps the done button. Null if trial was skipped."},presented_cells:{type:["array","null"],description:"Randomly chosen locations of the dots presented to the user. Null if trial was skipped.",items:{type:"object",properties:{row:{type:"integer",description:"Row of the cell, 0-indexed."},column:{type:"integer",description:"Column of the cell, 0-indexed."}}}},selected_cells:{type:["array","null"],description:"User selected locations of the dots. Null if trial was skipped.",items:{type:"object",properties:{row:{type:"integer",description:"Row of the cell, 0-indexed."},column:{type:"integer",description:"Column of the cell, 0-indexed."}}}},user_dot_actions:{type:["array","null"],description:"Complete user dot actions: placement, removal, and done. Null if trial was skipped.",items:{type:"object",properties:{elapsed_duration_ms:{type:"number",description:"Duration, milliseconds, from when dot recall scene fully appeared until this user action."},action_type:{type:"string",enum:["placed","removed","done"],description:"Was the action a dot placement, dot removal, or done button push?"},cell:{type:["object","null"],description:"Cell of user action; null if non-applicable (user action was done button push).",properties:{row:{type:"integer",description:"Row of the cell, 0-indexed."},column:{type:"integer",description:"Column of the cell, 0-indexed."},tap_x:{type:"number",description:"X coordinate of user's tap on the cell, relative to the cell."},tap_y:{type:"number",description:"Y coordinate of user's tap on the cell, relative to the cell."}}}}}},user_interference_actions:{type:["array","null"],description:"User actions tapping the interference targets. Null if trial was skipped.",items:{type:"object",properties:{elapsed_duration_ms:{type:"number",description:"Duration, milliseconds, from when interference scene fully appeared until this user action."},action_type:{type:"string",enum:["on-target","off-target"],description:"Was the action on an interference target or off?"},cell:{type:"object",description:"Cell of user interference action.",properties:{row:{type:"integer",description:"Row of the cell, 0-indexed."},column:{type:"integer",description:"Column of the cell, 0-indexed."},tap_x:{type:"number",description:"X coordinate of user's tap on the cell, relative to the cell."},tap_y:{type:"number",description:"Y coordinate of user's tap on the cell, relative to the cell."}}}}}},number_of_correct_dots:{type:["integer","null"],description:"Number of dots that were correctly placed. Null if trial was skipped."},quit_button_pressed:{type:"boolean",description:"Was the quit button pressed?"}},r={activity_begin_iso8601_timestamp:{type:"string",format:"date-time",description:"ISO 8601 timestamp at the beginning of the game activity."},first_trial_begin_iso8601_timestamp:{type:["string","null"],format:"date-time",description:"ISO 8601 timestamp at the beginning of the first trial. Null if no trials were completed."},last_trial_end_iso8601_timestamp:{type:["string","null"],format:"date-time",description:"ISO 8601 timestamp at the end of the last trial. Null if no trials were completed."},n_trials:{type:"integer",description:"Number of trials completed."},n_trials_exact_targets:{type:"integer",description:"Number of trials in which the user selected the exact target cells without error."},flag_trials_match_expected:{type:"integer",description:"Does the number of completed and expected trials match? 1 = true, 0 = false."},distance_hausdorff_median:{type:["number","null"],description:"Median across all trials of the Hausdorff distance between the presented and selected cells within a trial."},sum_exact_targets:{type:["integer","null"],description:"Sum of the number of exact targets across all trials. An exact target is a target that was selected in the correct location."},percent_exact_targets:{type:["number","null"],description:"Percent of exact targets out of all targets across all trials. An exact target is a target that was selected in the correct location."}},s={configuration:{baseLocale:"en-US"},"en-US":{localeName:"English",INSTRUCTIONS_TITLE:"Grid Memory",INSTRUCTIONS_TEXT_PAGE_1:"For this activity, try to remember the location of {{NUMBER_OF_DOTS}} dots.",INSTRUCTIONS_TEXT_PAGE_2:"Before placing the {{NUMBER_OF_DOTS}} dots in their location, you will also have to tap some Fs on the screen as quickly as you can.",INSTRUCTIONS_TEXT_PAGE_3:"Press START to begin!",GET_READY:"GET READY",REMEMBER_LOCATIONS:"Remember the dot locations!",TOUCH_INTERFERENCE:"Touch the F's!",DONE_BUTTON_TEXT:"Done",WHERE_WERE:"Where were the dots?",MUST_SELECT:"You must select all {{NUMBER_OF_DOTS}} locations!",START_BUTTON_TEXT:"START",NEXT_BUTTON_TEXT:"Next",BACK_BUTTON_TEXT:"Back",TRIALS_COMPLETE_SCENE_TEXT:"This activity is complete.",TRIALS_COMPLETE_SCENE_BUTTON_TEXT:"OK"},"es-MX":{localeName:"Espa\xF1ol",INSTRUCTIONS_TITLE:"Memoria de Puntos",INSTRUCTIONS_TEXT_PAGE_1:"Para esta actividad, intenta recordar la ubicaci\xF3n de {{NUMBER_OF_DOTS}} puntos.",INSTRUCTIONS_TEXT_PAGE_2:"Antes de colocar los {{NUMBER_OF_DOTS}} puntos en su ubicaci\xF3n, tambi\xE9n tendr\xE1s que tocar las Fs en la pantalla lo m\xE1s r\xE1pido que puedas.",INSTRUCTIONS_TEXT_PAGE_3:"Presione COMENZAR para Empezar",GET_READY:"PREP\xC1RESE",REMEMBER_LOCATIONS:"Recuerda las ubicaciones de los puntos",TOUCH_INTERFERENCE:"\xA1Toca las Fs!",DONE_BUTTON_TEXT:"Listo",WHERE_WERE:"\xBFD\xF3nde estaban los puntos?",MUST_SELECT:"\xA1Debes seleccionar todas las {{NUMBER_OF_DOTS}} ubicaciones!",START_BUTTON_TEXT:"COMENZAR",NEXT_BUTTON_TEXT:"Siguiente",BACK_BUTTON_TEXT:"Atr\xE1s",TRIALS_COMPLETE_SCENE_TEXT:"Esta actividad est\xE1 completa.",TRIALS_COMPLETE_SCENE_BUTTON_TEXT:"OK"},"de-DE":{localeName:"Deutsch",INSTRUCTIONS_TITLE:"Raster-Ged\xE4chtnis",INSTRUCTIONS_TEXT_PAGE_1:"In dieser Aufgabe werden {{NUMBER_OF_DOTS}} rote Punkte kurz in einem Raster erscheinen. Ihre Aufgabe ist es, sich ihre Standorte zu merken!",INSTRUCTIONS_TEXT_PAGE_2:"Als n\xE4chstes werden Sie eine Seite voll mit den Buchstaben E und F sehen, wie auf dem Beispiel unten. Ihre Aufgabe ist es, so schnell wie m\xF6glich auf alle F's zu tippen!",INSTRUCTIONS_TEXT_PAGE_3:"Sobald das leere Raster erscheint, platzieren Sie die Punkte dort, wo Sie sie zuvor gesehen haben, indem Sie auf die entsprechenden Stellen tippen.",GET_READY:"BEREIT MACHEN",REMEMBER_LOCATIONS:"Merken Sie sich die Punktpositionen!",TOUCH_INTERFERENCE:"Ber\xFChren die F's!",DONE_BUTTON_TEXT:"Fertig",WHERE_WERE:"Wo waren die Punkte?",MUST_SELECT:"Sie m\xFCssen alle {{NUMBER_OF_DOTS}} Punktpositionen ausw\xE4hlen!",START_BUTTON_TEXT:"START",NEXT_BUTTON_TEXT:"Weiter",BACK_BUTTON_TEXT:"Vorherige",TRIALS_COMPLETE_SCENE_TEXT:"Die Aufgabe ist beendet.",TRIALS_COMPLETE_SCENE_BUTTON_TEXT:"OK"},"it-IT":{localeName:"Italiano",INSTRUCTIONS_TITLE:"Griglia di memoria",INSTRUCTIONS_TEXT_PAGE_1:"Per questa attivit\xE0, cerca di ricordare la posizione di {{NUMBER_OF_DOTS}} punti.",INSTRUCTIONS_TEXT_PAGE_2:"Prima di piazzare i {{NUMBER_OF_DOTS}} punti al loro posto, dovrai toccare delle lettere 'F' sullo schermo, il pi\xF9 velocemente possibile.",INSTRUCTIONS_TEXT_PAGE_3:"Premi INIZIA per cominciare!",GET_READY:"PREPARATI",REMEMBER_LOCATIONS:"Ricorda la posizione dei punti!",TOUCH_INTERFERENCE:"Tocca le F!",DONE_BUTTON_TEXT:"Fatto",WHERE_WERE:"Dove erano i punti?",MUST_SELECT:"Devi selezionare tutte le {{NUMBER_OF_DOTS}} posizioni!",START_BUTTON_TEXT:"INIZIA",NEXT_BUTTON_TEXT:"Avanti",BACK_BUTTON_TEXT:"Indietro",TRIALS_COMPLETE_SCENE_TEXT:"Attivit\xE0 completata.",TRIALS_COMPLETE_SCENE_BUTTON_TEXT:"OK"}},t=200,n={name:"Grid Memory",id:"grid-memory",publishUuid:"50ee0af4-d013-408f-a7d1-c8d5c04da920",version:"0.8.33 (c86b5047)",moduleMetadata:{name:"@m2c2kit/assessment-grid-memory",version:"0.8.33",dependencies:{"@m2c2kit/addons":"0.3.34","@m2c2kit/core":"0.3.35","@m2c2kit/data-calc":"0.8.6"}},translation:s,shortDescription:"Grid Memory is a visuospatial working memory task, with delayed free recall. After a brief exposure, and a short distraction phase, participants report the location of dots on a grid.",longDescription:'Each trial of the dot memory task consisted of 3 phases: encoding,   distraction, and retrieval. During the encoding phase, the participant was   asked to remember the location three red dots appear on a 5 x 5 grid. After   a 3-second study period, the grid was removed and the distraction phase   began, during which the participant was required to locate and touch Fs among   an array of Es. After performing the distraction task for 8 seconds, and   empty 5 x 5 grid reappeared on the screen and participants were then   prompted to recall the locations of the 3 dots presented initially and press   a button labeled "Done" after entering their responses to complete the trial.   Participants completed 2 trials (encoding, distractor, retrieval) with a   1-second delay between trials. The dependent variable was an error score with   partial credit given based on the deviation from the correct positions. If   all dots were recalled in their correct location, the participant received a   score of zero. In the case of one or more retrieval errors, Euclidean distance   of the location of the incorrect dot to the correct grid location was   calculated, with higher scores indicating less accurate placement and poorer   performance (Siedlecki, 2007). The rationale for our use of this task as an   indicator of working memory has both an empirical and theoretical basis.   Previous research (Miyake, Friedman, Rettinger, Shah, & Hegarty, 2001) has   demonstrated that a similar dotmemory task loaded on a factor representing   working memory. The authors of this study reasoned that the spatial dot   memory task placed high demands on controlled attention\u2014a hallmark of working   memory tasks. Indeed, individual differences in working memory capacity arise   "in situations where information needs to be actively maintained or when a   controlled search of memory is required" (Unsworth & Engle, 2007, p. 123).   The ambulatory dot memory task satisfies this requirement by using an   interference task to prevent rehearsal and produce interference with encoded   locations, which creates the demand for active maintenance and controlled   retrieval of previously encoded location during the recall phase.   SOURCE: Sliwinski, Martin J., Jacqueline A. Mogle, Jinshil Hyun, Elizabeth   Munoz, Joshua M. Smyth, and Richard B. Lipton. "Reliability and validity of   ambulatory cognitive assessments." Assessment 25, no. 1 (2018): 14-30.',showFps:e.show_fps.default,width:400,height:800,trialSchema:i,scoringSchema:r,parameters:e,fonts:[{fontName:"roboto",url:"fonts/roboto/Roboto-Regular.ttf"}],images:[{imageName:"grid",height:t,width:t,url:"images/dotmem1_grid.png"},{imageName:"fs",height:t,width:t,url:"images/dotmem2_fs.png"},{imageName:"circle-x",height:32,width:32,url:"images/circle-x.svg"}]};super(n)}async initialize(){await super.initialize();const e=this,i=e.getParameter("seed");typeof i=="string"&&J.setSeed(i);let r,s,t,n;const o=e.getParameter("number_of_dots");if(e.getParameter("show_quit_button")){const h=new ue({imageName:"circle-x",position:{x:380,y:20},isUserInteractionEnabled:!0});e.addFreeNode(h),h.onTapDown(b=>{e.removeAllFreeNodes(),b.handled=!0;const T=new F;if(e.addScene(T),e.presentScene(T),e.addTrialData("quit_button_pressed",!0),e.trialComplete(),e.getParameter("scoring")){const g=e.calculateScores([],{numberOfDots:e.getParameter("number_of_dots"),numberOfTrials:e.getParameter("number_of_trials")});e.addScoringData(g),e.scoringComplete()}e.cancel()})}let a;e.getParameter("show_locale_picker")&&(a=new he,e.addFreeNode(a));let l;const u=e.getParameter("instructions");if(u)l=ie.create(u);else{if(!this.i18n)throw new de("No i18n object found.");l=ie.create({instructionScenes:[{title:"INSTRUCTIONS_TITLE",text:"INSTRUCTIONS_TEXT_PAGE_1",textInterpolation:{NUMBER_OF_DOTS:o.toString()},imageName:"grid",imageAboveText:!1,imageMarginTop:12,textFontSize:24,titleFontSize:30,textVerticalBias:.25,nextButtonText:"NEXT_BUTTON_TEXT",backButtonText:"BACK_BUTTON_TEXT"},{title:"INSTRUCTIONS_TITLE",text:"INSTRUCTIONS_TEXT_PAGE_2",textInterpolation:{NUMBER_OF_DOTS:o.toString()},imageName:"fs",imageAboveText:!1,imageMarginTop:12,textFontSize:24,titleFontSize:30,textVerticalBias:.25,nextButtonText:"NEXT_BUTTON_TEXT",backButtonText:"BACK_BUTTON_TEXT"},{title:"INSTRUCTIONS_TITLE",text:"INSTRUCTIONS_TEXT_PAGE_3",textFontSize:24,titleFontSize:30,textAlignmentMode:pe.Center,nextButtonText:"START_BUTTON_TEXT",nextButtonBackgroundColor:N.Green,backButtonText:"BACK_BUTTON_TEXT"}]})}l[0].onAppear(()=>{e.addTrialData("activity_begin_iso8601_timestamp",this.beginIso8601Timestamp)}),e.addScenes(l);let d,p;e.getParameter("interference_transition_animation")&&(d=W.slide({direction:Q.Left,duration:500,easing:Z.sinusoidalInOut}),p=W.slide({direction:Q.Right,duration:500,easing:Z.sinusoidalInOut}));const y=new fe({milliseconds:3e3,text:"",zeroDwellMilliseconds:1e3,transition:W.none()});e.addScene(y);const O=new F;e.addScene(O);const D=new R({text:"GET_READY",fontSize:24,position:{x:200,y:400}});O.addChild(D),O.onAppear(()=>{O.run(_.sequence([_.custom({callback:()=>{e.addTrialData("activity_begin_iso8601_timestamp",this.beginIso8601Timestamp),e.addTrialData("trial_begin_iso8601_timestamp",new Date().toISOString())}}),_.wait({duration:e.getParameter("preparation_duration_ms")}),_.custom({callback:()=>{e.presentScene(x)}})]))});const x=new F;e.addScene(x);const L=new R({text:"REMEMBER_LOCATIONS",fontSize:24,position:{x:200,y:150}});x.addChild(L);const K=new ee({size:{width:300,height:300},position:{x:200,y:400},rows:5,columns:5,backgroundColor:N.Silver,gridLineColor:N.Black,gridLineWidth:4});x.addChild(K),x.onSetup(()=>{L.hidden=!0}),x.onAppear(()=>{L.hidden=!1,x.run(_.sequence([_.wait({duration:e.getParameter("blank_grid_duration_ms")}),_.custom({callback:()=>{r=J.fromGridWithoutReplacement(o,5,5);for(let h=0;h<o;h++){const b=new $({circleOfRadius:20,fillColor:N.Red,strokeColor:N.Black,lineWidth:2});K.addAtCell(b,r[h].row,r[h].column)}}}),_.wait({duration:e.getParameter("dot_present_duration_ms")}),_.custom({callback:()=>{K.removeAllGridChildren(),L.hidden=!0,e.presentScene(A,d)}})]))});const A=new F;e.addScene(A);const q=new R({text:"TOUCH_INTERFERENCE",fontSize:24,position:{x:200,y:100}});A.addChild(q);const I=new ee({size:{width:300,height:480},position:{x:200,y:400},rows:8,columns:5,backgroundColor:N.Transparent,gridLineColor:N.Transparent});A.addChild(I);const te=new Array;for(let h=0;h<10;h++)te.push(J.fromGridWithoutReplacement(e.getParameter("number_of_interference_targets"),8,5));A.onSetup(()=>{n=new Array,S.startNew("interferenceResponseTime"),q.hidden=!0,h(),A.run(_.sequence([_.wait({duration:e.getParameter("interference_duration_ms")}),_.custom({callback:()=>{S.remove("interferenceResponseTime"),e.presentScene(C,p)}})]),"advanceAfterInterference");function h(b=!1){I.removeAllGridChildren();let T=0;const g=e.getParameter("number_of_interference_targets");let E=te.pop();E||(E=J.fromGridWithoutReplacement(g,8,5));for(let k=0;k<8;k++)for(let U=0;U<5;U++){const w=new $({rect:{size:{width:59,height:59}},fillColor:N.Transparent});let ne=!1,j;j=new R({text:"E",fontSize:50});for(let v=0;v<g;v++)E[v].row===k&&E[v].column===U&&(j=new R({text:"F",fontSize:50}),ne=!0);w.userData={},w.userData.row=k,w.userData.column=U,ne?w.userData.tapStatus=0:w.userData.tapStatus=-1,w.isUserInteractionEnabled=!0,w.onTapDown(v=>{w.userData.tapStatus===0?(T++,j.text="E",j.run(_.sequence([_.scale({scale:1.25,duration:125}),_.scale({scale:1,duration:125})])),w.userData.tapStatus=1,T>=g&&(I.gridChildren.forEach(le=>{le.node.isUserInteractionEnabled=!1}),h(!0)),S.exists("interferenceResponseTime")&&n.push({elapsed_duration_ms:S.elapsed("interferenceResponseTime"),action_type:"on-target",cell:{row:w.userData.row,column:w.userData.column,tap_x:v.point.x,tap_y:v.point.y}})):S.exists("interferenceResponseTime")&&n.push({elapsed_duration_ms:S.elapsed("interferenceResponseTime"),action_type:"off-target",cell:{row:w.userData.row,column:w.userData.column,tap_x:v.point.x,tap_y:v.point.y}})}),I.addAtCell(j,k,U),I.addAtCell(w,k,U)}b&&(I.position={x:200,y:1040},I.run(_.move({point:{x:200,y:400},duration:500})))}}),A.onAppear(()=>{q.hidden=!1});const C=new F;e.addScene(C);const H=new R({text:"WHERE_WERE",fontSize:24,position:{x:200,y:150}});C.addChild(H);const Y=new ee({size:{width:300,height:300},position:{x:200,y:400},rows:5,columns:5,backgroundColor:N.Silver,gridLineColor:N.Black,gridLineWidth:4});C.addChild(Y);let P=0;C.onSetup(()=>{S.startNew("responseTime"),Y.removeAllGridChildren(),z.hidden=!0,H.hidden=!0,P=0,s=new Array,t=new Array;for(let h=0;h<5;h++)for(let b=0;b<5;b++){const T=new $({rect:{size:{width:59,height:59}},fillColor:N.Transparent});T.userData=0,T.onTapDown(g=>{if(T.userData===0&&P<o){const E=new $({circleOfRadius:20,fillColor:N.Red,strokeColor:N.Black,lineWidth:2});T.addChild(E),T.userData=1,P++,s.push({row:h,column:b}),t.push({elapsed_duration_ms:S.elapsed("responseTime"),action_type:"placed",cell:{row:h,column:b,tap_x:g.point.x,tap_y:g.point.y}})}else T.userData===1&&(T.removeAllChildren(),T.userData=0,P--,s=s.filter(E=>!(E.row===h&&E.column===b)),t.push({elapsed_duration_ms:S.elapsed("responseTime"),action_type:"removed",cell:{row:h,column:b,tap_x:g.point.x,tap_y:g.point.y}}))}),T.isUserInteractionEnabled=!0,Y.addAtCell(T,h,b)}}),C.onAppear(()=>{z.hidden=!1,H.hidden=!1});const z=new re({text:"DONE_BUTTON_TEXT",position:{x:200,y:700},size:{width:250,height:50}});C.addChild(z);const V=new R({text:"MUST_SELECT",interpolation:{NUMBER_OF_DOTS:o.toString()},position:{x:200,y:600},hidden:!0});C.addChild(V),z.isUserInteractionEnabled=!0,z.onTapDown(()=>{const h=S.elapsed("responseTime");if(t.push({elapsed_duration_ms:h,action_type:"done",cell:null}),P<o)V.run(_.sequence([_.custom({callback:()=>{V.hidden=!1}}),_.wait({duration:3e3}),_.custom({callback:()=>{V.hidden=!0}})]));else{S.stop("responseTime"),S.remove("responseTime"),e.addTrialData("trial_end_iso8601_timestamp",new Date().toISOString()),e.addTrialData("response_time_duration_ms",h),e.addTrialData("presented_cells",r),e.addTrialData("selected_cells",s),e.addTrialData("user_dot_actions",t),e.addTrialData("user_interference_actions",n);const b=(g,E)=>g.row===E.row&&g.column===E.column,T=s.map(g=>r.some(E=>b(E,g))?1:0).reduce((g,E)=>g+E,0);if(e.addTrialData("number_of_correct_dots",T),e.addTrialData("quit_button_pressed",!1),e.addTrialData("trial_index",e.trialIndex),e.trialComplete(),e.trialIndex===e.getParameter("number_of_trials")){if(e.getParameter("scoring")){const E=e.calculateScores(e.data.trials,{numberOfDots:e.getParameter("number_of_dots"),numberOfTrials:e.getParameter("number_of_trials")});e.addScoringData(E),e.scoringComplete()}const g=W.slide({direction:Q.Left,duration:500,easing:Z.sinusoidalInOut});e.getParameter("show_trials_complete_scene")?e.presentScene(M,g):e.end()}else e.presentScene(O)}});const M=new F;e.addScene(M);const ae=new R({text:"TRIALS_COMPLETE_SCENE_TEXT",position:{x:200,y:400}});M.addChild(ae);const G=new re({text:"TRIALS_COMPLETE_SCENE_BUTTON_TEXT",position:{x:200,y:600}});G.isUserInteractionEnabled=!0,G.onTapDown(()=>{G.isUserInteractionEnabled=!1,M.removeAllChildren(),e.end()}),M.addChild(G),M.onSetup(()=>{e.removeAllFreeNodes()})}calculateScores(e,i){const r=new m(e),s=e.map(n=>{const o=n.presented_cells,a=n.selected_cells;return o.length===0||a.length===0?{hausdorff_distance:null}:{hausdorff_distance:Se(o,a)}});return r.summarize({activity_begin_iso8601_timestamp:this.beginIso8601Timestamp,first_trial_begin_iso8601_timestamp:r.arrange("trial_begin_iso8601_timestamp").slice(0).pull("trial_begin_iso8601_timestamp"),last_trial_end_iso8601_timestamp:r.arrange("-trial_end_iso8601_timestamp").slice(0).pull("trial_end_iso8601_timestamp"),n_trials:r.length,flag_trials_match_expected:r.length===i.numberOfTrials?1:0,distance_hausdorff_median:we(new m(s).pull("hausdorff_distance")),n_trials_exact_targets:r.filter(n=>n.number_of_correct_dots===i.numberOfDots).length,sum_exact_targets:be("number_of_correct_dots")}).mutate({percent_exact_targets:n=>n.n_trials===0?null:n.sum_exact_targets/(n.n_trials*i.numberOfDots)}).observations}}function Se(c,e){if(c.length===0||e.length===0)return 1/0;function i(n,o){const a=n.row-o.row,l=n.column-o.column;return Math.sqrt(a*a+l*l)}function r(n,o){return n.reduce((a,l)=>{const u=o.reduce((d,p)=>{const y=i(l,p);return y<d?y:d},1/0);return u>a?u:a},0)}const s=r(c,e),t=r(e,c);return Math.max(s,t)}export{Ne as GridMemory};
