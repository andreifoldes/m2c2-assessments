{"version":3,"file":"index.js","sources":["../../data-calc/dist/index.js","../src/index.ts"],"sourcesContent":["class M2Error extends Error {\n  constructor(...params) {\n    super(...params);\n    this.name = \"M2Error\";\n    Object.setPrototypeOf(this, M2Error.prototype);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, M2Error);\n    }\n  }\n}\n\nclass DataCalc {\n  /**\n   * A class for transformation and calculation of m2c2kit data.\n   *\n   * @remarks The purpose is to provide a simple and intuitive interface for\n   * assessments to score and summarize their own data. It is not meant for\n   * data analysis or statistical modeling. The idiomatic approach is based on the\n   * dplyr R package.\n   *\n   * @param data - An array of observations, where each observation is a set of\n   * key-value pairs of variable names and values.\n   * @param options - Options, such as groups to group the data by\n   * @example\n   * ```js\n   * const dc = new DataCalc(gameData.trials);\n   * const mean_response_time_correct_trials = dc\n   *  .filter((obs) => obs.correct_response_index === obs.user_response_index)\n   *  .summarize({ mean_rt: mean(\"response_time_duration_ms\") })\n   *  .pull(\"mean_rt\");\n   * ```\n   */\n  constructor(data, options) {\n    this._groups = new Array();\n    if (!Array.isArray(data)) {\n      throw new M2Error(\n        \"DataCalc constructor expects an array of observations as first argument\"\n      );\n    }\n    for (let i = 0; i < data.length; i++) {\n      if (data[i] === null || typeof data[i] !== \"object\" || Array.isArray(data[i])) {\n        throw new M2Error(\n          `DataCalc constructor expects all elements to be objects (observations). Element at index ${i} is ${typeof data[i]}. Element: ${JSON.stringify(data[i])}`\n        );\n      }\n    }\n    this._observations = this.deepCopy(data);\n    const allVariables = /* @__PURE__ */ new Set();\n    for (const observation of data) {\n      for (const key of Object.keys(observation)) {\n        allVariables.add(key);\n      }\n    }\n    for (const observation of this._observations) {\n      for (const variable of allVariables) {\n        if (!(variable in observation)) {\n          observation[variable] = null;\n        }\n      }\n    }\n    if (options?.groups) {\n      this._groups = Array.from(options.groups);\n    }\n  }\n  /**\n   * Returns the groups in the data.\n   */\n  get groups() {\n    return this._groups;\n  }\n  /**\n   * Returns the observations in the data.\n   *\n   * @remarks An observation is conceptually similar to a row in a dataset,\n   * where the keys are the variable names and the values are the variable values.\n   */\n  get observations() {\n    return this._observations;\n  }\n  /**\n   * Alias for the observations property.\n   */\n  get rows() {\n    return this._observations;\n  }\n  /**\n   * Returns a single variable from the data.\n   *\n   * @remarks If the variable length is 1, the value is returned. If the\n   * variable has length > 1, an array of values is returned.\n   *\n   * @param variable - Name of variable to pull from the data\n   * @returns the value of the variable\n   *\n   * @example\n   * ```js\n   * const d = [{ a: 1, b: 2, c: 3 }];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.pull(\"c\")\n   * ); // 3\n   * ```\n   */\n  pull(variable) {\n    if (this._observations.length === 0) {\n      console.warn(\n        `DataCalc.pull(): No observations available to pull variable \"${variable}\" from. Returning null.`\n      );\n      return null;\n    }\n    this.verifyObservationsContainVariable(variable);\n    const values = this._observations.map((o) => o[variable]);\n    if (values.length === 1) {\n      return values[0];\n    }\n    return values;\n  }\n  /**\n   * Returns the number of observations in the data.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.length\n   * ); // 2\n   * ```\n   */\n  get length() {\n    return this._observations.length;\n  }\n  /**\n   * Filters observations based on a predicate function.\n   *\n   * @param predicate - A function that returns true for observations to keep and\n   * false for observations to discard\n   * @returns A new `DataCalc` object with only the observations that pass the\n   * predicate function\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.filter((obs) => obs.b >= 3).observations);\n   * // [ { a: 0, b: 8, c: 3 }, { a: 9, b: 4, c: 7 } ]\n   * ```\n   */\n  filter(predicate) {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `filter() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \"\n        )}. Ungroup the data first using ungroup().`\n      );\n    }\n    return new DataCalc(\n      this._observations.filter(\n        predicate\n      ),\n      { groups: this._groups }\n    );\n  }\n  /**\n   * Groups observations by one or more variables.\n   *\n   * @remarks This is used with the `summarize()` method to calculate summaries\n   * by group.\n   *\n   * @param groups - variable names to group by\n   * @returns A new `DataCalc` object with the observations grouped by one or\n   * more variables\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   *   { a: 5, b: 0, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * const grouped = dc.groupBy(\"c\");\n   * // subsequent summarize operations will be performed separately by\n   * // each unique level of c, in this case, 3 and 7\n   * ```\n   */\n  groupBy(...groups) {\n    groups.forEach((group) => {\n      this.verifyObservationsContainVariable(group);\n    });\n    return new DataCalc(this._observations, { groups });\n  }\n  /**\n   * Ungroups observations.\n   *\n   * @returns A new DataCalc object with the observations ungrouped\n   */\n  ungroup() {\n    return new DataCalc(this._observations);\n  }\n  /**\n   * Adds new variables to the observations based on the provided mutation options.\n   *\n   * @param mutations - An object where the keys are the names of the new variables\n   * and the values are functions that take an observation and return the value\n   * for the new variable.\n   * @returns A new DataCalc object with the new variables added to the observations.\n   *\n   * @example\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.mutate({ doubledA: (obs) => obs.a * 2 }).observations\n   * );\n   * // [ { a: 1, b: 2, c: 3, doubledA: 2 },\n   * //   { a: 0, b: 8, c: 3, doubledA: 0 },\n   * //   { a: 9, b: 4, c: 7, doubledA: 18 } ]\n   */\n  mutate(mutations) {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `mutate() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \"\n        )}. Ungroup the data first using ungroup().`\n      );\n    }\n    const newObservations = this._observations.map((observation) => {\n      let newObservation = { ...observation };\n      for (const [newVariable, transformFunction] of Object.entries(\n        mutations\n      )) {\n        newObservation = {\n          ...newObservation,\n          [newVariable]: transformFunction(observation)\n        };\n      }\n      return newObservation;\n    });\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n  /**\n   * Calculates summaries of the data.\n   *\n   * @param summarizations - An object where the keys are the names of the new\n   * variables and the values are `DataCalc` summary functions: `sum()`,\n   * `mean()`, `median()`, `variance()`, `sd()`, `min()`, `max()`, or `n()`.\n   * The summary functions take a variable name as a string, or alternatively,\n   * a value or array of values to summarize.\n   * @returns A new `DataCalc` object with the new summary variables.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   *   { a: 5, b: 0, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.summarize({\n   *     meanA: mean(\"a\"),\n   *     varA: variance(\"a\"),\n   *     totalB: sum(\"b\")\n   *   }).observations\n   * );\n   * // [ { meanA: 3.75, varA: 16.916666666666668, totalB: 14 } ]\n   *\n   * console.log(\n   *   dc.summarize({\n   *    filteredTotalC: sum(dc.filter(obs => obs.b > 2).pull(\"c\"))\n   *  }).observations\n   * );\n   * // [ { filteredTotalC: 10 } ]\n   * ```\n   */\n  summarize(summarizations) {\n    if (this._groups.length === 0) {\n      const obs = {};\n      for (const [newVariable, value] of Object.entries(summarizations)) {\n        if (typeof value === \"object\" && value !== null && \"summarizeFunction\" in value) {\n          const summarizeOperation = value;\n          obs[newVariable] = summarizeOperation.summarizeFunction(\n            this,\n            summarizeOperation.parameters,\n            summarizeOperation.options\n          );\n        } else {\n          obs[newVariable] = value;\n        }\n      }\n      return new DataCalc([obs], { groups: this._groups });\n    }\n    return this.summarizeByGroups(summarizations);\n  }\n  summarizeByGroups(summarizations) {\n    const groupMap = /* @__PURE__ */ new Map();\n    this._observations.forEach((obs) => {\n      const groupKey = this._groups.map(\n        (g) => typeof obs[g] === \"object\" ? JSON.stringify(obs[g]) : obs[g]\n      ).join(\"|\");\n      if (!groupMap.has(groupKey)) {\n        groupMap.set(groupKey, []);\n      }\n      const groupArray = groupMap.get(groupKey);\n      if (groupArray) {\n        groupArray.push(obs);\n      } else {\n        groupMap.set(groupKey, [obs]);\n      }\n    });\n    const summarizedObservations = [];\n    groupMap.forEach((groupObs, groupKey) => {\n      const groupValues = groupKey.split(\"|\");\n      const firstObs = groupObs[0];\n      const summaryObj = {};\n      this._groups.forEach((group, i) => {\n        const valueStr = groupValues[i];\n        const originalType = typeof firstObs[group];\n        if (originalType === \"number\") {\n          summaryObj[group] = Number(valueStr);\n        } else if (originalType === \"boolean\") {\n          summaryObj[group] = valueStr === \"true\";\n        } else if (valueStr.startsWith(\"{\") || valueStr.startsWith(\"[\")) {\n          try {\n            summaryObj[group] = JSON.parse(valueStr);\n          } catch {\n            throw new M2Error(\n              `Failed to parse group value ${valueStr} as JSON for group ${group}`\n            );\n          }\n        } else {\n          summaryObj[group] = valueStr;\n        }\n      });\n      const groupDataCalc = new DataCalc(groupObs);\n      for (const [newVariable, value] of Object.entries(summarizations)) {\n        if (typeof value === \"object\" && value !== null && \"summarizeFunction\" in value) {\n          const summarizeOperation = value;\n          summaryObj[newVariable] = summarizeOperation.summarizeFunction(\n            groupDataCalc,\n            summarizeOperation.parameters,\n            summarizeOperation.options\n          );\n        } else {\n          summaryObj[newVariable] = value;\n        }\n      }\n      summarizedObservations.push(summaryObj);\n    });\n    return new DataCalc(summarizedObservations, { groups: this._groups });\n  }\n  /**\n   * Selects specific variables to keep in the dataset.\n   * Variables prefixed with \"-\" will be excluded from the result.\n   *\n   * @param variables - Names of variables to select; prefix with '-' to exclude instead\n   * @returns A new DataCalc object with only the selected variables (minus excluded ones)\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3, d: 4 },\n   *   { a: 5, b: 6, c: 7, d: 8 }\n   * ];\n   * const dc = new DataCalc(d);\n   * // Keep a and c\n   * console.log(dc.select(\"a\", \"c\").observations);\n   * // [ { a: 1, c: 3 }, { a: 5, c: 7 } ]\n   * ```\n   */\n  select(...variables) {\n    const includeVars = [];\n    const excludeVars = [];\n    variables.forEach((variable) => {\n      if (variable.startsWith(\"-\")) {\n        excludeVars.push(variable.substring(1));\n      } else {\n        includeVars.push(variable);\n      }\n    });\n    const allVars = includeVars.length > 0 ? includeVars : Object.keys(this._observations[0] || {});\n    [...allVars, ...excludeVars].forEach((variable) => {\n      this.verifyObservationsContainVariable(variable);\n    });\n    const excludeSet = new Set(excludeVars);\n    const newObservations = this._observations.map((observation) => {\n      const newObservation = {};\n      if (includeVars.length > 0) {\n        includeVars.forEach((variable) => {\n          if (!excludeSet.has(variable)) {\n            newObservation[variable] = observation[variable];\n          }\n        });\n      } else {\n        Object.keys(observation).forEach((key) => {\n          if (!excludeSet.has(key)) {\n            newObservation[key] = observation[key];\n          }\n        });\n      }\n      return newObservation;\n    });\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n  /**\n   * Arranges (sorts) the observations based on one or more variables.\n   *\n   * @param variables - Names of variables to sort by, prefixed with '-' for descending order\n   * @returns A new DataCalc object with the observations sorted\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 5, b: 2 },\n   *   { a: 3, b: 7 },\n   *   { a: 5, b: 1 }\n   * ];\n   * const dc = new DataCalc(d);\n   * // Sort by a (ascending), then by b (descending)\n   * console.log(dc.arrange(\"a\", \"-b\").observations);\n   * // [ { a: 3, b: 7 }, { a: 5, b: 2 }, { a: 5, b: 1 } ]\n   * ```\n   */\n  arrange(...variables) {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `arrange() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \"\n        )}. Ungroup the data first using ungroup().`\n      );\n    }\n    const sortedObservations = [...this._observations].sort((a, b) => {\n      for (const variable of variables) {\n        let varName = variable;\n        let direction = 1;\n        if (variable.startsWith(\"-\")) {\n          varName = variable.substring(1);\n          direction = -1;\n        }\n        if (!(varName in a) || !(varName in b)) {\n          throw new M2Error(\n            `arrange(): variable ${varName} does not exist in all observations`\n          );\n        }\n        const aVal = a[varName];\n        const bVal = b[varName];\n        if (typeof aVal !== typeof bVal) {\n          return direction * (String(aVal) < String(bVal) ? -1 : 1);\n        }\n        if (aVal < bVal) return -1 * direction;\n        if (aVal > bVal) return 1 * direction;\n      }\n      return 0;\n    });\n    return new DataCalc(sortedObservations, { groups: this._groups });\n  }\n  /**\n   * Keeps only unique/distinct observations.\n   *\n   * @returns A new `DataCalc` object with only unique observations\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 1, b: 2, c: 3 }, // Duplicate\n   *   { a: 2, b: 3, c: 5 },\n   *   { a: 1, b: 2, c: { name: \"dog\" } },\n   *   { a: 1, b: 2, c: { name: \"dog\" } } // Duplicate with nested object\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.distinct().observations);\n   * // [ { a: 1, b: 2, c: 3 }, { a: 2, b: 3, c: 5 }, { a: 1, b: 2, c: { name: \"dog\" } } ]\n   * ```\n   */\n  distinct() {\n    const seen = /* @__PURE__ */ new Set();\n    const uniqueObs = this._observations.filter((obs) => {\n      const key = JSON.stringify(this.normalizeForComparison(obs));\n      if (seen.has(key)) return false;\n      seen.add(key);\n      return true;\n    });\n    return new DataCalc(uniqueObs, { groups: this._groups });\n  }\n  /**\n   * Renames variables in the observations.\n   *\n   * @param renames - Object mapping new variable names to old variable names\n   * @returns A new DataCalc object with renamed variables\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 4, b: 5, c: 6 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.rename({ x: 'a', z: 'c' }).observations);\n   * // [ { x: 1, b: 2, z: 3 }, { x: 4, b: 5, z: 6 } ]\n   * ```\n   */\n  rename(renames) {\n    if (this._observations.length === 0) {\n      throw new M2Error(\"Cannot rename variables on an empty dataset\");\n    }\n    Object.values(renames).forEach((oldName) => {\n      this.verifyObservationsContainVariable(oldName);\n    });\n    const newObservations = this._observations.map((observation) => {\n      const newObservation = {};\n      for (const [key, value] of Object.entries(observation)) {\n        const newKey = Object.entries(renames).find(\n          ([, old]) => old === key\n        )?.[0];\n        if (newKey) {\n          newObservation[newKey] = value;\n        } else if (!Object.values(renames).includes(key)) {\n          newObservation[key] = value;\n        }\n      }\n      return newObservation;\n    });\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n  /**\n   * Performs an inner join with another DataCalc object.\n   * Only rows with matching keys in both datasets are included.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.innerJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 } ]\n   * ```\n   */\n  innerJoin(other, by) {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `innerJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`\n      );\n    }\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n    const rightMap = /* @__PURE__ */ new Map();\n    other.observations.forEach((obs) => {\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(obs[k]))).join(\"|\");\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n    const result = [];\n    this._observations.forEach((leftObs) => {\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k]))).join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n      if (rightMatches.length > 0) {\n        rightMatches.forEach((rightObs) => {\n          const joinedObs = { ...leftObs };\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n          result.push(joinedObs);\n        });\n      }\n    });\n    return new DataCalc(result);\n  }\n  /**\n   * Performs a left join with another DataCalc object.\n   * All rows from the left dataset are included, along with matching rows from the right.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.leftJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 }, { id: 3, x: 'c' } ]\n   * ```\n   */\n  leftJoin(other, by) {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `leftJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`\n      );\n    }\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n    const rightMap = /* @__PURE__ */ new Map();\n    other.observations.forEach((obs) => {\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(obs[k]))).join(\"|\");\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n    const result = [];\n    this._observations.forEach((leftObs) => {\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        result.push({ ...leftObs });\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k]))).join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n      if (rightMatches.length > 0) {\n        rightMatches.forEach((rightObs) => {\n          const joinedObs = { ...leftObs };\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n          result.push(joinedObs);\n        });\n      } else {\n        result.push({ ...leftObs });\n      }\n    });\n    return new DataCalc(result);\n  }\n  /**\n   * Performs a right join with another DataCalc object.\n   * All rows from the right dataset are included, along with matching rows from the left.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.rightJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 }, { id: 4, y: 400 } ]\n   * ```\n   */\n  rightJoin(other, by) {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `rightJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`\n      );\n    }\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n    const rightMap = /* @__PURE__ */ new Map();\n    other.observations.forEach((obs) => {\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(obs[k]))).join(\"|\");\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n    const result = [];\n    const processedRightKeys = /* @__PURE__ */ new Set();\n    this._observations.forEach((leftObs) => {\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k]))).join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n      if (rightMatches.length > 0) {\n        rightMatches.forEach((rightObs) => {\n          const joinedObs = { ...leftObs };\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n          result.push(joinedObs);\n        });\n        processedRightKeys.add(key);\n      }\n    });\n    other.observations.forEach((rightObs) => {\n      if (this.hasNullJoinKeys(rightObs, by)) {\n        result.push({ ...rightObs });\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(rightObs[k]))).join(\"|\");\n      if (!processedRightKeys.has(key)) {\n        result.push({ ...rightObs });\n        processedRightKeys.add(key);\n      }\n    });\n    return new DataCalc(result);\n  }\n  /**\n   * Performs a full join with another DataCalc object.\n   * All rows from both datasets are included.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.fullJoin(dc2, [\"id\"]).observations);\n   * // [\n   * //   { id: 1, x: 'a', y: 100 },\n   * //   { id: 2, x: 'b', y: 200 },\n   * //   { id: 3, x: 'c' },\n   * //   { id: 4, y: 400 }\n   * // ]\n   * ```\n   */\n  fullJoin(other, by) {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `fullJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`\n      );\n    }\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n    const rightMap = /* @__PURE__ */ new Map();\n    other.observations.forEach((obs) => {\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(obs[k]))).join(\"|\");\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n    const result = [];\n    const processedRightKeys = /* @__PURE__ */ new Set();\n    this._observations.forEach((leftObs) => {\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        result.push({ ...leftObs });\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k]))).join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n      if (rightMatches.length > 0) {\n        rightMatches.forEach((rightObs) => {\n          const joinedObs = { ...leftObs };\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n          result.push(joinedObs);\n        });\n        processedRightKeys.add(key);\n      } else {\n        result.push({ ...leftObs });\n      }\n    });\n    other.observations.forEach((rightObs) => {\n      if (this.hasNullJoinKeys(rightObs, by)) {\n        result.push({ ...rightObs });\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(rightObs[k]))).join(\"|\");\n      if (!processedRightKeys.has(key)) {\n        result.push({ ...rightObs });\n        processedRightKeys.add(key);\n      }\n    });\n    return new DataCalc(result);\n  }\n  /**\n   * Slice observations by position.\n   *\n   * @param start - Starting position (0-based). Negative values count from\n   * the end.\n   * @param end - Ending position (exclusive)\n   * @returns A new DataCalc object with sliced observations\n   *\n   * @remarks If `end` is not provided, it will return a single observation at\n   * `start` position. If `start` is beyond the length of observations,\n   * it will return an empty DataCalc.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2 },\n   *   { a: 3, b: 4 },\n   *   { a: 5, b: 6 },\n   *   { a: 7, b: 8 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.slice(1, 3).observations);\n   * // [ { a: 3, b: 4 }, { a: 5, b: 6 } ]\n   * console.log(dc.slice(0).observations);\n   * // [ { a: 1, b: 2 } ]\n   * ```\n   */\n  slice(start, end) {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `slice() cannot be used on grouped data. Ungroup the data first using ungroup().`\n      );\n    }\n    let sliced;\n    if (start >= this._observations.length) {\n      return new DataCalc([], { groups: this._groups });\n    }\n    if (end === void 0) {\n      const index = start < 0 ? this._observations.length + start : start;\n      sliced = [this._observations[index]];\n    } else {\n      sliced = this._observations.slice(start, end);\n    }\n    return new DataCalc(sliced, { groups: this._groups });\n  }\n  /**\n   * Combines observations from two DataCalc objects by rows.\n   *\n   * @param other - The other DataCalc object to bind with\n   * @returns A new DataCalc object with combined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { a: 1, b: 2 },\n   *   { a: 3, b: 4 }\n   * ];\n   * const d2 = [\n   *   { a: 5, b: 6 },\n   *   { a: 7, b: 8 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.bindRows(dc2).observations);\n   * // [ { a: 1, b: 2 }, { a: 3, b: 4 }, { a: 5, b: 6 }, { a: 7, b: 8 } ]\n   * ```\n   */\n  bindRows(other) {\n    if (this._observations.length > 0 && other.observations.length > 0) {\n      const thisVariables = new Set(Object.keys(this._observations[0]));\n      const otherVariables = new Set(Object.keys(other.observations[0]));\n      const commonVariables = [...thisVariables].filter(\n        (variable) => otherVariables.has(variable)\n      );\n      commonVariables.forEach((variable) => {\n        const thisType = this.getVariableType(variable);\n        const otherType = other.getVariableType(variable);\n        if (thisType !== otherType) {\n          console.warn(\n            `Warning: bindRows() is combining datasets with different data types for variable '${variable}'. Left dataset has type '${thisType}' and right dataset has type '${otherType}'.`\n          );\n        }\n      });\n    }\n    return new DataCalc([...this._observations, ...other.observations]);\n  }\n  /**\n   * Helper method to determine the primary type of a variable across observations\n   * @internal\n   *\n   * @param variable - The variable name to check\n   * @returns The most common type for the variable or 'mixed' if no clear type exists\n   */\n  getVariableType(variable) {\n    if (this._observations.length === 0) {\n      return \"unknown\";\n    }\n    const typeCounts = {};\n    this._observations.forEach((obs) => {\n      if (variable in obs) {\n        const value = obs[variable];\n        const type = value === null ? \"null\" : Array.isArray(value) ? \"array\" : typeof value;\n        typeCounts[type] = (typeCounts[type] || 0) + 1;\n      }\n    });\n    let maxCount = 0;\n    let dominantType = \"unknown\";\n    for (const [type, count] of Object.entries(typeCounts)) {\n      if (count > maxCount) {\n        maxCount = count;\n        dominantType = type;\n      }\n    }\n    return dominantType;\n  }\n  /**\n   * Verifies that the variable exists in each observation in the data.\n   *\n   * @remarks Throws an error if the variable does not exist in each\n   * observation. This is not meant to be called by users of the library, but\n   * is used internally.\n   * @internal\n   *\n   * @param variable - The variable to check for\n   */\n  verifyObservationsContainVariable(variable) {\n    if (!this._observations.every((observation) => variable in observation)) {\n      throw new M2Error(\n        `Variable ${variable} does not exist for each item (row) in the data array.`\n      );\n    }\n  }\n  /**\n   * Checks if the variable exists for at least one observation in the data.\n   *\n   * @remarks This is not meant to be called by users of the library, but\n   * is used internally.\n   * @internal\n   *\n   * @param variable - The variable to check for\n   * @returns true if the variable exists in at least one observation, false\n   * otherwise\n   */\n  variableExists(variable) {\n    return this._observations.some((observation) => variable in observation);\n  }\n  /**\n   * Checks if a value is a non-missing numeric value.\n   *\n   * @remarks A non-missing numeric value is a value that is a number and is\n   * not NaN or infinite.\n   *\n   * @param value - The value to check\n   * @returns true if the value is a non-missing numeric value, false otherwise\n   */\n  isNonMissingNumeric(value) {\n    return typeof value === \"number\" && !isNaN(value) && isFinite(value);\n  }\n  /**\n   * Checks if a value is a missing numeric value.\n   *\n   * @remarks A missing numeric value is a number that is NaN or infinite, or any\n   * value that is null or undefined. Thus, a null or undefined value is\n   * considered to be a missing numeric value.\n   *\n   * @param value - The value to check\n   * @returns true if the value is a missing numeric value, false otherwise\n   */\n  isMissingNumeric(value) {\n    return typeof value === \"number\" && (isNaN(value) || !isFinite(value)) || value === null || typeof value === \"undefined\";\n  }\n  /**\n   * Normalizes an object for stable comparison by sorting keys\n   * @internal\n   *\n   * @remarks Normalizing is needed to handle situations where objects have the\n   * same properties but in different orders because we are using\n   * JSON.stringify() for comparison.\n   */\n  normalizeForComparison(obj) {\n    if (obj === null || typeof obj !== \"object\") {\n      return obj;\n    }\n    if (Array.isArray(obj)) {\n      return obj.map((item) => this.normalizeForComparison(item));\n    }\n    return Object.keys(obj).sort().reduce((result, key) => {\n      result[key] = this.normalizeForComparison(obj[key]);\n      return result;\n    }, {});\n  }\n  /**\n   * Creates a deep copy of an object.\n   * @internal\n   *\n   * @remarks We create a deep copy of the object, in our case an instance\n   * of `DataCalc`, to ensure that we are working with a new object\n   * without any references to the original object. This is important\n   * to avoid unintended side effects when modifying an object.\n   *\n   * @param source - object to copy\n   * @param map - map of objects that have already been copied\n   * @returns a deep copy of the object\n   */\n  deepCopy(source, map = /* @__PURE__ */ new WeakMap()) {\n    if (source === null || typeof source !== \"object\") {\n      return source;\n    }\n    if (map.has(source)) {\n      return map.get(source);\n    }\n    const copy = Array.isArray(source) ? [] : Object.create(Object.getPrototypeOf(source));\n    map.set(source, copy);\n    const keys = [\n      ...Object.getOwnPropertyNames(source),\n      ...Object.getOwnPropertySymbols(source)\n    ];\n    for (const key of keys) {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        source,\n        key\n      );\n      if (descriptor) {\n        Object.defineProperty(copy, key, {\n          ...descriptor,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          value: this.deepCopy(source[key], map)\n        });\n      }\n    }\n    return copy;\n  }\n  /**\n   * Checks if an observation has null or undefined values in any of the join columns.\n   * @internal\n   *\n   * @param obs - The observation to check\n   * @param keys - The join columns to check\n   * @returns true if any join column has a null or undefined value\n   */\n  hasNullJoinKeys(obs, keys) {\n    return keys.some((key) => obs[key] === null || obs[key] === void 0);\n  }\n}\n\nconst DEFAULT_SUMMARIZE_OPTIONS = {\n  coerceBooleans: true,\n  skipMissing: false\n};\nfunction applyDefaultOptions(options) {\n  return { ...DEFAULT_SUMMARIZE_OPTIONS, ...options };\n}\nfunction processNumericValues(dataCalc, variable, options, collector, errorPrefix, initialState) {\n  const mergedOptions = applyDefaultOptions(options);\n  dataCalc.verifyObservationsContainVariable(variable);\n  let count = 0;\n  let state = initialState;\n  let containsMissing = false;\n  dataCalc.observations.forEach((o) => {\n    if (dataCalc.isNonMissingNumeric(o[variable])) {\n      state = collector(o[variable], state);\n      count++;\n      return;\n    }\n    if (typeof o[variable] === \"boolean\" && mergedOptions.coerceBooleans) {\n      state = collector(o[variable] ? 1 : 0, state);\n      count++;\n      return;\n    }\n    if (dataCalc.isMissingNumeric(o[variable])) {\n      containsMissing = true;\n      return;\n    }\n    throw new M2Error(\n      `${errorPrefix}: variable ${variable} has non-numeric value ${o[variable]} in this observation: ${JSON.stringify(o)}`\n    );\n  });\n  return { state, count, containsMissing };\n}\nfunction processDirectValues(values, options, collector, errorPrefix, initialState) {\n  const mergedOptions = applyDefaultOptions(options);\n  let state = initialState;\n  let count = 0;\n  let containsMissing = false;\n  for (const value of values) {\n    if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n      state = collector(value, state);\n      count++;\n    } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n      state = collector(value ? 1 : 0, state);\n      count++;\n    } else if (value === null || value === void 0 || typeof value === \"number\" && (isNaN(value) || !isFinite(value))) {\n      containsMissing = true;\n    } else {\n      throw new M2Error(`${errorPrefix}: has non-numeric value ${value}`);\n    }\n  }\n  return { state, count, containsMissing };\n}\nfunction processSingleValue(value, options, errorPrefix) {\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n    return { value, isMissing: false };\n  } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n    return { value: value ? 1 : 0, isMissing: false };\n  } else if (value === null || value === void 0 || typeof value === \"number\" && (isNaN(value) || !isFinite(value))) {\n    return { value: 0, isMissing: true };\n  } else {\n    throw new M2Error(`${errorPrefix}: has non-numeric value ${value}`);\n  }\n}\nconst nInternal = (dataCalc) => {\n  return dataCalc.length;\n};\nfunction n() {\n  return {\n    summarizeFunction: nInternal,\n    parameters: []\n  };\n}\nconst sumInternal = (dataCalc, params, options) => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum2) => sum2 + value,\n      \"sum()\",\n      0\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, sum2) => sum2 + value,\n      \"sum()\",\n      0\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"sum()\");\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    return result.isMissing ? null : result.value;\n  }\n};\nfunction sum(variableOrValues, options) {\n  return {\n    summarizeFunction: sumInternal,\n    parameters: [variableOrValues],\n    options\n  };\n}\nconst meanInternal = (dataCalc, params, options) => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum2) => sum2 + value,\n      \"mean()\",\n      0\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state / result.count;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, sum2) => sum2 + value,\n      \"mean()\",\n      0\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state / result.count;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"mean()\");\n    return result.isMissing && !mergedOptions.skipMissing ? null : result.value;\n  }\n};\nfunction mean(variableOrValues, options) {\n  return {\n    summarizeFunction: meanInternal,\n    parameters: [variableOrValues],\n    options\n  };\n}\nconst varianceInternal = (dataCalc, params, options) => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const meanResult = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum2) => sum2 + value,\n      \"variance()\",\n      0\n    );\n    if (meanResult.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (meanResult.count <= 1) {\n      return null;\n    }\n    const meanValue = meanResult.state / meanResult.count;\n    const varianceResult = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum2) => {\n        const actualValue = typeof value === \"boolean\" && mergedOptions.coerceBooleans ? value ? 1 : 0 : value;\n        return sum2 + Math.pow(actualValue - meanValue, 2);\n      },\n      \"variance()\",\n      0\n    );\n    return varianceResult.state / (meanResult.count - 1);\n  } else if (Array.isArray(variableOrValues)) {\n    const validValues = [];\n    let containsMissing = false;\n    for (const value of variableOrValues) {\n      if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n        validValues.push(value);\n      } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n        validValues.push(value ? 1 : 0);\n      } else if (value === null || value === void 0 || typeof value === \"number\" && (isNaN(value) || !isFinite(value))) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(`variance(): has non-numeric value ${value}`);\n      }\n    }\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (validValues.length <= 1) {\n      return null;\n    }\n    const sum2 = validValues.reduce((acc, val) => acc + val, 0);\n    const mean2 = sum2 / validValues.length;\n    const sumSquaredDiffs = validValues.reduce(\n      (acc, val) => acc + Math.pow(val - mean2, 2),\n      0\n    );\n    return sumSquaredDiffs / (validValues.length - 1);\n  } else {\n    return null;\n  }\n};\nfunction variance(variableOrValues, options) {\n  return {\n    summarizeFunction: varianceInternal,\n    parameters: [variableOrValues],\n    options\n  };\n}\nconst minInternal = (dataCalc, params, options) => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, min2) => min2 === Number.POSITIVE_INFINITY || value < min2 ? value : min2,\n      \"min()\",\n      Number.POSITIVE_INFINITY\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, min2) => min2 === Number.POSITIVE_INFINITY || value < min2 ? value : min2,\n      \"min()\",\n      Number.POSITIVE_INFINITY\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"min()\");\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    return result.isMissing ? null : result.value;\n  }\n};\nfunction min(variableOrValues, options) {\n  return {\n    summarizeFunction: minInternal,\n    parameters: [variableOrValues],\n    options\n  };\n}\nconst maxInternal = (dataCalc, params, options) => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, max2) => max2 === Number.NEGATIVE_INFINITY || value > max2 ? value : max2,\n      \"max()\",\n      Number.NEGATIVE_INFINITY\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, max2) => max2 === Number.NEGATIVE_INFINITY || value > max2 ? value : max2,\n      \"max()\",\n      Number.NEGATIVE_INFINITY\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"max()\");\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    return result.isMissing ? null : result.value;\n  }\n};\nfunction max(variableOrValues, options) {\n  return {\n    summarizeFunction: maxInternal,\n    parameters: [variableOrValues],\n    options\n  };\n}\nconst medianInternal = (dataCalc, params, options) => {\n  const variableOrValues = params[0];\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    dataCalc.verifyObservationsContainVariable(variable);\n    const values = [];\n    let containsMissing = false;\n    dataCalc.observations.forEach((o) => {\n      if (dataCalc.isNonMissingNumeric(o[variable])) {\n        values.push(o[variable]);\n      } else if (typeof o[variable] === \"boolean\" && mergedOptions.coerceBooleans) {\n        values.push(o[variable] ? 1 : 0);\n      } else if (dataCalc.isMissingNumeric(o[variable])) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(\n          `median(): variable ${variable} has non-numeric value ${o[variable]} in this observation: ${JSON.stringify(o)}`\n        );\n      }\n    });\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (values.length === 0) {\n      return null;\n    }\n    values.sort((a, b) => a - b);\n    const mid = Math.floor(values.length / 2);\n    if (values.length % 2 === 0) {\n      return (values[mid - 1] + values[mid]) / 2;\n    } else {\n      return values[mid];\n    }\n  } else if (Array.isArray(variableOrValues)) {\n    const values = [];\n    let containsMissing = false;\n    for (const value of variableOrValues) {\n      if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n        values.push(value);\n      } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n        values.push(value ? 1 : 0);\n      } else if (value === null || value === void 0 || typeof value === \"number\" && (isNaN(value) || !isFinite(value))) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(`median(): has non-numeric value ${value}`);\n      }\n    }\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (values.length === 0) {\n      return null;\n    }\n    values.sort((a, b) => a - b);\n    const mid = Math.floor(values.length / 2);\n    if (values.length % 2 === 0) {\n      return (values[mid - 1] + values[mid]) / 2;\n    } else {\n      return values[mid];\n    }\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"median()\");\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    return result.isMissing ? null : result.value;\n  }\n};\nfunction median(variableOrValues, options) {\n  return {\n    summarizeFunction: medianInternal,\n    parameters: [variableOrValues],\n    options\n  };\n}\nconst sdInternal = (dataCalc, params, options) => {\n  const variableOrValues = params[0];\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const varianceValue = varianceInternal(dataCalc, params, options);\n    if (varianceValue === null) {\n      return null;\n    }\n    return Math.sqrt(varianceValue);\n  } else if (Array.isArray(variableOrValues)) {\n    const newParams = [...params];\n    const varianceValue = varianceInternal(dataCalc, newParams, options);\n    if (varianceValue === null) {\n      return null;\n    }\n    return Math.sqrt(varianceValue);\n  } else {\n    return null;\n  }\n};\nfunction sd(variableOrValues, options) {\n  return {\n    summarizeFunction: sdInternal,\n    parameters: [variableOrValues],\n    options\n  };\n}\n\nconsole.log(\"\\u26AA @m2c2kit/data-calc version 0.8.2 (62ccf312)\");\n\nexport { DataCalc, max, mean, median, min, n, sd, sum, variance };\n//# sourceMappingURL=index.js.map\n","import {\n  Game,\n  Action,\n  Scene,\n  Shape,\n  Label,\n  Transition,\n  TransitionDirection,\n  WebColors,\n  RandomDraws,\n  LabelHorizontalAlignmentMode,\n  GameParameters,\n  GameOptions,\n  TrialSchema,\n  Timer,\n  Easings,\n  Sprite,\n  Constants,\n  Translation,\n  ScoringProvider,\n  ActivityKeyValueData,\n  ScoringSchema,\n  M2Error,\n} from \"@m2c2kit/core\";\nimport {\n  Button,\n  CountdownScene,\n  Grid,\n  Instructions,\n  InstructionsOptions,\n  LocalePicker,\n} from \"@m2c2kit/addons\";\nimport { DataCalc, median, sum } from \"@m2c2kit/data-calc\";\n\n/**\n * Grid Memory is a visuospatial working memory task, with delayed free\n * recall. After a brief exposure, and a short distraction phase,\n * participants report the location of dots on a grid.\n */\nclass GridMemory extends Game implements ScoringProvider {\n  constructor() {\n    /**\n     * These are configurable game parameters and their defaults.\n     * Each game parameter should have a type, default (this is the default\n     * value), and a description.\n     */\n    const defaultParameters: GameParameters = {\n      number_of_dots: {\n        type: \"integer\",\n        default: 3,\n        description: \"Number of dots to present.\",\n      },\n      preparation_duration_ms: {\n        type: \"number\",\n        default: 500,\n        description:\n          \"How long the 'get ready' message before each trial is shown, milliseconds.\",\n      },\n      blank_grid_duration_ms: {\n        type: \"number\",\n        default: 500,\n        description:\n          \"How long a blank grid is shown before the dots appear, milliseconds.\",\n      },\n      interference_duration_ms: {\n        type: \"number\",\n        default: 8000,\n        description:\n          \"How long the grid of interference targets is shown, milliseconds.\",\n      },\n      interference_transition_animation: {\n        type: \"boolean\",\n        default: true,\n        description:\n          \"Should the transitions between dot presentation, interference, and recall be animated slide transitions?\",\n      },\n      dot_present_duration_ms: {\n        type: \"number\",\n        default: 3000,\n        description: \"How long the dots are shown, milliseconds.\",\n      },\n      number_of_interference_targets: {\n        type: \"integer\",\n        default: 5,\n        description: \"How many targets to show in the interference phase.\",\n      },\n      number_of_trials: {\n        type: \"integer\",\n        default: 4,\n        description: \"How many trials to run.\",\n      },\n      show_trials_complete_scene: {\n        default: true,\n        type: \"boolean\",\n        description:\n          \"After the final trial, should a completion scene be shown? Otherwise, the game will immediately end.\",\n      },\n      instruction_type: {\n        type: \"string\",\n        default: \"long\",\n        description: \"Type of instructions to show, 'short' or 'long'.\",\n      },\n      instructions: {\n        default: null,\n        type: [\"object\", \"null\"],\n        description:\n          \"When non-null, an InstructionsOptions object that will completely override the built-in instructions.\",\n      },\n      show_quit_button: {\n        type: \"boolean\",\n        default: false,\n        description: \"Should the activity quit button be shown?\",\n      },\n      show_fps: {\n        type: \"boolean\",\n        default: false,\n        description: \"Should the FPS be shown?\",\n      },\n      show_locale_picker: {\n        type: \"boolean\",\n        default: false,\n        description:\n          \"Should the icon that allows the participant to switch the locale be shown?\",\n      },\n      scoring: {\n        type: \"boolean\",\n        default: false,\n        description: \"Should scoring data be generated? Default is false.\",\n      },\n    };\n\n    /**\n     * This describes all the data that will be generated by the assessment.\n     * At runtime, when a trial completes, the data will be returned to the\n     * session with a callback, along with this schema transformed into\n     * JSON Schema.\n     */\n    const gridMemoryTrialSchema: TrialSchema = {\n      activity_begin_iso8601_timestamp: {\n        type: \"string\",\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the beginning of the game activity.\",\n      },\n      trial_begin_iso8601_timestamp: {\n        type: [\"string\", \"null\"],\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the beginning of the trial. Null if trial was skipped.\",\n      },\n      trial_end_iso8601_timestamp: {\n        type: [\"string\", \"null\"],\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the end of the trial (when user presses 'Done' after placing the three objects). Null if trial was skipped.\",\n      },\n      trial_index: {\n        type: [\"integer\", \"null\"],\n        description: \"Index of the trial within this assessment, 0-based.\",\n      },\n      response_time_duration_ms: {\n        type: [\"number\", \"null\"],\n        description:\n          \"Milliseconds from the when the empty grid is shown in the recall phase until the user has placed all dots and taps the done button. Null if trial was skipped.\",\n      },\n      presented_cells: {\n        type: [\"array\", \"null\"],\n        description:\n          \"Randomly chosen locations of the dots presented to the user. Null if trial was skipped.\",\n        items: {\n          type: \"object\",\n          properties: {\n            row: {\n              type: \"integer\",\n              description: \"Row of the cell, 0-indexed.\",\n            },\n            column: {\n              type: \"integer\",\n              description: \"Column of the cell, 0-indexed.\",\n            },\n          },\n        },\n      },\n      selected_cells: {\n        type: [\"array\", \"null\"],\n        description:\n          \"User selected locations of the dots. Null if trial was skipped.\",\n        items: {\n          type: \"object\",\n          properties: {\n            row: {\n              type: \"integer\",\n              description: \"Row of the cell, 0-indexed.\",\n            },\n            column: {\n              type: \"integer\",\n              description: \"Column of the cell, 0-indexed.\",\n            },\n          },\n        },\n      },\n      user_dot_actions: {\n        type: [\"array\", \"null\"],\n        description:\n          \"Complete user dot actions: placement, removal, and done. Null if trial was skipped.\",\n        items: {\n          type: \"object\",\n          properties: {\n            elapsed_duration_ms: {\n              type: \"number\",\n              description:\n                \"Duration, milliseconds, from when dot recall scene fully appeared until this user action.\",\n            },\n            action_type: {\n              type: \"string\",\n              enum: [\"placed\", \"removed\", \"done\"],\n              description:\n                \"Was the action a dot placement, dot removal, or done button push?\",\n            },\n            cell: {\n              type: [\"object\", \"null\"],\n              description:\n                \"Cell of user action; null if non-applicable (user action was done button push).\",\n              properties: {\n                row: {\n                  type: \"integer\",\n                  description: \"Row of the cell, 0-indexed.\",\n                },\n                column: {\n                  type: \"integer\",\n                  description: \"Column of the cell, 0-indexed.\",\n                },\n                tap_x: {\n                  type: \"number\",\n                  description:\n                    \"X coordinate of user's tap on the cell, relative to the cell.\",\n                },\n                tap_y: {\n                  type: \"number\",\n                  description:\n                    \"Y coordinate of user's tap on the cell, relative to the cell.\",\n                },\n              },\n            },\n          },\n        },\n      },\n      user_interference_actions: {\n        type: [\"array\", \"null\"],\n        description:\n          \"User actions tapping the interference targets. Null if trial was skipped.\",\n        items: {\n          type: \"object\",\n          properties: {\n            elapsed_duration_ms: {\n              type: \"number\",\n              description:\n                \"Duration, milliseconds, from when interference scene fully appeared until this user action.\",\n            },\n            action_type: {\n              type: \"string\",\n              enum: [\"on-target\", \"off-target\"],\n              description: \"Was the action on an interference target or off?\",\n            },\n            cell: {\n              type: \"object\",\n              description: \"Cell of user interference action.\",\n              properties: {\n                row: {\n                  type: \"integer\",\n                  description: \"Row of the cell, 0-indexed.\",\n                },\n                column: {\n                  type: \"integer\",\n                  description: \"Column of the cell, 0-indexed.\",\n                },\n                tap_x: {\n                  type: \"number\",\n                  description:\n                    \"X coordinate of user's tap on the cell, relative to the cell.\",\n                },\n                tap_y: {\n                  type: \"number\",\n                  description:\n                    \"Y coordinate of user's tap on the cell, relative to the cell.\",\n                },\n              },\n            },\n          },\n        },\n      },\n      number_of_correct_dots: {\n        type: [\"integer\", \"null\"],\n        description:\n          \"Number of dots that were correctly placed. Null if trial was skipped.\",\n      },\n      quit_button_pressed: {\n        type: \"boolean\",\n        description: \"Was the quit button pressed?\",\n      },\n    };\n\n    const gridMemoryScoringSchema: ScoringSchema = {\n      activity_begin_iso8601_timestamp: {\n        type: \"string\",\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the beginning of the game activity.\",\n      },\n      first_trial_begin_iso8601_timestamp: {\n        type: [\"string\", \"null\"],\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the beginning of the first trial. Null if no trials were completed.\",\n      },\n      last_trial_end_iso8601_timestamp: {\n        type: [\"string\", \"null\"],\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the end of the last trial. Null if no trials were completed.\",\n      },\n      n_trials: {\n        type: \"integer\",\n        description: \"Number of trials completed.\",\n      },\n      n_trials_exact_targets: {\n        type: \"integer\",\n        description:\n          \"Number of trials in which the user selected the exact target cells without error.\",\n      },\n      flag_trials_match_expected: {\n        type: \"integer\",\n        description:\n          \"Does the number of completed and expected trials match? 1 = true, 0 = false.\",\n      },\n      distance_hausdorff_median: {\n        type: [\"number\", \"null\"],\n        description:\n          \"Median across all trials of the Hausdorff distance between the presented and selected cells within a trial.\",\n      },\n      sum_exact_targets: {\n        type: [\"integer\", \"null\"],\n        description:\n          \"Sum of the number of exact targets across all trials. An exact target is a target that was selected in the correct location.\",\n      },\n    };\n\n    const translation: Translation = {\n      configuration: {\n        baseLocale: \"en-US\",\n      },\n      \"en-US\": {\n        localeName: \"English\",\n        INSTRUCTIONS_TITLE: \"Grid Memory\",\n        INSTRUCTIONS_TEXT_PAGE_1:\n          \"For this activity, try to remember the location of {{NUMBER_OF_DOTS}} dots.\",\n        INSTRUCTIONS_TEXT_PAGE_2:\n          \"Before placing the {{NUMBER_OF_DOTS}} dots in their location, you will also have to tap some Fs on the screen as quickly as you can.\",\n        INSTRUCTIONS_TEXT_PAGE_3: \"Press START to begin!\",\n        GET_READY: \"GET READY\",\n        REMEMBER_LOCATIONS: \"Remember the dot locations!\",\n        TOUCH_INTERFERENCE: \"Touch the F's!\",\n        DONE_BUTTON_TEXT: \"Done\",\n        WHERE_WERE: \"Where were the dots?\",\n        MUST_SELECT: \"You must select all {{NUMBER_OF_DOTS}} locations!\",\n        START_BUTTON_TEXT: \"START\",\n        NEXT_BUTTON_TEXT: \"Next\",\n        BACK_BUTTON_TEXT: \"Back\",\n        TRIALS_COMPLETE_SCENE_TEXT: \"This activity is complete.\",\n        TRIALS_COMPLETE_SCENE_BUTTON_TEXT: \"OK\",\n      },\n      // cSpell:disable (for VS Code extension, Code Spell Checker)\n      \"es-MX\": {\n        localeName: \"Espaol\",\n        INSTRUCTIONS_TITLE: \"Memoria de Puntos\",\n        INSTRUCTIONS_TEXT_PAGE_1:\n          \"Para esta actividad, intenta recordar la ubicacin de {{NUMBER_OF_DOTS}} puntos.\",\n        INSTRUCTIONS_TEXT_PAGE_2:\n          \"Antes de colocar los {{NUMBER_OF_DOTS}} puntos en su ubicacin, tambin tendrs que tocar las Fs en la pantalla lo ms rpido que puedas.\",\n        INSTRUCTIONS_TEXT_PAGE_3: \"Presione COMENZAR para Empezar\",\n        GET_READY: \"PREPRESE\",\n        REMEMBER_LOCATIONS: \"Recuerda las ubicaciones de los puntos\",\n        TOUCH_INTERFERENCE: \"Toca las Fs!\",\n        DONE_BUTTON_TEXT: \"Listo\",\n        WHERE_WERE: \"Dnde estaban los puntos?\",\n        MUST_SELECT:\n          \"Debes seleccionar todas las {{NUMBER_OF_DOTS}} ubicaciones!\",\n        START_BUTTON_TEXT: \"COMENZAR\",\n        NEXT_BUTTON_TEXT: \"Siguiente\",\n        BACK_BUTTON_TEXT: \"Atrs\",\n        TRIALS_COMPLETE_SCENE_TEXT: \"Esta actividad est completa.\",\n        TRIALS_COMPLETE_SCENE_BUTTON_TEXT: \"OK\",\n      },\n      \"de-DE\": {\n        localeName: \"Deutsch\",\n        INSTRUCTIONS_TITLE: \"Raster-Gedchtnis\",\n        INSTRUCTIONS_TEXT_PAGE_1:\n          \"In dieser Aufgabe werden {{NUMBER_OF_DOTS}} rote Punkte kurz in einem Raster erscheinen. Ihre Aufgabe ist es, sich ihre Standorte zu merken!\",\n        INSTRUCTIONS_TEXT_PAGE_2:\n          \"Als nchstes werden Sie eine Seite voll mit den Buchstaben E und F sehen, wie auf dem Beispiel unten. Ihre Aufgabe ist es, so schnell wie mglich auf alle F's zu tippen!\",\n        INSTRUCTIONS_TEXT_PAGE_3:\n          \"Sobald das leere Raster erscheint, platzieren Sie die Punkte dort, wo Sie sie zuvor gesehen haben, indem Sie auf die entsprechenden Stellen tippen.\",\n        GET_READY: \"BEREIT MACHEN\",\n        REMEMBER_LOCATIONS: \"Merken Sie sich die Punktpositionen!\",\n        TOUCH_INTERFERENCE: \"Berhren die F's!\",\n        DONE_BUTTON_TEXT: \"Fertig\",\n        WHERE_WERE: \"Wo waren die Punkte?\",\n        MUST_SELECT:\n          \"Sie mssen alle {{NUMBER_OF_DOTS}} Punktpositionen auswhlen!\",\n        START_BUTTON_TEXT: \"START\",\n        NEXT_BUTTON_TEXT: \"Weiter\",\n        BACK_BUTTON_TEXT: \"Vorherige\",\n        TRIALS_COMPLETE_SCENE_TEXT: \"Die Aufgabe ist beendet.\",\n        TRIALS_COMPLETE_SCENE_BUTTON_TEXT: \"OK\",\n      },\n      \"it-IT\": {\n        localeName: \"Italiano\",\n        INSTRUCTIONS_TITLE: \"Griglia di memoria\",\n        INSTRUCTIONS_TEXT_PAGE_1:\n          \"Per questa attivit, cerca di ricordare la posizione di {{NUMBER_OF_DOTS}} punti.\",\n        INSTRUCTIONS_TEXT_PAGE_2:\n          \"Prima di piazzare i {{NUMBER_OF_DOTS}} punti al loro posto, dovrai toccare delle lettere 'F' sullo schermo, il pi velocemente possibile.\",\n        INSTRUCTIONS_TEXT_PAGE_3: \"Premi INIZIA per cominciare!\",\n        GET_READY: \"PREPARATI\",\n        REMEMBER_LOCATIONS: \"Ricorda la posizione dei punti!\",\n        TOUCH_INTERFERENCE: \"Tocca le F!\",\n        DONE_BUTTON_TEXT: \"Fatto\",\n        WHERE_WERE: \"Dove erano i punti?\",\n        MUST_SELECT: \"Devi selezionare tutte le {{NUMBER_OF_DOTS}} posizioni!\",\n        START_BUTTON_TEXT: \"INIZIA\",\n        NEXT_BUTTON_TEXT: \"Avanti\",\n        BACK_BUTTON_TEXT: \"Indietro\",\n        TRIALS_COMPLETE_SCENE_TEXT: \"Attivit completata.\",\n        TRIALS_COMPLETE_SCENE_BUTTON_TEXT: \"OK\",\n      },\n      // cSpell:enable\n    };\n\n    const img_default_size = 200;\n    const options: GameOptions = {\n      name: \"Grid Memory\",\n      /**\n       * This id must match the property m2c2kit.assessmentId in package.json\n       */\n      id: \"grid-memory\",\n      publishUuid: \"50ee0af4-d013-408f-a7d1-c8d5c04da920\",\n      version: \"__PACKAGE_JSON_VERSION__\",\n      moduleMetadata: Constants.MODULE_METADATA_PLACEHOLDER,\n      translation: translation,\n      shortDescription:\n        \"Grid Memory is a visuospatial working memory task, \\\nwith delayed free recall. After a brief exposure, and a short distraction \\\nphase, participants report the location of dots on a grid.\",\n      longDescription:\n        'Each trial of the dot memory task consisted of 3 phases: encoding, \\\n  distraction, and retrieval. During the encoding phase, the participant was \\\n  asked to remember the location three red dots appear on a 5 x 5 grid. After \\\n  a 3-second study period, the grid was removed and the distraction phase \\\n  began, during which the participant was required to locate and touch Fs among \\\n  an array of Es. After performing the distraction task for 8 seconds, and \\\n  empty 5 x 5 grid reappeared on the screen and participants were then \\\n  prompted to recall the locations of the 3 dots presented initially and press \\\n  a button labeled \"Done\" after entering their responses to complete the trial. \\\n  Participants completed 2 trials (encoding, distractor, retrieval) with a \\\n  1-second delay between trials. The dependent variable was an error score with \\\n  partial credit given based on the deviation from the correct positions. If \\\n  all dots were recalled in their correct location, the participant received a \\\n  score of zero. In the case of one or more retrieval errors, Euclidean distance \\\n  of the location of the incorrect dot to the correct grid location was \\\n  calculated, with higher scores indicating less accurate placement and poorer \\\n  performance (Siedlecki, 2007). The rationale for our use of this task as an \\\n  indicator of working memory has both an empirical and theoretical basis. \\\n  Previous research (Miyake, Friedman, Rettinger, Shah, & Hegarty, 2001) has \\\n  demonstrated that a similar dotmemory task loaded on a factor representing \\\n  working memory. The authors of this study reasoned that the spatial dot \\\n  memory task placed high demands on controlled attentiona hallmark of working \\\n  memory tasks. Indeed, individual differences in working memory capacity arise \\\n  \"in situations where information needs to be actively maintained or when a \\\n  controlled search of memory is required\" (Unsworth & Engle, 2007, p. 123). \\\n  The ambulatory dot memory task satisfies this requirement by using an \\\n  interference task to prevent rehearsal and produce interference with encoded \\\n  locations, which creates the demand for active maintenance and controlled \\\n  retrieval of previously encoded location during the recall phase. \\\n  SOURCE: Sliwinski, Martin J., Jacqueline A. Mogle, Jinshil Hyun, Elizabeth \\\n  Munoz, Joshua M. Smyth, and Richard B. Lipton. \"Reliability and validity of \\\n  ambulatory cognitive assessments.\" Assessment 25, no. 1 (2018): 14-30.',\n      showFps: defaultParameters.show_fps.default,\n      width: 400,\n      height: 800,\n      trialSchema: gridMemoryTrialSchema,\n      scoringSchema: gridMemoryScoringSchema,\n      parameters: defaultParameters,\n      fonts: [\n        {\n          fontName: \"roboto\",\n          url: \"fonts/roboto/Roboto-Regular.ttf\",\n        },\n      ],\n      images: [\n        {\n          imageName: \"grid\",\n          height: img_default_size,\n          width: img_default_size,\n          url: \"images/dotmem1_grid.png\",\n        },\n        {\n          imageName: \"fs\",\n          height: img_default_size,\n          width: img_default_size,\n          url: \"images/dotmem2_fs.png\",\n        },\n        {\n          imageName: \"circle-x\",\n          height: 32,\n          width: 32,\n          // the svg is from evericons and is licensed under CC0 1.0\n          // Universal (Public Domain). see https://www.patreon.com/evericons\n          url: \"images/circle-x.svg\",\n        },\n      ],\n    };\n\n    super(options);\n  }\n\n  override async initialize() {\n    await super.initialize();\n    // just for convenience, alias the variable game to \"this\"\n    // (even though eslint doesn't like it)\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const game = this;\n\n    // ==============================================================\n    // variables user actions with dots and interference targets\n\n    interface cell {\n      row: number;\n      column: number;\n    }\n    let presentedCells: cell[];\n    let selectedCells: cell[];\n\n    interface UserAction {\n      elapsed_duration_ms: number;\n      action_type: \"placed\" | \"removed\" | \"done\" | \"on-target\" | \"off-target\";\n      cell: null | {\n        row: number | null;\n        column: number | null;\n        tap_x: number | null;\n        tap_y: number | null;\n      };\n    }\n\n    let userDotActions: UserAction[];\n    let userInterferenceActions: UserAction[];\n\n    const NUMBER_OF_DOTS = game.getParameter<number>(\"number_of_dots\");\n\n    // ==============================================================\n\n    if (game.getParameter<boolean>(\"show_quit_button\")) {\n      const quitSprite = new Sprite({\n        imageName: \"circle-x\",\n        position: { x: 380, y: 20 },\n        isUserInteractionEnabled: true,\n      });\n      game.addFreeNode(quitSprite);\n      quitSprite.onTapDown((e) => {\n        game.removeAllFreeNodes();\n        e.handled = true;\n        const blankScene = new Scene();\n        game.addScene(blankScene);\n        game.presentScene(blankScene);\n        game.addTrialData(\"quit_button_pressed\", true);\n        game.trialComplete();\n        if (game.getParameter<boolean>(\"scoring\")) {\n          // Score the data only if user does not quit. If user quits, pass\n          // empty data to calculateScores so a \"blank\" set of scores is\n          // generated.\n          const scores = game.calculateScores([], {\n            numberOfDots: game.getParameter<number>(\"number_of_dots\"),\n            numberOfTrials: game.getParameter<number>(\"number_of_trials\"),\n          });\n          game.addScoringData(scores);\n          game.scoringComplete();\n        }\n        game.cancel();\n      });\n    }\n\n    let localePicker: LocalePicker;\n    if (game.getParameter<boolean>(\"show_locale_picker\")) {\n      localePicker = new LocalePicker();\n      game.addFreeNode(localePicker);\n    }\n\n    // ==============================================================\n    // SCENES: instructions\n\n    let instructionsScenes: Array<Scene>;\n\n    const customInstructions = game.getParameter<InstructionsOptions | null>(\n      \"instructions\",\n    );\n    if (customInstructions) {\n      instructionsScenes = Instructions.create(customInstructions);\n    } else {\n      if (!this.i18n) {\n        throw new M2Error(\"No i18n object found.\");\n      }\n      instructionsScenes = Instructions.create({\n        instructionScenes: [\n          {\n            title: \"INSTRUCTIONS_TITLE\",\n            text: \"INSTRUCTIONS_TEXT_PAGE_1\",\n            textInterpolation: { NUMBER_OF_DOTS: NUMBER_OF_DOTS.toString() },\n            imageName: \"grid\",\n            imageAboveText: false,\n            imageMarginTop: 12,\n            textFontSize: 24,\n            titleFontSize: 30,\n            textVerticalBias: 0.25,\n            nextButtonText: \"NEXT_BUTTON_TEXT\",\n            backButtonText: \"BACK_BUTTON_TEXT\",\n          },\n          {\n            title: \"INSTRUCTIONS_TITLE\",\n            text: \"INSTRUCTIONS_TEXT_PAGE_2\",\n            textInterpolation: { NUMBER_OF_DOTS: NUMBER_OF_DOTS.toString() },\n            imageName: \"fs\",\n            imageAboveText: false,\n            imageMarginTop: 12,\n            textFontSize: 24,\n            titleFontSize: 30,\n            textVerticalBias: 0.25,\n            nextButtonText: \"NEXT_BUTTON_TEXT\",\n            backButtonText: \"BACK_BUTTON_TEXT\",\n          },\n          {\n            title: \"INSTRUCTIONS_TITLE\",\n            text: \"INSTRUCTIONS_TEXT_PAGE_3\",\n            textFontSize: 24,\n            titleFontSize: 30,\n            textAlignmentMode: LabelHorizontalAlignmentMode.Center,\n            nextButtonText: \"START_BUTTON_TEXT\",\n            nextButtonBackgroundColor: WebColors.Green,\n            backButtonText: \"BACK_BUTTON_TEXT\",\n          },\n        ],\n      });\n    }\n    instructionsScenes[0].onAppear(() => {\n      // in case user quits before starting trial, record the timestamp\n      game.addTrialData(\n        \"activity_begin_iso8601_timestamp\",\n        this.beginIso8601Timestamp,\n      );\n    });\n    game.addScenes(instructionsScenes);\n\n    let forward_into_interference_scene_transition: Transition | undefined;\n    let back_from_interference_scene_transition: Transition | undefined;\n    if (game.getParameter<boolean>(\"interference_transition_animation\")) {\n      forward_into_interference_scene_transition = Transition.slide({\n        direction: TransitionDirection.Left,\n        duration: 500,\n        easing: Easings.sinusoidalInOut,\n      });\n      back_from_interference_scene_transition = Transition.slide({\n        direction: TransitionDirection.Right,\n        duration: 500,\n        easing: Easings.sinusoidalInOut,\n      });\n    }\n\n    // ==============================================================\n    // SCENE: countdown. Show 3 second countdown.\n    const countdownScene = new CountdownScene({\n      milliseconds: 3000,\n      // No message, because we show \"Get Ready\" before each trial\n      text: \"\",\n      zeroDwellMilliseconds: 1000,\n      transition: Transition.none(),\n    });\n    game.addScene(countdownScene);\n\n    // ==============================================================\n    // SCENE: per-trial preparation. Show get ready message, then advance after\n    // XXXX milliseconds (as defined in preparation_duration_ms parameter)\n    const preparationScene = new Scene();\n    game.addScene(preparationScene);\n\n    const getReadyMessage = new Label({\n      text: \"GET_READY\",\n      fontSize: 24,\n      position: { x: 200, y: 400 },\n    });\n    preparationScene.addChild(getReadyMessage);\n\n    preparationScene.onAppear(() => {\n      preparationScene.run(\n        Action.sequence([\n          Action.custom({\n            callback: () => {\n              game.addTrialData(\n                \"activity_begin_iso8601_timestamp\",\n                this.beginIso8601Timestamp,\n              );\n              game.addTrialData(\n                \"trial_begin_iso8601_timestamp\",\n                new Date().toISOString(),\n              );\n            },\n          }),\n          Action.wait({\n            duration: game.getParameter(\"preparation_duration_ms\"),\n          }),\n          Action.custom({\n            callback: () => {\n              game.presentScene(dotPresentationScene);\n            },\n          }),\n        ]),\n      );\n    });\n\n    // ==============================================================\n    // SCENE: Show the dot placement\n    const dotPresentationScene = new Scene();\n    game.addScene(dotPresentationScene);\n\n    const rememberDotsMessage = new Label({\n      text: \"REMEMBER_LOCATIONS\",\n      fontSize: 24,\n      position: { x: 200, y: 150 },\n    });\n    dotPresentationScene.addChild(rememberDotsMessage);\n\n    const presentationGrid = new Grid({\n      size: { width: 300, height: 300 },\n      position: { x: 200, y: 400 },\n      rows: 5,\n      columns: 5,\n      backgroundColor: WebColors.Silver,\n      gridLineColor: WebColors.Black,\n      gridLineWidth: 4,\n    });\n    dotPresentationScene.addChild(presentationGrid);\n\n    dotPresentationScene.onSetup(() => {\n      rememberDotsMessage.hidden = true;\n    });\n\n    dotPresentationScene.onAppear(() => {\n      // randomly choose 3 (NUMBER_OF_DOTS) cells that will have the red dots\n      // on a grid of size 5 rows, 5 columns\n      rememberDotsMessage.hidden = false;\n\n      dotPresentationScene.run(\n        Action.sequence([\n          Action.wait({\n            duration: game.getParameter(\"blank_grid_duration_ms\"),\n          }),\n          Action.custom({\n            callback: () => {\n              presentedCells = RandomDraws.FromGridWithoutReplacement(\n                NUMBER_OF_DOTS,\n                5,\n                5,\n              );\n              for (let i = 0; i < NUMBER_OF_DOTS; i++) {\n                const circle = new Shape({\n                  circleOfRadius: 20,\n                  fillColor: WebColors.Red,\n                  strokeColor: WebColors.Black,\n                  lineWidth: 2,\n                });\n                presentationGrid.addAtCell(\n                  circle,\n                  presentedCells[i].row,\n                  presentedCells[i].column,\n                );\n              }\n            },\n          }),\n          Action.wait({\n            duration: game.getParameter(\"dot_present_duration_ms\"),\n          }),\n          Action.custom({\n            callback: () => {\n              presentationGrid.removeAllGridChildren();\n              rememberDotsMessage.hidden = true;\n              game.presentScene(\n                interferenceScene,\n                forward_into_interference_scene_transition,\n              );\n            },\n          }),\n        ]),\n      );\n    });\n\n    // ==============================================================\n    // SCENE: interference. Ask participant to the touch the Fs\n    const interferenceScene = new Scene();\n    game.addScene(interferenceScene);\n\n    const touchTheFs = new Label({\n      text: \"TOUCH_INTERFERENCE\",\n      fontSize: 24,\n      position: { x: 200, y: 100 },\n    });\n    interferenceScene.addChild(touchTheFs);\n\n    const interferenceGrid = new Grid({\n      size: { width: 300, height: 480 },\n      position: { x: 200, y: 400 },\n      rows: 8,\n      columns: 5,\n      backgroundColor: WebColors.Transparent,\n      gridLineColor: WebColors.Transparent,\n    });\n\n    interferenceScene.addChild(interferenceGrid);\n\n    interferenceScene.onSetup(() => {\n      userInterferenceActions = new Array<UserAction>();\n      // note: we should really start the timer in onAppear, but that can\n      // cause a problem if that user taps a target before the timer starts\n      // TODO: refactor so that the tappability of targets is turned on\n      // only in onAppear\n      Timer.startNew(\"interferenceResponseTime\");\n\n      touchTheFs.hidden = true;\n      ShowInterferenceActivity();\n\n      // Advance to the next recall screen after \"interference_duration_ms\"\n      interferenceScene.run(\n        Action.sequence([\n          Action.wait({\n            duration: game.getParameter(\"interference_duration_ms\"),\n          }),\n          Action.custom({\n            callback: () => {\n              Timer.remove(\"interferenceResponseTime\");\n              game.presentScene(\n                dotRecallScene,\n                back_from_interference_scene_transition,\n              );\n            },\n          }),\n        ]),\n        \"advanceAfterInterference\",\n      );\n\n      // On repeated showings of the grid, we will slide it into view\n      // and slideGridIntoScene = true\n      function ShowInterferenceActivity(slideGridIntoScene = false) {\n        interferenceGrid.removeAllGridChildren();\n        let tappedFCount = 0;\n\n        // randomly choose six cells to have F in them from the grid that\n        // is of size 8 rows and 5 columns\n        const number_of_interference_targets = game.getParameter<number>(\n          \"number_of_interference_targets\",\n        );\n        const FCells = RandomDraws.FromGridWithoutReplacement(\n          number_of_interference_targets,\n          8,\n          5,\n        );\n        for (let i = 0; i < 8; i++) {\n          for (let j = 0; j < 5; j++) {\n            const square = new Shape({\n              rect: { size: { width: 59, height: 59 } },\n              fillColor: WebColors.Transparent,\n            });\n\n            let letterIsF = false;\n            let letter: Label;\n            letter = new Label({ text: \"E\", fontSize: 50 });\n            for (let k = 0; k < number_of_interference_targets; k++) {\n              if (FCells[k].row === i && FCells[k].column === j) {\n                letter = new Label({ text: \"F\", fontSize: 50 });\n                letterIsF = true;\n              }\n            }\n            interface squareUserData {\n              row: number;\n              column: number;\n              tapStatus: number;\n            }\n\n            square.userData = {};\n            (<squareUserData>square.userData).row = i;\n            (<squareUserData>square.userData).column = j;\n\n            if (letterIsF) {\n              // square can be tapped, but yet not tapped\n              (<squareUserData>square.userData).tapStatus = 0;\n            } else {\n              // square cannot be tapped\n              (<squareUserData>square.userData).tapStatus = -1;\n            }\n            square.isUserInteractionEnabled = true;\n            square.onTapDown((e) => {\n              if ((<squareUserData>square.userData).tapStatus === 0) {\n                tappedFCount++;\n                letter.text = \"E\";\n                letter.run(\n                  Action.sequence([\n                    Action.scale({ scale: 1.25, duration: 125 }),\n                    Action.scale({ scale: 1, duration: 125 }),\n                  ]),\n                );\n                // square has been tapped\n                (<squareUserData>square.userData).tapStatus = 1;\n                if (tappedFCount >= number_of_interference_targets) {\n                  // don't allow more taps on this current grid\n                  interferenceGrid.gridChildren.forEach((cell) => {\n                    cell.node.isUserInteractionEnabled = false;\n                  });\n\n                  // show a new interference grid\n                  // but this time, slide it into view\n                  ShowInterferenceActivity(true);\n                }\n                /**\n                 * There is an edge case in which the interference_duration_ms\n                 * has elapsed and we auto-advance to the next scene, but\n                 * then the user taps a target. In that case, the\n                 * \"interferenceResponseTime\" timer has been removed, and thus\n                 * a call to Timer.elapsed() will throw an error.\n                 * To prevent this, check if the timer exists before\n                 * calling Timer.elapsed(). We will not record these user taps,\n                 * but that is OK because we are at or beyond the\n                 * interference_duration_ms duration.\n                 */\n                if (Timer.exists(\"interferenceResponseTime\")) {\n                  userInterferenceActions.push({\n                    elapsed_duration_ms: Timer.elapsed(\n                      \"interferenceResponseTime\",\n                    ),\n                    action_type: \"on-target\",\n                    cell: {\n                      row: (<squareUserData>square.userData).row,\n                      column: (<squareUserData>square.userData).column,\n                      tap_x: e.point.x,\n                      tap_y: e.point.y,\n                    },\n                  });\n                }\n              } else {\n                if (Timer.exists(\"interferenceResponseTime\")) {\n                  userInterferenceActions.push({\n                    elapsed_duration_ms: Timer.elapsed(\n                      \"interferenceResponseTime\",\n                    ),\n                    action_type: \"off-target\",\n                    cell: {\n                      row: (<squareUserData>square.userData).row,\n                      column: (<squareUserData>square.userData).column,\n                      tap_x: e.point.x,\n                      tap_y: e.point.y,\n                    },\n                  });\n                }\n              }\n            });\n\n            interferenceGrid.addAtCell(letter, i, j);\n            interferenceGrid.addAtCell(square, i, j);\n          }\n        }\n\n        if (slideGridIntoScene) {\n          interferenceGrid.position = { x: 200, y: 1040 };\n          interferenceGrid.run(\n            Action.move({ point: { x: 200, y: 400 }, duration: 500 }),\n          );\n        }\n      }\n    });\n\n    interferenceScene.onAppear(() => {\n      touchTheFs.hidden = false;\n    });\n\n    // ==============================================================\n    // SCENE: recall. Ask participant to recall the dot positions\n    const dotRecallScene = new Scene();\n    game.addScene(dotRecallScene);\n\n    const whereDotsMessage = new Label({\n      text: \"WHERE_WERE\",\n      fontSize: 24,\n      position: { x: 200, y: 150 },\n    });\n    dotRecallScene.addChild(whereDotsMessage);\n\n    const recallGrid = new Grid({\n      size: { width: 300, height: 300 },\n      position: { x: 200, y: 400 },\n      rows: 5,\n      columns: 5,\n      backgroundColor: WebColors.Silver,\n      gridLineColor: WebColors.Black,\n      gridLineWidth: 4,\n    });\n    dotRecallScene.addChild(recallGrid);\n\n    let tappedCellCount = 0;\n\n    dotRecallScene.onSetup(() => {\n      // note: we should really start the timer in onAppear, but that can\n      // cause a problem if that user taps a target before the timer starts\n      // TODO: refactor so that the tappability of targets is turned on\n      // only in onAppear\n      Timer.startNew(\"responseTime\");\n\n      recallGrid.removeAllGridChildren();\n      recallDoneButton.hidden = true;\n      whereDotsMessage.hidden = true;\n\n      tappedCellCount = 0;\n      selectedCells = new Array<{\n        row: number;\n        column: number;\n      }>();\n      userDotActions = new Array<UserAction>();\n\n      for (let i = 0; i < 5; i++) {\n        for (let j = 0; j < 5; j++) {\n          const cell = new Shape({\n            // this rectangle will be the hit area for the cell\n            // it's transparent -- we use it only for its hit\n            // area. Make it 59 x 59 (not 60 x 60) to avoid overlap\n            // of hit area on the borders\n            rect: { size: { width: 59, height: 59 } },\n            fillColor: WebColors.Transparent,\n          });\n          // a node's userData is a property we can use to store\n          // anything we want. Here, we use it simply to keep track\n          // of whether the cell has been tapped or not.\n          cell.userData = 0;\n          cell.onTapDown((e) => {\n            if (cell.userData === 0 && tappedCellCount < NUMBER_OF_DOTS) {\n              // cell has not been tapped, and there are not yet\n              // 3 (NUMBER_OF_DOTS) circles placed\n              const circle = new Shape({\n                circleOfRadius: 20,\n                fillColor: WebColors.Red,\n                strokeColor: WebColors.Black,\n                lineWidth: 2,\n              });\n              cell.addChild(circle);\n              cell.userData = 1;\n              tappedCellCount++;\n              selectedCells.push({ row: i, column: j });\n              userDotActions.push({\n                elapsed_duration_ms: Timer.elapsed(\"responseTime\"),\n                action_type: \"placed\",\n                cell: {\n                  row: i,\n                  column: j,\n                  tap_x: e.point.x,\n                  tap_y: e.point.y,\n                },\n              });\n            } else if (cell.userData === 1) {\n              // this cell has been tapped. Remove the circle from here\n              cell.removeAllChildren();\n              cell.userData = 0;\n              tappedCellCount--;\n              // remove this \"untapped\" cell from the recorded data of tapped cells\n              selectedCells = selectedCells.filter(\n                (cell) => !(cell.row === i && cell.column === j),\n              );\n              userDotActions.push({\n                elapsed_duration_ms: Timer.elapsed(\"responseTime\"),\n                action_type: \"removed\",\n                cell: {\n                  row: i,\n                  column: j,\n                  tap_x: e.point.x,\n                  tap_y: e.point.y,\n                },\n              });\n            }\n          });\n          cell.isUserInteractionEnabled = true;\n          recallGrid.addAtCell(cell, i, j);\n        }\n      }\n    });\n\n    dotRecallScene.onAppear(() => {\n      recallDoneButton.hidden = false;\n      whereDotsMessage.hidden = false;\n    });\n\n    const recallDoneButton = new Button({\n      text: \"DONE_BUTTON_TEXT\",\n      position: { x: 200, y: 700 },\n      size: { width: 250, height: 50 },\n    });\n    dotRecallScene.addChild(recallDoneButton);\n\n    // place this warning message on the scene, but hide it\n    // we'll unhide it, if needed.\n    const youMustSelectAllMessage = new Label({\n      text: \"MUST_SELECT\",\n      interpolation: { NUMBER_OF_DOTS: NUMBER_OF_DOTS.toString() },\n      position: { x: 200, y: 600 },\n      hidden: true,\n    });\n    dotRecallScene.addChild(youMustSelectAllMessage);\n\n    recallDoneButton.isUserInteractionEnabled = true;\n    recallDoneButton.onTapDown(() => {\n      const doneButtonElapsedMs = Timer.elapsed(\"responseTime\");\n      userDotActions.push({\n        elapsed_duration_ms: doneButtonElapsedMs,\n        action_type: \"done\",\n        cell: null,\n      });\n\n      if (tappedCellCount < NUMBER_OF_DOTS) {\n        youMustSelectAllMessage.run(\n          Action.sequence([\n            Action.custom({\n              callback: () => {\n                youMustSelectAllMessage.hidden = false;\n              },\n            }),\n            Action.wait({ duration: 3000 }),\n            Action.custom({\n              callback: () => {\n                youMustSelectAllMessage.hidden = true;\n              },\n            }),\n          ]),\n        );\n      } else {\n        Timer.stop(\"responseTime\");\n        Timer.remove(\"responseTime\");\n\n        game.addTrialData(\n          \"trial_end_iso8601_timestamp\",\n          new Date().toISOString(),\n        );\n        game.addTrialData(\"response_time_duration_ms\", doneButtonElapsedMs);\n        game.addTrialData(\"presented_cells\", presentedCells);\n        game.addTrialData(\"selected_cells\", selectedCells);\n        game.addTrialData(\"user_dot_actions\", userDotActions);\n        game.addTrialData(\"user_interference_actions\", userInterferenceActions);\n\n        const cellsEqual = (cell1: cell, cell2: cell): boolean => {\n          return cell1.row === cell2.row && cell1.column === cell2.column;\n        };\n        const numberOfCorrectDots = selectedCells\n          .map((selectedCell) =>\n            presentedCells.some((presentedCell) =>\n              cellsEqual(presentedCell, selectedCell),\n            )\n              ? 1\n              : 0,\n          )\n          .reduce((a: number, b) => a + b, 0);\n        game.addTrialData(\"number_of_correct_dots\", numberOfCorrectDots);\n        game.addTrialData(\"quit_button_pressed\", false);\n        game.addTrialData(\"trial_index\", game.trialIndex);\n        game.trialComplete();\n        if (game.trialIndex === game.getParameter(\"number_of_trials\")) {\n          if (game.getParameter<boolean>(\"scoring\")) {\n            const scores = game.calculateScores(game.data.trials, {\n              numberOfDots: game.getParameter<number>(\"number_of_dots\"),\n              numberOfTrials: game.getParameter<number>(\"number_of_trials\"),\n            });\n            game.addScoringData(scores);\n            game.scoringComplete();\n          }\n\n          const nextScreenTransition = Transition.slide({\n            direction: TransitionDirection.Left,\n            duration: 500,\n            easing: Easings.sinusoidalInOut,\n          });\n          if (game.getParameter(\"show_trials_complete_scene\")) {\n            game.presentScene(doneScene, nextScreenTransition);\n          } else {\n            game.end();\n          }\n        } else {\n          game.presentScene(preparationScene);\n        }\n      }\n    });\n\n    // ==============================================================\n    // SCENE: done. Show done message, with a button to exit.\n    const doneScene = new Scene();\n    game.addScene(doneScene);\n\n    const doneSceneText = new Label({\n      text: \"TRIALS_COMPLETE_SCENE_TEXT\",\n      position: { x: 200, y: 400 },\n    });\n    doneScene.addChild(doneSceneText);\n\n    const okButton = new Button({\n      text: \"TRIALS_COMPLETE_SCENE_BUTTON_TEXT\",\n      position: { x: 200, y: 600 },\n    });\n    okButton.isUserInteractionEnabled = true;\n    okButton.onTapDown(() => {\n      // don't allow repeat taps of ok button\n      okButton.isUserInteractionEnabled = false;\n      doneScene.removeAllChildren();\n      game.end();\n    });\n    doneScene.addChild(okButton);\n    doneScene.onSetup(() => {\n      // no need to have cancel button, because we're done\n      game.removeAllFreeNodes();\n    });\n  }\n\n  calculateScores(\n    data: ActivityKeyValueData[],\n    extras: {\n      numberOfDots: number;\n      numberOfTrials: number;\n    },\n  ) {\n    const dc = new DataCalc(data);\n\n    const distances = data.map((obs) => {\n      const presentedCells = obs.presented_cells as Array<Cell>;\n      const selectedCells = obs.selected_cells as Array<Cell>;\n      // If there are no presented cells or selected cells, score the\n      // Hausdorff distance as null. This can happen if the user\n      // quits the game before placing any dots or before beginning\n      // a trial.\n      if (presentedCells.length === 0 || selectedCells.length === 0) {\n        return {\n          hausdorff_distance: null,\n        };\n      }\n      return {\n        hausdorff_distance: hausdorffDistance(presentedCells, selectedCells),\n      };\n    });\n\n    const scores = dc.summarize({\n      activity_begin_iso8601_timestamp: this.beginIso8601Timestamp,\n      first_trial_begin_iso8601_timestamp: dc\n        .arrange(\"trial_begin_iso8601_timestamp\")\n        .slice(0)\n        .pull(\"trial_begin_iso8601_timestamp\"),\n      last_trial_end_iso8601_timestamp: dc\n        .arrange(\"-trial_end_iso8601_timestamp\")\n        .slice(0)\n        .pull(\"trial_end_iso8601_timestamp\"),\n      n_trials: dc.length,\n      flag_trials_match_expected: dc.length === extras.numberOfTrials ? 1 : 0,\n      distance_hausdorff_median: median(\n        new DataCalc(distances).pull(\"hausdorff_distance\"),\n      ),\n      n_trials_exact_targets: dc.filter(\n        (obs) => obs.number_of_correct_dots === extras.numberOfDots,\n      ).length,\n      sum_exact_targets: sum(\"number_of_correct_dots\"),\n    });\n    return scores.observations;\n  }\n}\n\ninterface Cell {\n  row: number;\n  column: number;\n}\n\nfunction hausdorffDistance(setA: Cell[], setB: Cell[]): number {\n  if (setA.length === 0 || setB.length === 0) {\n    return Infinity;\n  }\n\n  function euclideanDistance(cell1: Cell, cell2: Cell): number {\n    const rowDiff = cell1.row - cell2.row;\n    const columnDiff = cell1.column - cell2.column;\n    return Math.sqrt(rowDiff * rowDiff + columnDiff * columnDiff);\n  }\n\n  function maxMinDistance(fromSet: Cell[], toSet: Cell[]): number {\n    return fromSet.reduce((maxMinDist, cellA) => {\n      const minDist = toSet.reduce((minDist, cellB) => {\n        const dist = euclideanDistance(cellA, cellB);\n        return dist < minDist ? dist : minDist;\n      }, Infinity);\n      return minDist > maxMinDist ? minDist : maxMinDist;\n    }, 0);\n  }\n\n  const distanceAB = maxMinDistance(setA, setB);\n  const distanceBA = maxMinDistance(setB, setA);\n\n  return Math.max(distanceAB, distanceBA);\n}\n\nexport { GridMemory };\n"],"names":["M2Error","cell","minDist"],"mappings":"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"}