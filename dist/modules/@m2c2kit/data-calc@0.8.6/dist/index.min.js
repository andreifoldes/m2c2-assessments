class h extends Error{constructor(...e){super(...e),this.name="M2Error",Object.setPrototypeOf(this,h.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,h)}}class g{constructor(e,s){if(this._groups=new Array,!Array.isArray(e))throw new h("DataCalc constructor expects an array of observations as first argument");for(let i=0;i<e.length;i++)if(e[i]===null||typeof e[i]!="object"||Array.isArray(e[i]))throw new h(`DataCalc constructor expects all elements to be objects (observations). Element at index ${i} is ${typeof e[i]}. Element: ${JSON.stringify(e[i])}`);this._observations=this.deepCopy(e);const r=new Set;for(const i of e)for(const n of Object.keys(i))r.add(n);for(const i of this._observations)for(const n of r)n in i||(i[n]=null);s?.groups&&(this._groups=Array.from(s.groups))}get groups(){return this._groups}get observations(){return this._observations}get rows(){return this._observations}pull(e){if(this._observations.length===0)return console.warn(`DataCalc.pull(): No observations available to pull variable "${e}" from. Returning null.`),null;this.verifyObservationsContainVariable(e);const s=this._observations.map(r=>r[e]);return s.length===1?s[0]:s}get length(){return this._observations.length}filter(e){if(this._groups.length>0)throw new h(`filter() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(", ")}. Ungroup the data first using ungroup().`);return new g(this._observations.filter(e),{groups:this._groups})}groupBy(...e){return e.forEach(s=>{this.verifyObservationsContainVariable(s)}),new g(this._observations,{groups:e})}ungroup(){return new g(this._observations)}mutate(e){if(this._groups.length>0)throw new h(`mutate() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(", ")}. Ungroup the data first using ungroup().`);const s=this._observations.map(r=>{let i={...r};for(const[n,t]of Object.entries(e))i={...i,[n]:t(r)};return i});return new g(s,{groups:this._groups})}summarize(e){if(this._groups.length===0){const s={};for(const[r,i]of Object.entries(e))if(typeof i=="object"&&i!==null&&"summarizeFunction"in i){const n=i;s[r]=n.summarizeFunction(this,n.parameters,n.options)}else s[r]=i;return new g([s],{groups:this._groups})}return this.summarizeByGroups(e)}summarizeByGroups(e){const s=new Map;this._observations.forEach(i=>{const n=this._groups.map(o=>typeof i[o]=="object"?JSON.stringify(i[o]):i[o]).join("|");s.has(n)||s.set(n,[]);const t=s.get(n);t?t.push(i):s.set(n,[i])});const r=[];return s.forEach((i,n)=>{const t=n.split("|"),o=i[0],a={};this._groups.forEach((c,f)=>{const p=t[f],v=typeof o[c];if(v==="number")a[c]=Number(p);else if(v==="boolean")a[c]=p==="true";else if(p.startsWith("{")||p.startsWith("["))try{a[c]=JSON.parse(p)}catch{throw new h(`Failed to parse group value ${p} as JSON for group ${c}`)}else a[c]=p});const u=new g(i);for(const[c,f]of Object.entries(e))if(typeof f=="object"&&f!==null&&"summarizeFunction"in f){const p=f;a[c]=p.summarizeFunction(u,p.parameters,p.options)}else a[c]=f;r.push(a)}),new g(r,{groups:this._groups})}select(...e){const s=[],r=[];e.forEach(o=>{o.startsWith("-")?r.push(o.substring(1)):s.push(o)}),[...s.length>0?s:Object.keys(this._observations[0]||{}),...r].forEach(o=>{this.verifyObservationsContainVariable(o)});const n=new Set(r),t=this._observations.map(o=>{const a={};return s.length>0?s.forEach(u=>{n.has(u)||(a[u]=o[u])}):Object.keys(o).forEach(u=>{n.has(u)||(a[u]=o[u])}),a});return new g(t,{groups:this._groups})}arrange(...e){if(this._groups.length>0)throw new h(`arrange() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(", ")}. Ungroup the data first using ungroup().`);const s=[...this._observations].sort((r,i)=>{for(const n of e){let t=n,o=1;if(n.startsWith("-")&&(t=n.substring(1),o=-1),!(t in r)||!(t in i))throw new h(`arrange(): variable ${t} does not exist in all observations`);const a=r[t],u=i[t];if(typeof a!=typeof u)return o*(String(a)<String(u)?-1:1);if(a<u)return-1*o;if(a>u)return 1*o}return 0});return new g(s,{groups:this._groups})}distinct(){const e=new Set,s=this._observations.filter(r=>{const i=JSON.stringify(this.normalizeForComparison(r));return e.has(i)?!1:(e.add(i),!0)});return new g(s,{groups:this._groups})}rename(e){if(this._observations.length===0)throw new h("Cannot rename variables on an empty dataset");Object.values(e).forEach(r=>{this.verifyObservationsContainVariable(r)});const s=this._observations.map(r=>{const i={};for(const[n,t]of Object.entries(r)){const o=Object.entries(e).find(([,a])=>a===n)?.[0];o?i[o]=t:Object.values(e).includes(n)||(i[n]=t)}return i});return new g(s,{groups:this._groups})}innerJoin(e,s){if(this._groups.length>0||e._groups.length>0)throw new h("innerJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");s.forEach(n=>{this.verifyObservationsContainVariable(n),e.verifyObservationsContainVariable(n)});const r=new Map;e.observations.forEach(n=>{if(this.hasNullJoinKeys(n,s))return;const t=s.map(a=>JSON.stringify(this.normalizeForComparison(n[a]))).join("|"),o=r.get(t)||[];o.push(n),r.set(t,o)});const i=[];return this._observations.forEach(n=>{if(this.hasNullJoinKeys(n,s))return;const t=s.map(a=>JSON.stringify(this.normalizeForComparison(n[a]))).join("|"),o=r.get(t)||[];o.length>0&&o.forEach(a=>{const u={...n};Object.entries(a).forEach(([c,f])=>{s.includes(c)||(u[c]=f)}),i.push(u)})}),new g(i)}leftJoin(e,s){if(this._groups.length>0||e._groups.length>0)throw new h("leftJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");s.forEach(n=>{this.verifyObservationsContainVariable(n),e.verifyObservationsContainVariable(n)});const r=new Map;e.observations.forEach(n=>{if(this.hasNullJoinKeys(n,s))return;const t=s.map(a=>JSON.stringify(this.normalizeForComparison(n[a]))).join("|"),o=r.get(t)||[];o.push(n),r.set(t,o)});const i=[];return this._observations.forEach(n=>{if(this.hasNullJoinKeys(n,s)){i.push({...n});return}const t=s.map(a=>JSON.stringify(this.normalizeForComparison(n[a]))).join("|"),o=r.get(t)||[];o.length>0?o.forEach(a=>{const u={...n};Object.entries(a).forEach(([c,f])=>{s.includes(c)||(u[c]=f)}),i.push(u)}):i.push({...n})}),new g(i)}rightJoin(e,s){if(this._groups.length>0||e._groups.length>0)throw new h("rightJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");s.forEach(t=>{this.verifyObservationsContainVariable(t),e.verifyObservationsContainVariable(t)});const r=new Map;e.observations.forEach(t=>{if(this.hasNullJoinKeys(t,s))return;const o=s.map(u=>JSON.stringify(this.normalizeForComparison(t[u]))).join("|"),a=r.get(o)||[];a.push(t),r.set(o,a)});const i=[],n=new Set;return this._observations.forEach(t=>{if(this.hasNullJoinKeys(t,s))return;const o=s.map(u=>JSON.stringify(this.normalizeForComparison(t[u]))).join("|"),a=r.get(o)||[];a.length>0&&(a.forEach(u=>{const c={...t};Object.entries(u).forEach(([f,p])=>{s.includes(f)||(c[f]=p)}),i.push(c)}),n.add(o))}),e.observations.forEach(t=>{if(this.hasNullJoinKeys(t,s)){i.push({...t});return}const o=s.map(a=>JSON.stringify(this.normalizeForComparison(t[a]))).join("|");n.has(o)||(i.push({...t}),n.add(o))}),new g(i)}fullJoin(e,s){if(this._groups.length>0||e._groups.length>0)throw new h("fullJoin() cannot be used on grouped data. Ungroup the data first using ungroup().");s.forEach(t=>{this.verifyObservationsContainVariable(t),e.verifyObservationsContainVariable(t)});const r=new Map;e.observations.forEach(t=>{if(this.hasNullJoinKeys(t,s))return;const o=s.map(u=>JSON.stringify(this.normalizeForComparison(t[u]))).join("|"),a=r.get(o)||[];a.push(t),r.set(o,a)});const i=[],n=new Set;return this._observations.forEach(t=>{if(this.hasNullJoinKeys(t,s)){i.push({...t});return}const o=s.map(u=>JSON.stringify(this.normalizeForComparison(t[u]))).join("|"),a=r.get(o)||[];a.length>0?(a.forEach(u=>{const c={...t};Object.entries(u).forEach(([f,p])=>{s.includes(f)||(c[f]=p)}),i.push(c)}),n.add(o)):i.push({...t})}),e.observations.forEach(t=>{if(this.hasNullJoinKeys(t,s)){i.push({...t});return}const o=s.map(a=>JSON.stringify(this.normalizeForComparison(t[a]))).join("|");n.has(o)||(i.push({...t}),n.add(o))}),new g(i)}slice(e,s){if(this._groups.length>0)throw new h("slice() cannot be used on grouped data. Ungroup the data first using ungroup().");let r;if(e>=this._observations.length)return new g([],{groups:this._groups});if(s===void 0){const i=e<0?this._observations.length+e:e;r=[this._observations[i]]}else r=this._observations.slice(e,s);return new g(r,{groups:this._groups})}bindRows(e){if(this._observations.length>0&&e.observations.length>0){const s=new Set(Object.keys(this._observations[0])),r=new Set(Object.keys(e.observations[0]));[...s].filter(n=>r.has(n)).forEach(n=>{const t=this.getVariableType(n),o=e.getVariableType(n);t!==o&&console.warn(`Warning: bindRows() is combining datasets with different data types for variable '${n}'. Left dataset has type '${t}' and right dataset has type '${o}'.`)})}return new g([...this._observations,...e.observations])}getVariableType(e){if(this._observations.length===0)return"unknown";const s={};this._observations.forEach(n=>{if(e in n){const t=n[e],o=t===null?"null":Array.isArray(t)?"array":typeof t;s[o]=(s[o]||0)+1}});let r=0,i="unknown";for(const[n,t]of Object.entries(s))t>r&&(r=t,i=n);return i}verifyObservationsContainVariable(e){if(!this._observations.every(s=>e in s))throw new h(`Variable ${e} does not exist for each item (row) in the data array.`)}variableExists(e){return this._observations.some(s=>e in s)}isNonMissingNumeric(e){return typeof e=="number"&&!isNaN(e)&&isFinite(e)}isMissingNumeric(e){return typeof e=="number"&&(isNaN(e)||!isFinite(e))||e===null||typeof e>"u"}normalizeForComparison(e){return e===null||typeof e!="object"?e:Array.isArray(e)?e.map(s=>this.normalizeForComparison(s)):Object.keys(e).sort().reduce((s,r)=>(s[r]=this.normalizeForComparison(e[r]),s),{})}deepCopy(e,s=new WeakMap){if(e===null||typeof e!="object")return e;if(s.has(e))return s.get(e);const r=Array.isArray(e)?[]:Object.create(Object.getPrototypeOf(e));s.set(e,r);const i=[...Object.getOwnPropertyNames(e),...Object.getOwnPropertySymbols(e)];for(const n of i){const t=Object.getOwnPropertyDescriptor(e,n);t&&Object.defineProperty(r,n,{...t,value:this.deepCopy(e[n],s)})}return r}hasNullJoinKeys(e,s){return s.some(r=>e[r]===null||e[r]===void 0)}}const E={"+":1,"-":1,"*":2,"/":2,"^":3};class m{constructor(e,s,r,i){this.leafFn=e,this.parameters=s,this.options=r,i&&i.length>0?this.tokens=i.slice():e?this.tokens=[{t:"operand",v:this}]:this.tokens=[],this.summarizeFunction=n=>this.evaluateAsValue(n)}static leaf(e,s,r){return new m(e,s,r)}cloneWithTokens(e){return new m(void 0,void 0,void 0,e)}appendOp(e,s){const r=this.tokens.slice();return r.push({t:"op",v:e}),r.push({t:"operand",v:s}),this.cloneWithTokens(r)}add(e){return this.appendOp("+",e)}sub(e){return this.appendOp("-",e)}mul(e){return this.appendOp("*",e)}div(e){return this.appendOp("/",e)}pow(e){return this.appendOp("^",e)}evaluateOperandToNumber(e,s){if(typeof e=="number")return e;const r=Array.isArray(e.parameters)?e.parameters:e.parameters===void 0?void 0:[e.parameters],i=e.leafFn?e.leafFn(s,r,e.options):e.evaluateAsValue(s);if(i==null)return NaN;const n=Number(i);return typeof n=="number"&&!isNaN(n)?n:NaN}evaluateFlatTokens(e,s){const r=[],i=[];for(const t of e)t.t==="operand"?r.push(t.v):i.push(t.v);if(r.length===0)return NaN;for(;i.length>0;){let t=0,o=E[i[0]]??0;for(let N=1;N<i.length;N++){const O=E[i[N]]??0;(O>o||O===o&&i[N]==="^")&&(o=O,t=N)}const a=i.splice(t,1)[0],u=r.splice(t,1)[0],c=r.splice(t,1)[0],f=this.evaluateOperandToNumber(u,s),p=this.evaluateOperandToNumber(c,s);let v=NaN;a==="+"?v=f+p:a==="-"?v=f-p:a==="*"?v=f*p:a==="/"?v=p===0?NaN:f/p:a==="^"&&(v=Math.pow(f,p)),r.splice(t,0,v)}const n=r[0];return typeof n=="number"?n:this.evaluateOperandToNumber(n,s)}parens(){return V(this)}evaluateAsValue(e){if(this.leafFn){const r=Array.isArray(this.parameters)?this.parameters:this.parameters===void 0?void 0:[this.parameters],i=this.leafFn(e,r,this.options);return typeof i=="number"&&Number.isNaN(i)?null:i}if(!this.tokens||this.tokens.length===0)return NaN;const s=this.evaluateFlatTokens(this.tokens,e);return typeof s=="number"&&Number.isNaN(s)?null:s}}function V(l){const e=[{t:"operand",v:l}];return new m(void 0,void 0,void 0,e)}const I={coerceBooleans:!0,skipMissing:!1};function b(l){return{...I,...l}}function y(l,e,s,r,i,n){const t=b(s);l.verifyObservationsContainVariable(e);let o=0,a=n,u=!1;return l.observations.forEach(c=>{if(l.isNonMissingNumeric(c[e])){a=r(c[e],a),o++;return}if(typeof c[e]=="boolean"&&t.coerceBooleans){a=r(c[e]?1:0,a),o++;return}if(l.isMissingNumeric(c[e])){u=!0;return}throw new h(`${i}: variable ${e} has non-numeric value ${c[e]} in this observation: ${JSON.stringify(c)}`)}),{state:a,count:o,containsMissing:u}}function w(l,e,s,r,i){const n=b(e);let t=i,o=0,a=!1;for(const u of l)if(typeof u=="number"&&!isNaN(u)&&isFinite(u))t=s(u,t),o++;else if(typeof u=="boolean"&&n.coerceBooleans)t=s(u?1:0,t),o++;else if(u==null||typeof u=="number"&&(isNaN(u)||!isFinite(u)))a=!0;else throw new h(`${r}: has non-numeric value ${u}`);return{state:t,count:o,containsMissing:a}}function d(l,e,s){const r=b(e);if(typeof l=="number"&&!isNaN(l)&&isFinite(l))return{value:l,isMissing:!1};if(typeof l=="boolean"&&r.coerceBooleans)return{value:l?1:0,isMissing:!1};if(l==null||typeof l=="number"&&(isNaN(l)||!isFinite(l)))return{value:0,isMissing:!0};throw new h(`${s}: has non-numeric value ${l}`)}const F=l=>l.length;function j(){return m.leaf(F,[],void 0)}const k=(l,e,s)=>{const r=e?e[0]:void 0,i=b(s);if(typeof r=="string"){if(!l.variableExists(r))return null;const t=y(l,r,s,(o,a)=>a+o,"sum()",0);return t.containsMissing&&!i.skipMissing||t.count===0?null:t.state}else if(Array.isArray(r)){const n=w(r,s,(t,o)=>o+t,"sum()",0);return n.containsMissing&&!i.skipMissing||n.count===0?null:n.state}else{const n=d(r,s,"sum()");return n.isMissing&&!i.skipMissing||n.isMissing?null:n.value}};function A(l,e){return m.leaf(k,[l],e)}const S=(l,e,s)=>{const r=e?e[0]:void 0,i=b(s);if(typeof r=="string"){if(!l.variableExists(r))return null;const t=y(l,r,s,(o,a)=>a+o,"mean()",0);return t.containsMissing&&!i.skipMissing||t.count===0?null:t.state/t.count}else if(Array.isArray(r)){const n=w(r,s,(t,o)=>o+t,"mean()",0);return n.containsMissing&&!i.skipMissing||n.count===0?null:n.state/n.count}else{const n=d(r,s,"mean()");return n.isMissing&&!i.skipMissing?null:n.value}};function T(l,e){return m.leaf(S,[l],e)}const M=(l,e,s)=>{const r=e?e[0]:void 0,i=b(s);if(typeof r=="string"){if(!l.variableExists(r))return null;const n=r,t=y(l,n,s,(u,c)=>c+u,"variance()",0);if(t.containsMissing&&!i.skipMissing||t.count<=1)return null;const o=t.state/t.count;return y(l,n,s,(u,c)=>{const f=typeof u=="boolean"&&i.coerceBooleans?u?1:0:u;return c+Math.pow(f-o,2)},"variance()",0).state/(t.count-1)}else if(Array.isArray(r)){const n=[];let t=!1;for(const c of r)if(typeof c=="number"&&!isNaN(c)&&isFinite(c))n.push(c);else if(typeof c=="boolean"&&i.coerceBooleans)n.push(c?1:0);else if(c==null||typeof c=="number"&&(isNaN(c)||!isFinite(c)))t=!0;else throw new h(`variance(): has non-numeric value ${c}`);if(t&&!i.skipMissing||n.length<=1)return null;const a=n.reduce((c,f)=>c+f,0)/n.length;return n.reduce((c,f)=>c+Math.pow(f-a,2),0)/(n.length-1)}else return null};function J(l,e){return m.leaf(M,[l],e)}const $=(l,e,s)=>{const r=e?e[0]:void 0,i=b(s);if(typeof r=="string"){if(!l.variableExists(r))return null;const t=y(l,r,s,(o,a)=>a===Number.POSITIVE_INFINITY||o<a?o:a,"min()",Number.POSITIVE_INFINITY);return t.containsMissing&&!i.skipMissing||t.count===0?null:t.state}else if(Array.isArray(r)){const n=w(r,s,(t,o)=>o===Number.POSITIVE_INFINITY||t<o?t:o,"min()",Number.POSITIVE_INFINITY);return n.containsMissing&&!i.skipMissing||n.count===0?null:n.state}else{const n=d(r,s,"min()");return n.isMissing&&!i.skipMissing||n.isMissing?null:n.value}};function z(l,e){return m.leaf($,[l],e)}const x=(l,e,s)=>{const r=e?e[0]:void 0,i=b(s);if(typeof r=="string"){if(!l.variableExists(r))return null;const t=y(l,r,s,(o,a)=>a===Number.NEGATIVE_INFINITY||o>a?o:a,"max()",Number.NEGATIVE_INFINITY);return t.containsMissing&&!i.skipMissing||t.count===0?null:t.state}else if(Array.isArray(r)){const n=w(r,s,(t,o)=>o===Number.NEGATIVE_INFINITY||t>o?t:o,"max()",Number.NEGATIVE_INFINITY);return n.containsMissing&&!i.skipMissing||n.count===0?null:n.state}else{const n=d(r,s,"max()");return n.isMissing&&!i.skipMissing||n.isMissing?null:n.value}};function K(l,e){return m.leaf(x,[l],e)}const P=(l,e,s)=>{const r=e?e[0]:void 0,i=b(s);if(typeof r=="string"){if(!l.variableExists(r))return null;const n=r;l.verifyObservationsContainVariable(n);const t=[];let o=!1;if(l.observations.forEach(u=>{if(l.isNonMissingNumeric(u[n]))t.push(u[n]);else if(typeof u[n]=="boolean"&&i.coerceBooleans)t.push(u[n]?1:0);else if(l.isMissingNumeric(u[n]))o=!0;else throw new h(`median(): variable ${n} has non-numeric value ${u[n]} in this observation: ${JSON.stringify(u)}`)}),o&&!i.skipMissing||t.length===0)return null;t.sort((u,c)=>u-c);const a=Math.floor(t.length/2);return t.length%2===0?(t[a-1]+t[a])/2:t[a]}else if(Array.isArray(r)){const n=[];let t=!1;for(const a of r)if(typeof a=="number"&&!isNaN(a)&&isFinite(a))n.push(a);else if(typeof a=="boolean"&&i.coerceBooleans)n.push(a?1:0);else if(a==null||typeof a=="number"&&(isNaN(a)||!isFinite(a)))t=!0;else throw new h(`median(): has non-numeric value ${a}`);if(t&&!i.skipMissing||n.length===0)return null;n.sort((a,u)=>a-u);const o=Math.floor(n.length/2);return n.length%2===0?(n[o-1]+n[o])/2:n[o]}else{const n=d(r,s,"median()");return n.isMissing&&!i.skipMissing||n.isMissing?null:n.value}};function B(l,e){return m.leaf(P,[l],e)}const C=(l,e,s)=>{const r=e?e[0]:void 0;if(typeof r=="string"){if(!l.variableExists(r))return null;const i=M(l,e,s);return i===null?null:Math.sqrt(i)}else if(Array.isArray(r)){const i=e?[...e]:[r],n=M(l,i,s);return n===null?null:Math.sqrt(n)}else return null};function R(l,e){return m.leaf(C,[l],e)}const U=(l,e,s)=>{const r=e?e[0]:void 0,i=d(r,s,"scalar()");return i.isMissing?null:i.value};function _(l){return m.leaf(U,[l],void 0)}const W=_;console.log("\u26AA @m2c2kit/data-calc version 0.8.6 (c86b5047)");export{g as DataCalc,m as SummarizeOperation,K as max,T as mean,B as median,z as min,j as n,V as parens,W as s,_ as scalar,R as sd,A as sum,J as variance};
