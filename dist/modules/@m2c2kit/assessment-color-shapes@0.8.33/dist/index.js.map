{"version":3,"file":"index.js","sources":["../../data-calc/dist/index.js","../src/index.ts"],"sourcesContent":["class M2Error extends Error {\n  constructor(...params) {\n    super(...params);\n    this.name = \"M2Error\";\n    Object.setPrototypeOf(this, M2Error.prototype);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, M2Error);\n    }\n  }\n}\n\nclass DataCalc {\n  /**\n   * A class for transformation and calculation of m2c2kit data.\n   *\n   * @remarks The purpose is to provide a simple and intuitive interface for\n   * assessments to score and summarize their own data. It is not meant for\n   * data analysis or statistical modeling. The idiomatic approach is based on the\n   * dplyr R package.\n   *\n   * @param data - An array of observations, where each observation is a set of\n   * key-value pairs of variable names and values.\n   * @param options - Options, such as groups to group the data by\n   * @example\n   * ```js\n   * const dc = new DataCalc(gameData.trials);\n   * const mean_response_time_correct_trials = dc\n   *  .filter((obs) => obs.correct_response_index === obs.user_response_index)\n   *  .summarize({ mean_rt: mean(\"response_time_duration_ms\") })\n   *  .pull(\"mean_rt\");\n   * ```\n   */\n  constructor(data, options) {\n    this._groups = new Array();\n    if (!Array.isArray(data)) {\n      throw new M2Error(\n        \"DataCalc constructor expects an array of observations as first argument\"\n      );\n    }\n    for (let i = 0; i < data.length; i++) {\n      if (data[i] === null || typeof data[i] !== \"object\" || Array.isArray(data[i])) {\n        throw new M2Error(\n          `DataCalc constructor expects all elements to be objects (observations). Element at index ${i} is ${typeof data[i]}. Element: ${JSON.stringify(data[i])}`\n        );\n      }\n    }\n    this._observations = this.deepCopy(data);\n    const allVariables = /* @__PURE__ */ new Set();\n    for (const observation of data) {\n      for (const key of Object.keys(observation)) {\n        allVariables.add(key);\n      }\n    }\n    for (const observation of this._observations) {\n      for (const variable of allVariables) {\n        if (!(variable in observation)) {\n          observation[variable] = null;\n        }\n      }\n    }\n    if (options?.groups) {\n      this._groups = Array.from(options.groups);\n    }\n  }\n  /**\n   * Returns the groups in the data.\n   */\n  get groups() {\n    return this._groups;\n  }\n  /**\n   * Returns the observations in the data.\n   *\n   * @remarks An observation is conceptually similar to a row in a dataset,\n   * where the keys are the variable names and the values are the variable values.\n   */\n  get observations() {\n    return this._observations;\n  }\n  /**\n   * Alias for the observations property.\n   */\n  get rows() {\n    return this._observations;\n  }\n  /**\n   * Returns a single variable from the data.\n   *\n   * @remarks If the variable length is 1, the value is returned. If the\n   * variable has length > 1, an array of values is returned. If an empty\n   * dataset is provided, `null` is returned and a warning is logged.\n   *\n   * @param variable - Name of variable to pull from the data\n   * @returns the value of the variable\n   *\n   * @example\n   * ```js\n   * const d = [{ a: 1, b: 2, c: 3 }];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.pull(\"c\")\n   * ); // 3\n   * ```\n   */\n  pull(variable) {\n    if (this._observations.length === 0) {\n      console.warn(\n        `DataCalc.pull(): No observations available to pull variable \"${variable}\" from. Returning null.`\n      );\n      return null;\n    }\n    this.verifyObservationsContainVariable(variable);\n    const values = this._observations.map((o) => o[variable]);\n    if (values.length === 1) {\n      return values[0];\n    }\n    return values;\n  }\n  /**\n   * Returns the number of observations in the data.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.length\n   * ); // 2\n   * ```\n   */\n  get length() {\n    return this._observations.length;\n  }\n  /**\n   * Filters observations based on a predicate function.\n   *\n   * @param predicate - A function that returns true for observations to keep and\n   * false for observations to discard\n   * @returns A new `DataCalc` object with only the observations that pass the\n   * predicate function\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.filter((obs) => obs.b >= 3).observations);\n   * // [ { a: 0, b: 8, c: 3 }, { a: 9, b: 4, c: 7 } ]\n   * ```\n   */\n  filter(predicate) {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `filter() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \"\n        )}. Ungroup the data first using ungroup().`\n      );\n    }\n    return new DataCalc(\n      this._observations.filter(\n        predicate\n      ),\n      { groups: this._groups }\n    );\n  }\n  /**\n   * Groups observations by one or more variables.\n   *\n   * @remarks This is used with the `summarize()` method to calculate summaries\n   * by group.\n   *\n   * @param groups - variable names to group by\n   * @returns A new `DataCalc` object with the observations grouped by one or\n   * more variables\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   *   { a: 5, b: 0, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * const grouped = dc.groupBy(\"c\");\n   * // subsequent summarize operations will be performed separately by\n   * // each unique level of c, in this case, 3 and 7\n   * ```\n   */\n  groupBy(...groups) {\n    groups.forEach((group) => {\n      this.verifyObservationsContainVariable(group);\n    });\n    return new DataCalc(this._observations, { groups });\n  }\n  /**\n   * Ungroups observations.\n   *\n   * @returns A new DataCalc object with the observations ungrouped\n   */\n  ungroup() {\n    return new DataCalc(this._observations);\n  }\n  /**\n   * Adds new variables to the observations based on the provided mutation options.\n   *\n   * @param mutations - An object where the keys are the names of the new variables\n   * and the values are functions that take an observation and return the value\n   * for the new variable.\n   * @returns A new DataCalc object with the new variables added to the observations.\n   *\n   * @example\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.mutate({ doubledA: (obs) => obs.a * 2 }).observations\n   * );\n   * // [ { a: 1, b: 2, c: 3, doubledA: 2 },\n   * //   { a: 0, b: 8, c: 3, doubledA: 0 },\n   * //   { a: 9, b: 4, c: 7, doubledA: 18 } ]\n   */\n  mutate(mutations) {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `mutate() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \"\n        )}. Ungroup the data first using ungroup().`\n      );\n    }\n    const newObservations = this._observations.map((observation) => {\n      let newObservation = { ...observation };\n      for (const [newVariable, transformFunction] of Object.entries(\n        mutations\n      )) {\n        newObservation = {\n          ...newObservation,\n          [newVariable]: transformFunction(observation)\n        };\n      }\n      return newObservation;\n    });\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n  /**\n   * Calculates summaries of the data.\n   *\n   * @param summarizations - An object where the keys are the names of the new\n   * variables and the values are `DataCalc` summary functions: `sum()`,\n   * `mean()`, `median()`, `variance()`, `sd()`, `min()`, `max()`, or `n()`.\n   * The summary functions take a variable name as a string, or alternatively,\n   * a value or array of values to summarize.\n   * @returns A new `DataCalc` object with the new summary variables.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   *   { a: 5, b: 0, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.summarize({\n   *     meanA: mean(\"a\"),\n   *     varA: variance(\"a\"),\n   *     totalB: sum(\"b\")\n   *   }).observations\n   * );\n   * // [ { meanA: 3.75, varA: 16.916666666666668, totalB: 14 } ]\n   *\n   * console.log(\n   *   dc.summarize({\n   *    filteredTotalC: sum(dc.filter(obs => obs.b > 2).pull(\"c\"))\n   *  }).observations\n   * );\n   * // [ { filteredTotalC: 10 } ]\n   * ```\n   */\n  summarize(summarizations) {\n    if (this._groups.length === 0) {\n      const obs = {};\n      for (const [newVariable, value] of Object.entries(summarizations)) {\n        if (typeof value === \"object\" && value !== null && \"summarizeFunction\" in value) {\n          const summarizeOperation = value;\n          obs[newVariable] = summarizeOperation.summarizeFunction(\n            this,\n            summarizeOperation.parameters,\n            summarizeOperation.options\n          );\n        } else {\n          obs[newVariable] = value;\n        }\n      }\n      return new DataCalc([obs], { groups: this._groups });\n    }\n    return this.summarizeByGroups(summarizations);\n  }\n  summarizeByGroups(summarizations) {\n    const groupMap = /* @__PURE__ */ new Map();\n    this._observations.forEach((obs) => {\n      const groupKey = this._groups.map(\n        (g) => typeof obs[g] === \"object\" ? JSON.stringify(obs[g]) : obs[g]\n      ).join(\"|\");\n      if (!groupMap.has(groupKey)) {\n        groupMap.set(groupKey, []);\n      }\n      const groupArray = groupMap.get(groupKey);\n      if (groupArray) {\n        groupArray.push(obs);\n      } else {\n        groupMap.set(groupKey, [obs]);\n      }\n    });\n    const summarizedObservations = [];\n    groupMap.forEach((groupObs, groupKey) => {\n      const groupValues = groupKey.split(\"|\");\n      const firstObs = groupObs[0];\n      const summaryObj = {};\n      this._groups.forEach((group, i) => {\n        const valueStr = groupValues[i];\n        const originalType = typeof firstObs[group];\n        if (originalType === \"number\") {\n          summaryObj[group] = Number(valueStr);\n        } else if (originalType === \"boolean\") {\n          summaryObj[group] = valueStr === \"true\";\n        } else if (valueStr.startsWith(\"{\") || valueStr.startsWith(\"[\")) {\n          try {\n            summaryObj[group] = JSON.parse(valueStr);\n          } catch {\n            throw new M2Error(\n              `Failed to parse group value ${valueStr} as JSON for group ${group}`\n            );\n          }\n        } else {\n          summaryObj[group] = valueStr;\n        }\n      });\n      const groupDataCalc = new DataCalc(groupObs);\n      for (const [newVariable, value] of Object.entries(summarizations)) {\n        if (typeof value === \"object\" && value !== null && \"summarizeFunction\" in value) {\n          const summarizeOperation = value;\n          summaryObj[newVariable] = summarizeOperation.summarizeFunction(\n            groupDataCalc,\n            summarizeOperation.parameters,\n            summarizeOperation.options\n          );\n        } else {\n          summaryObj[newVariable] = value;\n        }\n      }\n      summarizedObservations.push(summaryObj);\n    });\n    return new DataCalc(summarizedObservations, { groups: this._groups });\n  }\n  /**\n   * Selects specific variables to keep in the dataset.\n   * Variables prefixed with \"-\" will be excluded from the result.\n   *\n   * @param variables - Names of variables to select; prefix with '-' to exclude instead\n   * @returns A new DataCalc object with only the selected variables (minus excluded ones)\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3, d: 4 },\n   *   { a: 5, b: 6, c: 7, d: 8 }\n   * ];\n   * const dc = new DataCalc(d);\n   * // Keep a and c\n   * console.log(dc.select(\"a\", \"c\").observations);\n   * // [ { a: 1, c: 3 }, { a: 5, c: 7 } ]\n   * ```\n   */\n  select(...variables) {\n    const includeVars = [];\n    const excludeVars = [];\n    variables.forEach((variable) => {\n      if (variable.startsWith(\"-\")) {\n        excludeVars.push(variable.substring(1));\n      } else {\n        includeVars.push(variable);\n      }\n    });\n    const allVars = includeVars.length > 0 ? includeVars : Object.keys(this._observations[0] || {});\n    [...allVars, ...excludeVars].forEach((variable) => {\n      this.verifyObservationsContainVariable(variable);\n    });\n    const excludeSet = new Set(excludeVars);\n    const newObservations = this._observations.map((observation) => {\n      const newObservation = {};\n      if (includeVars.length > 0) {\n        includeVars.forEach((variable) => {\n          if (!excludeSet.has(variable)) {\n            newObservation[variable] = observation[variable];\n          }\n        });\n      } else {\n        Object.keys(observation).forEach((key) => {\n          if (!excludeSet.has(key)) {\n            newObservation[key] = observation[key];\n          }\n        });\n      }\n      return newObservation;\n    });\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n  /**\n   * Arranges (sorts) the observations based on one or more variables.\n   *\n   * @param variables - Names of variables to sort by, prefixed with '-' for descending order\n   * @returns A new DataCalc object with the observations sorted\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 5, b: 2 },\n   *   { a: 3, b: 7 },\n   *   { a: 5, b: 1 }\n   * ];\n   * const dc = new DataCalc(d);\n   * // Sort by a (ascending), then by b (descending)\n   * console.log(dc.arrange(\"a\", \"-b\").observations);\n   * // [ { a: 3, b: 7 }, { a: 5, b: 2 }, { a: 5, b: 1 } ]\n   * ```\n   */\n  arrange(...variables) {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `arrange() cannot be used on grouped data. The data are currently grouped by ${this._groups.join(\n          \", \"\n        )}. Ungroup the data first using ungroup().`\n      );\n    }\n    const sortedObservations = [...this._observations].sort((a, b) => {\n      for (const variable of variables) {\n        let varName = variable;\n        let direction = 1;\n        if (variable.startsWith(\"-\")) {\n          varName = variable.substring(1);\n          direction = -1;\n        }\n        if (!(varName in a) || !(varName in b)) {\n          throw new M2Error(\n            `arrange(): variable ${varName} does not exist in all observations`\n          );\n        }\n        const aVal = a[varName];\n        const bVal = b[varName];\n        if (typeof aVal !== typeof bVal) {\n          return direction * (String(aVal) < String(bVal) ? -1 : 1);\n        }\n        if (aVal < bVal) return -1 * direction;\n        if (aVal > bVal) return 1 * direction;\n      }\n      return 0;\n    });\n    return new DataCalc(sortedObservations, { groups: this._groups });\n  }\n  /**\n   * Keeps only unique/distinct observations.\n   *\n   * @returns A new `DataCalc` object with only unique observations\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 1, b: 2, c: 3 }, // Duplicate\n   *   { a: 2, b: 3, c: 5 },\n   *   { a: 1, b: 2, c: { name: \"dog\" } },\n   *   { a: 1, b: 2, c: { name: \"dog\" } } // Duplicate with nested object\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.distinct().observations);\n   * // [ { a: 1, b: 2, c: 3 }, { a: 2, b: 3, c: 5 }, { a: 1, b: 2, c: { name: \"dog\" } } ]\n   * ```\n   */\n  distinct() {\n    const seen = /* @__PURE__ */ new Set();\n    const uniqueObs = this._observations.filter((obs) => {\n      const key = JSON.stringify(this.normalizeForComparison(obs));\n      if (seen.has(key)) return false;\n      seen.add(key);\n      return true;\n    });\n    return new DataCalc(uniqueObs, { groups: this._groups });\n  }\n  /**\n   * Renames variables in the observations.\n   *\n   * @param renames - Object mapping new variable names to old variable names\n   * @returns A new DataCalc object with renamed variables\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 4, b: 5, c: 6 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.rename({ x: 'a', z: 'c' }).observations);\n   * // [ { x: 1, b: 2, z: 3 }, { x: 4, b: 5, z: 6 } ]\n   * ```\n   */\n  rename(renames) {\n    if (this._observations.length === 0) {\n      throw new M2Error(\"Cannot rename variables on an empty dataset\");\n    }\n    Object.values(renames).forEach((oldName) => {\n      this.verifyObservationsContainVariable(oldName);\n    });\n    const newObservations = this._observations.map((observation) => {\n      const newObservation = {};\n      for (const [key, value] of Object.entries(observation)) {\n        const newKey = Object.entries(renames).find(\n          ([, old]) => old === key\n        )?.[0];\n        if (newKey) {\n          newObservation[newKey] = value;\n        } else if (!Object.values(renames).includes(key)) {\n          newObservation[key] = value;\n        }\n      }\n      return newObservation;\n    });\n    return new DataCalc(newObservations, { groups: this._groups });\n  }\n  /**\n   * Performs an inner join with another DataCalc object.\n   * Only rows with matching keys in both datasets are included.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.innerJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 } ]\n   * ```\n   */\n  innerJoin(other, by) {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `innerJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`\n      );\n    }\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n    const rightMap = /* @__PURE__ */ new Map();\n    other.observations.forEach((obs) => {\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(obs[k]))).join(\"|\");\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n    const result = [];\n    this._observations.forEach((leftObs) => {\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k]))).join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n      if (rightMatches.length > 0) {\n        rightMatches.forEach((rightObs) => {\n          const joinedObs = { ...leftObs };\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n          result.push(joinedObs);\n        });\n      }\n    });\n    return new DataCalc(result);\n  }\n  /**\n   * Performs a left join with another DataCalc object.\n   * All rows from the left dataset are included, along with matching rows from the right.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.leftJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 }, { id: 3, x: 'c' } ]\n   * ```\n   */\n  leftJoin(other, by) {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `leftJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`\n      );\n    }\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n    const rightMap = /* @__PURE__ */ new Map();\n    other.observations.forEach((obs) => {\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(obs[k]))).join(\"|\");\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n    const result = [];\n    this._observations.forEach((leftObs) => {\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        result.push({ ...leftObs });\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k]))).join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n      if (rightMatches.length > 0) {\n        rightMatches.forEach((rightObs) => {\n          const joinedObs = { ...leftObs };\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n          result.push(joinedObs);\n        });\n      } else {\n        result.push({ ...leftObs });\n      }\n    });\n    return new DataCalc(result);\n  }\n  /**\n   * Performs a right join with another DataCalc object.\n   * All rows from the right dataset are included, along with matching rows from the left.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.rightJoin(dc2, [\"id\"]).observations);\n   * // [ { id: 1, x: 'a', y: 100 }, { id: 2, x: 'b', y: 200 }, { id: 4, y: 400 } ]\n   * ```\n   */\n  rightJoin(other, by) {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `rightJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`\n      );\n    }\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n    const rightMap = /* @__PURE__ */ new Map();\n    other.observations.forEach((obs) => {\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(obs[k]))).join(\"|\");\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n    const result = [];\n    const processedRightKeys = /* @__PURE__ */ new Set();\n    this._observations.forEach((leftObs) => {\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k]))).join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n      if (rightMatches.length > 0) {\n        rightMatches.forEach((rightObs) => {\n          const joinedObs = { ...leftObs };\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n          result.push(joinedObs);\n        });\n        processedRightKeys.add(key);\n      }\n    });\n    other.observations.forEach((rightObs) => {\n      if (this.hasNullJoinKeys(rightObs, by)) {\n        result.push({ ...rightObs });\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(rightObs[k]))).join(\"|\");\n      if (!processedRightKeys.has(key)) {\n        result.push({ ...rightObs });\n        processedRightKeys.add(key);\n      }\n    });\n    return new DataCalc(result);\n  }\n  /**\n   * Performs a full join with another DataCalc object.\n   * All rows from both datasets are included.\n   *\n   * @param other - The other DataCalc object to join with\n   * @param by - The variables to join on\n   * @returns A new DataCalc object with joined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { id: 1, x: 'a' },\n   *   { id: 2, x: 'b' },\n   *   { id: 3, x: 'c' }\n   * ];\n   * const d2 = [\n   *   { id: 1, y: 100 },\n   *   { id: 2, y: 200 },\n   *   { id: 4, y: 400 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.fullJoin(dc2, [\"id\"]).observations);\n   * // [\n   * //   { id: 1, x: 'a', y: 100 },\n   * //   { id: 2, x: 'b', y: 200 },\n   * //   { id: 3, x: 'c' },\n   * //   { id: 4, y: 400 }\n   * // ]\n   * ```\n   */\n  fullJoin(other, by) {\n    if (this._groups.length > 0 || other._groups.length > 0) {\n      throw new M2Error(\n        `fullJoin() cannot be used on grouped data. Ungroup the data first using ungroup().`\n      );\n    }\n    by.forEach((key) => {\n      this.verifyObservationsContainVariable(key);\n      other.verifyObservationsContainVariable(key);\n    });\n    const rightMap = /* @__PURE__ */ new Map();\n    other.observations.forEach((obs) => {\n      if (this.hasNullJoinKeys(obs, by)) {\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(obs[k]))).join(\"|\");\n      const matches = rightMap.get(key) || [];\n      matches.push(obs);\n      rightMap.set(key, matches);\n    });\n    const result = [];\n    const processedRightKeys = /* @__PURE__ */ new Set();\n    this._observations.forEach((leftObs) => {\n      if (this.hasNullJoinKeys(leftObs, by)) {\n        result.push({ ...leftObs });\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(leftObs[k]))).join(\"|\");\n      const rightMatches = rightMap.get(key) || [];\n      if (rightMatches.length > 0) {\n        rightMatches.forEach((rightObs) => {\n          const joinedObs = { ...leftObs };\n          Object.entries(rightObs).forEach(([k, v]) => {\n            if (!by.includes(k)) {\n              joinedObs[k] = v;\n            }\n          });\n          result.push(joinedObs);\n        });\n        processedRightKeys.add(key);\n      } else {\n        result.push({ ...leftObs });\n      }\n    });\n    other.observations.forEach((rightObs) => {\n      if (this.hasNullJoinKeys(rightObs, by)) {\n        result.push({ ...rightObs });\n        return;\n      }\n      const key = by.map((k) => JSON.stringify(this.normalizeForComparison(rightObs[k]))).join(\"|\");\n      if (!processedRightKeys.has(key)) {\n        result.push({ ...rightObs });\n        processedRightKeys.add(key);\n      }\n    });\n    return new DataCalc(result);\n  }\n  /**\n   * Slice observations by position.\n   *\n   * @param start - Starting position (0-based). Negative values count from\n   * the end.\n   * @param end - Ending position (exclusive)\n   * @returns A new DataCalc object with sliced observations\n   *\n   * @remarks If `end` is not provided, it will return a single observation at\n   * `start` position. If `start` is beyond the length of observations,\n   * it will return an empty DataCalc.\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2 },\n   *   { a: 3, b: 4 },\n   *   { a: 5, b: 6 },\n   *   { a: 7, b: 8 }\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(dc.slice(1, 3).observations);\n   * // [ { a: 3, b: 4 }, { a: 5, b: 6 } ]\n   * console.log(dc.slice(0).observations);\n   * // [ { a: 1, b: 2 } ]\n   * ```\n   */\n  slice(start, end) {\n    if (this._groups.length > 0) {\n      throw new M2Error(\n        `slice() cannot be used on grouped data. Ungroup the data first using ungroup().`\n      );\n    }\n    let sliced;\n    if (start >= this._observations.length) {\n      return new DataCalc([], { groups: this._groups });\n    }\n    if (end === void 0) {\n      const index = start < 0 ? this._observations.length + start : start;\n      sliced = [this._observations[index]];\n    } else {\n      sliced = this._observations.slice(start, end);\n    }\n    return new DataCalc(sliced, { groups: this._groups });\n  }\n  /**\n   * Combines observations from two DataCalc objects by rows.\n   *\n   * @param other - The other DataCalc object to bind with\n   * @returns A new DataCalc object with combined observations\n   *\n   * @example\n   * ```js\n   * const d1 = [\n   *   { a: 1, b: 2 },\n   *   { a: 3, b: 4 }\n   * ];\n   * const d2 = [\n   *   { a: 5, b: 6 },\n   *   { a: 7, b: 8 }\n   * ];\n   * const dc1 = new DataCalc(d1);\n   * const dc2 = new DataCalc(d2);\n   * console.log(dc1.bindRows(dc2).observations);\n   * // [ { a: 1, b: 2 }, { a: 3, b: 4 }, { a: 5, b: 6 }, { a: 7, b: 8 } ]\n   * ```\n   */\n  bindRows(other) {\n    if (this._observations.length > 0 && other.observations.length > 0) {\n      const thisVariables = new Set(Object.keys(this._observations[0]));\n      const otherVariables = new Set(Object.keys(other.observations[0]));\n      const commonVariables = [...thisVariables].filter(\n        (variable) => otherVariables.has(variable)\n      );\n      commonVariables.forEach((variable) => {\n        const thisType = this.getVariableType(variable);\n        const otherType = other.getVariableType(variable);\n        if (thisType !== otherType) {\n          console.warn(\n            `Warning: bindRows() is combining datasets with different data types for variable '${variable}'. Left dataset has type '${thisType}' and right dataset has type '${otherType}'.`\n          );\n        }\n      });\n    }\n    return new DataCalc([...this._observations, ...other.observations]);\n  }\n  /**\n   * Helper method to determine the primary type of a variable across observations\n   * @internal\n   *\n   * @param variable - The variable name to check\n   * @returns The most common type for the variable or 'mixed' if no clear type exists\n   */\n  getVariableType(variable) {\n    if (this._observations.length === 0) {\n      return \"unknown\";\n    }\n    const typeCounts = {};\n    this._observations.forEach((obs) => {\n      if (variable in obs) {\n        const value = obs[variable];\n        const type = value === null ? \"null\" : Array.isArray(value) ? \"array\" : typeof value;\n        typeCounts[type] = (typeCounts[type] || 0) + 1;\n      }\n    });\n    let maxCount = 0;\n    let dominantType = \"unknown\";\n    for (const [type, count] of Object.entries(typeCounts)) {\n      if (count > maxCount) {\n        maxCount = count;\n        dominantType = type;\n      }\n    }\n    return dominantType;\n  }\n  /**\n   * Verifies that the variable exists in each observation in the data.\n   *\n   * @remarks Throws an error if the variable does not exist in each\n   * observation. This is not meant to be called by users of the library, but\n   * is used internally.\n   * @internal\n   *\n   * @param variable - The variable to check for\n   */\n  verifyObservationsContainVariable(variable) {\n    if (!this._observations.every((observation) => variable in observation)) {\n      throw new M2Error(\n        `Variable ${variable} does not exist for each item (row) in the data array.`\n      );\n    }\n  }\n  /**\n   * Checks if the variable exists for at least one observation in the data.\n   *\n   * @remarks This is not meant to be called by users of the library, but\n   * is used internally.\n   * @internal\n   *\n   * @param variable - The variable to check for\n   * @returns true if the variable exists in at least one observation, false\n   * otherwise\n   */\n  variableExists(variable) {\n    return this._observations.some((observation) => variable in observation);\n  }\n  /**\n   * Checks if a value is a non-missing numeric value.\n   *\n   * @remarks A non-missing numeric value is a value that is a number and is\n   * not NaN or infinite.\n   *\n   * @param value - The value to check\n   * @returns true if the value is a non-missing numeric value, false otherwise\n   */\n  isNonMissingNumeric(value) {\n    return typeof value === \"number\" && !isNaN(value) && isFinite(value);\n  }\n  /**\n   * Checks if a value is a missing numeric value.\n   *\n   * @remarks A missing numeric value is a number that is NaN or infinite, or any\n   * value that is null or undefined. Thus, a null or undefined value is\n   * considered to be a missing numeric value.\n   *\n   * @param value - The value to check\n   * @returns true if the value is a missing numeric value, false otherwise\n   */\n  isMissingNumeric(value) {\n    return typeof value === \"number\" && (isNaN(value) || !isFinite(value)) || value === null || typeof value === \"undefined\";\n  }\n  /**\n   * Normalizes an object for stable comparison by sorting keys\n   * @internal\n   *\n   * @remarks Normalizing is needed to handle situations where objects have the\n   * same properties but in different orders because we are using\n   * JSON.stringify() for comparison.\n   */\n  normalizeForComparison(obj) {\n    if (obj === null || typeof obj !== \"object\") {\n      return obj;\n    }\n    if (Array.isArray(obj)) {\n      return obj.map((item) => this.normalizeForComparison(item));\n    }\n    return Object.keys(obj).sort().reduce((result, key) => {\n      result[key] = this.normalizeForComparison(obj[key]);\n      return result;\n    }, {});\n  }\n  /**\n   * Creates a deep copy of an object.\n   * @internal\n   *\n   * @remarks We create a deep copy of the object, in our case an instance\n   * of `DataCalc`, to ensure that we are working with a new object\n   * without any references to the original object. This is important\n   * to avoid unintended side effects when modifying an object.\n   *\n   * @param source - object to copy\n   * @param map - map of objects that have already been copied\n   * @returns a deep copy of the object\n   */\n  deepCopy(source, map = /* @__PURE__ */ new WeakMap()) {\n    if (source === null || typeof source !== \"object\") {\n      return source;\n    }\n    if (map.has(source)) {\n      return map.get(source);\n    }\n    const copy = Array.isArray(source) ? [] : Object.create(Object.getPrototypeOf(source));\n    map.set(source, copy);\n    const keys = [\n      ...Object.getOwnPropertyNames(source),\n      ...Object.getOwnPropertySymbols(source)\n    ];\n    for (const key of keys) {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        source,\n        key\n      );\n      if (descriptor) {\n        Object.defineProperty(copy, key, {\n          ...descriptor,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          value: this.deepCopy(source[key], map)\n        });\n      }\n    }\n    return copy;\n  }\n  /**\n   * Checks if an observation has null or undefined values in any of the join columns.\n   * @internal\n   *\n   * @param obs - The observation to check\n   * @param keys - The join columns to check\n   * @returns true if any join column has a null or undefined value\n   */\n  hasNullJoinKeys(obs, keys) {\n    return keys.some((key) => obs[key] === null || obs[key] === void 0);\n  }\n}\n\nconst PRECEDENCE = {\n  \"+\": 1,\n  \"-\": 1,\n  \"*\": 2,\n  \"/\": 2,\n  \"^\": 3\n};\nclass SummarizeOperation {\n  constructor(leafFn, parameters, options, tokens) {\n    this.leafFn = leafFn;\n    this.parameters = parameters;\n    this.options = options;\n    if (tokens && tokens.length > 0) {\n      this.tokens = tokens.slice();\n    } else if (leafFn) {\n      this.tokens = [{ t: \"operand\", v: this }];\n    } else {\n      this.tokens = [];\n    }\n    this.summarizeFunction = (dc) => {\n      return this.evaluateAsValue(dc);\n    };\n  }\n  // Factory for creating a leaf SummarizeOperation (use in helpers)\n  static leaf(leafFn, parameters, options) {\n    return new SummarizeOperation(leafFn, parameters, options);\n  }\n  // clone with new token stream (immutable-ish)\n  cloneWithTokens(newTokens) {\n    return new SummarizeOperation(void 0, void 0, void 0, newTokens);\n  }\n  // append operator + operand (operand can be number or SummarizeOperation)\n  appendOp(op, operand) {\n    const newTokens = this.tokens.slice();\n    newTokens.push({ t: \"op\", v: op });\n    newTokens.push({ t: \"operand\", v: operand });\n    return this.cloneWithTokens(newTokens);\n  }\n  /**\n   * Append addition to this expression.\n   *\n   * @param x - A numeric literal or another `SummarizeOperation` to add to this expression\n   * @returns A new `SummarizeOperation` representing `(this + x)`\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.summarize({\n   *     result: mean(\"a\").add(10),\n   *   }).observations\n   * );\n   * // [ { result: 13.33333 } ]\n   * ```\n   */\n  add(x) {\n    return this.appendOp(\"+\", x);\n  }\n  /**\n   * Append subtraction to this expression.\n   *\n   * @param x - A numeric literal or another `SummarizeOperation` to subtract from this expression\n   * @returns A new `SummarizeOperation` representing `(this - x)`\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.summarize({\n   *     result: mean(\"a\").sub(10),\n   *   }).observations\n   * );\n   * // [ { result: -6.6667 } ]\n   * ```\n   */\n  sub(x) {\n    return this.appendOp(\"-\", x);\n  }\n  /**\n   * Append multiplication to this expression. Multiplication has higher\n   * precedence than addition/subtraction.\n   *\n   * @param x - A numeric literal or another `SummarizeOperation` to multiply with this expression\n   * @returns A new `SummarizeOperation` representing `(this * x)`\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.summarize({\n   *     result: mean(\"a\").mul(10),\n   *   }).observations\n   * );\n   * // [ { result: 33.3333 } ]\n   * ```\n   */\n  mul(x) {\n    return this.appendOp(\"*\", x);\n  }\n  /**\n   * Append division to this expression.\n   *\n   * @param x - A numeric literal or another `SummarizeOperation` to divide this expression by\n   * @returns A new `SummarizeOperation` representing `(this / x)`\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.summarize({\n   *     result: mean(\"a\").div(10),\n   *   }).observations\n   * );\n   * // [ { result: .3333 } ]\n   * ```\n   */\n  div(x) {\n    return this.appendOp(\"/\", x);\n  }\n  /**\n   * Append exponentiation (power) to this expression.\n   *\n   * Note: exponentiation uses right-associative semantics (a ^ b ^ c -> a ^ (b ^ c)).\n   *\n   * @param x - A numeric literal or another `SummarizeOperation` used as the exponent\n   * @returns A new `SummarizeOperation` representing `(this ^ x)`\n   *\n   * @example\n   * ```js\n   * const d = [\n   *   { a: 1, b: 2, c: 3 },\n   *   { a: 0, b: 8, c: 3 },\n   *   { a: 9, b: 4, c: 7 },\n   * ];\n   * const dc = new DataCalc(d);\n   * console.log(\n   *   dc.summarize({\n   *     result: mean(\"a\").pow(2),\n   *   }).observations\n   * );\n   * // [ { result: 11.1111 } ]\n   * ```\n   */\n  pow(x) {\n    return this.appendOp(\"^\", x);\n  }\n  // Evaluate an operand token to a number (returns NaN for non-numeric)\n  evaluateOperandToNumber(opd, dc) {\n    if (typeof opd === \"number\") return opd;\n    const params = Array.isArray(opd.parameters) ? opd.parameters : opd.parameters === void 0 ? void 0 : [opd.parameters];\n    const raw = opd.leafFn ? opd.leafFn(dc, params, opd.options) : opd.evaluateAsValue(dc);\n    if (raw === null || raw === void 0) return NaN;\n    const num = Number(raw);\n    return typeof num === \"number\" && !isNaN(num) ? num : NaN;\n  }\n  // Evaluate a flat token stream (no nested handling required here; nested SummarizeOperation\n  // operands will evaluate themselves recursively)\n  evaluateFlatTokens(tokens, dc) {\n    const operands = [];\n    const ops = [];\n    for (const tk of tokens) {\n      if (tk.t === \"operand\") operands.push(tk.v);\n      else ops.push(tk.v);\n    }\n    if (operands.length === 0) return NaN;\n    while (ops.length > 0) {\n      let bestIdx = 0;\n      let bestPrec = PRECEDENCE[ops[0]] ?? 0;\n      for (let i = 1; i < ops.length; i++) {\n        const p = PRECEDENCE[ops[i]] ?? 0;\n        if (p > bestPrec || p === bestPrec && ops[i] === \"^\") {\n          bestPrec = p;\n          bestIdx = i;\n        }\n      }\n      const op = ops.splice(bestIdx, 1)[0];\n      const left = operands.splice(bestIdx, 1)[0];\n      const right = operands.splice(bestIdx, 1)[0];\n      const a = this.evaluateOperandToNumber(left, dc);\n      const b = this.evaluateOperandToNumber(right, dc);\n      let res = NaN;\n      if (op === \"+\") res = a + b;\n      else if (op === \"-\") res = a - b;\n      else if (op === \"*\") res = a * b;\n      else if (op === \"/\") res = b === 0 ? NaN : a / b;\n      else if (op === \"^\") res = Math.pow(a, b);\n      operands.splice(bestIdx, 0, res);\n    }\n    const final = operands[0];\n    if (typeof final === \"number\") return final;\n    return this.evaluateOperandToNumber(final, dc);\n  }\n  /**\n   * Instance helper: return a grouped version of this operation so it becomes\n   * a single operand in outer expressions. Equivalent to parens(this).\n   */\n  parens() {\n    return parens(this);\n  }\n  // Top-level evaluation: handles the case where this instance is a leaf (leafFn present)\n  // or an expression token stream.\n  evaluateAsValue(dc) {\n    if (this.leafFn) {\n      const params = Array.isArray(this.parameters) ? this.parameters : this.parameters === void 0 ? void 0 : [this.parameters];\n      const res = this.leafFn(dc, params, this.options);\n      if (typeof res === \"number\" && Number.isNaN(res)) return null;\n      return res;\n    }\n    if (!this.tokens || this.tokens.length === 0) return NaN;\n    const val = this.evaluateFlatTokens(this.tokens, dc);\n    if (typeof val === \"number\" && Number.isNaN(val)) return null;\n    return val;\n  }\n}\nfunction parens(op) {\n  const tokens = [{ t: \"operand\", v: op }];\n  return new SummarizeOperation(void 0, void 0, void 0, tokens);\n}\n\nconst DEFAULT_SUMMARIZE_OPTIONS = {\n  coerceBooleans: true,\n  skipMissing: false\n};\nfunction applyDefaultOptions(options) {\n  return { ...DEFAULT_SUMMARIZE_OPTIONS, ...options };\n}\nfunction processNumericValues(dataCalc, variable, options, collector, errorPrefix, initialState) {\n  const mergedOptions = applyDefaultOptions(options);\n  dataCalc.verifyObservationsContainVariable(variable);\n  let count = 0;\n  let state = initialState;\n  let containsMissing = false;\n  dataCalc.observations.forEach((o) => {\n    if (dataCalc.isNonMissingNumeric(o[variable])) {\n      state = collector(o[variable], state);\n      count++;\n      return;\n    }\n    if (typeof o[variable] === \"boolean\" && mergedOptions.coerceBooleans) {\n      state = collector(o[variable] ? 1 : 0, state);\n      count++;\n      return;\n    }\n    if (dataCalc.isMissingNumeric(o[variable])) {\n      containsMissing = true;\n      return;\n    }\n    throw new M2Error(\n      `${errorPrefix}: variable ${variable} has non-numeric value ${o[variable]} in this observation: ${JSON.stringify(o)}`\n    );\n  });\n  return { state, count, containsMissing };\n}\nfunction processDirectValues(values, options, collector, errorPrefix, initialState) {\n  const mergedOptions = applyDefaultOptions(options);\n  let state = initialState;\n  let count = 0;\n  let containsMissing = false;\n  for (const value of values) {\n    if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n      state = collector(value, state);\n      count++;\n    } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n      state = collector(value ? 1 : 0, state);\n      count++;\n    } else if (value === null || value === void 0 || typeof value === \"number\" && (isNaN(value) || !isFinite(value))) {\n      containsMissing = true;\n    } else {\n      throw new M2Error(`${errorPrefix}: has non-numeric value ${value}`);\n    }\n  }\n  return { state, count, containsMissing };\n}\nfunction processSingleValue(value, options, errorPrefix) {\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n    return { value, isMissing: false };\n  } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n    return { value: value ? 1 : 0, isMissing: false };\n  } else if (value === null || value === void 0 || typeof value === \"number\" && (isNaN(value) || !isFinite(value))) {\n    return { value: 0, isMissing: true };\n  } else {\n    throw new M2Error(`${errorPrefix}: has non-numeric value ${value}`);\n  }\n}\nconst nInternal = (dataCalc) => {\n  return dataCalc.length;\n};\nfunction n() {\n  return SummarizeOperation.leaf(nInternal, [], void 0);\n}\nconst sumInternal = (dataCalc, params, options) => {\n  const variableOrValues = params ? params[0] : void 0;\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum2) => sum2 + value,\n      \"sum()\",\n      0\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, sum2) => sum2 + value,\n      \"sum()\",\n      0\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"sum()\");\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    return result.isMissing ? null : result.value;\n  }\n};\nfunction sum(variableOrValues, options) {\n  return SummarizeOperation.leaf(sumInternal, [variableOrValues], options);\n}\nconst meanInternal = (dataCalc, params, options) => {\n  const variableOrValues = params ? params[0] : void 0;\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum2) => sum2 + value,\n      \"mean()\",\n      0\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state / result.count;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, sum2) => sum2 + value,\n      \"mean()\",\n      0\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state / result.count;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"mean()\");\n    return result.isMissing && !mergedOptions.skipMissing ? null : result.value;\n  }\n};\nfunction mean(variableOrValues, options) {\n  return SummarizeOperation.leaf(meanInternal, [variableOrValues], options);\n}\nconst varianceInternal = (dataCalc, params, options) => {\n  const variableOrValues = params ? params[0] : void 0;\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const meanResult = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum2) => sum2 + value,\n      \"variance()\",\n      0\n    );\n    if (meanResult.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (meanResult.count <= 1) {\n      return null;\n    }\n    const meanValue = meanResult.state / meanResult.count;\n    const varianceResult = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, sum2) => {\n        const actualValue = typeof value === \"boolean\" && mergedOptions.coerceBooleans ? value ? 1 : 0 : value;\n        return sum2 + Math.pow(actualValue - meanValue, 2);\n      },\n      \"variance()\",\n      0\n    );\n    return varianceResult.state / (meanResult.count - 1);\n  } else if (Array.isArray(variableOrValues)) {\n    const validValues = [];\n    let containsMissing = false;\n    for (const value of variableOrValues) {\n      if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n        validValues.push(value);\n      } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n        validValues.push(value ? 1 : 0);\n      } else if (value === null || value === void 0 || typeof value === \"number\" && (isNaN(value) || !isFinite(value))) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(`variance(): has non-numeric value ${value}`);\n      }\n    }\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (validValues.length <= 1) {\n      return null;\n    }\n    const sum2 = validValues.reduce((acc, val) => acc + val, 0);\n    const mean2 = sum2 / validValues.length;\n    const sumSquaredDiffs = validValues.reduce(\n      (acc, val) => acc + Math.pow(val - mean2, 2),\n      0\n    );\n    return sumSquaredDiffs / (validValues.length - 1);\n  } else {\n    return null;\n  }\n};\nfunction variance(variableOrValues, options) {\n  return SummarizeOperation.leaf(varianceInternal, [variableOrValues], options);\n}\nconst minInternal = (dataCalc, params, options) => {\n  const variableOrValues = params ? params[0] : void 0;\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, min2) => min2 === Number.POSITIVE_INFINITY || value < min2 ? value : min2,\n      \"min()\",\n      Number.POSITIVE_INFINITY\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, min2) => min2 === Number.POSITIVE_INFINITY || value < min2 ? value : min2,\n      \"min()\",\n      Number.POSITIVE_INFINITY\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"min()\");\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    return result.isMissing ? null : result.value;\n  }\n};\nfunction min(variableOrValues, options) {\n  return SummarizeOperation.leaf(minInternal, [variableOrValues], options);\n}\nconst maxInternal = (dataCalc, params, options) => {\n  const variableOrValues = params ? params[0] : void 0;\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    const result = processNumericValues(\n      dataCalc,\n      variable,\n      options,\n      (value, max2) => max2 === Number.NEGATIVE_INFINITY || value > max2 ? value : max2,\n      \"max()\",\n      Number.NEGATIVE_INFINITY\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else if (Array.isArray(variableOrValues)) {\n    const result = processDirectValues(\n      variableOrValues,\n      options,\n      (value, max2) => max2 === Number.NEGATIVE_INFINITY || value > max2 ? value : max2,\n      \"max()\",\n      Number.NEGATIVE_INFINITY\n    );\n    if (result.containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (result.count === 0) {\n      return null;\n    }\n    return result.state;\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"max()\");\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    return result.isMissing ? null : result.value;\n  }\n};\nfunction max(variableOrValues, options) {\n  return SummarizeOperation.leaf(maxInternal, [variableOrValues], options);\n}\nconst medianInternal = (dataCalc, params, options) => {\n  const variableOrValues = params ? params[0] : void 0;\n  const mergedOptions = applyDefaultOptions(options);\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const variable = variableOrValues;\n    dataCalc.verifyObservationsContainVariable(variable);\n    const values = [];\n    let containsMissing = false;\n    dataCalc.observations.forEach((o) => {\n      if (dataCalc.isNonMissingNumeric(o[variable])) {\n        values.push(o[variable]);\n      } else if (typeof o[variable] === \"boolean\" && mergedOptions.coerceBooleans) {\n        values.push(o[variable] ? 1 : 0);\n      } else if (dataCalc.isMissingNumeric(o[variable])) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(\n          `median(): variable ${variable} has non-numeric value ${o[variable]} in this observation: ${JSON.stringify(o)}`\n        );\n      }\n    });\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (values.length === 0) {\n      return null;\n    }\n    values.sort((a, b) => a - b);\n    const mid = Math.floor(values.length / 2);\n    if (values.length % 2 === 0) {\n      return (values[mid - 1] + values[mid]) / 2;\n    } else {\n      return values[mid];\n    }\n  } else if (Array.isArray(variableOrValues)) {\n    const values = [];\n    let containsMissing = false;\n    for (const value of variableOrValues) {\n      if (typeof value === \"number\" && !isNaN(value) && isFinite(value)) {\n        values.push(value);\n      } else if (typeof value === \"boolean\" && mergedOptions.coerceBooleans) {\n        values.push(value ? 1 : 0);\n      } else if (value === null || value === void 0 || typeof value === \"number\" && (isNaN(value) || !isFinite(value))) {\n        containsMissing = true;\n      } else {\n        throw new M2Error(`median(): has non-numeric value ${value}`);\n      }\n    }\n    if (containsMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    if (values.length === 0) {\n      return null;\n    }\n    values.sort((a, b) => a - b);\n    const mid = Math.floor(values.length / 2);\n    if (values.length % 2 === 0) {\n      return (values[mid - 1] + values[mid]) / 2;\n    } else {\n      return values[mid];\n    }\n  } else {\n    const result = processSingleValue(variableOrValues, options, \"median()\");\n    if (result.isMissing && !mergedOptions.skipMissing) {\n      return null;\n    }\n    return result.isMissing ? null : result.value;\n  }\n};\nfunction median(variableOrValues, options) {\n  return SummarizeOperation.leaf(medianInternal, [variableOrValues], options);\n}\nconst sdInternal = (dataCalc, params, options) => {\n  const variableOrValues = params ? params[0] : void 0;\n  if (typeof variableOrValues === \"string\") {\n    if (!dataCalc.variableExists(variableOrValues)) {\n      return null;\n    }\n    const varianceValue = varianceInternal(dataCalc, params, options);\n    if (varianceValue === null) {\n      return null;\n    }\n    return Math.sqrt(varianceValue);\n  } else if (Array.isArray(variableOrValues)) {\n    const newParams = params ? [...params] : [variableOrValues];\n    const varianceValue = varianceInternal(dataCalc, newParams, options);\n    if (varianceValue === null) {\n      return null;\n    }\n    return Math.sqrt(varianceValue);\n  } else {\n    return null;\n  }\n};\nfunction sd(variableOrValues, options) {\n  return SummarizeOperation.leaf(sdInternal, [variableOrValues], options);\n}\nconst scalarInternal = (_dataCalc, params, options) => {\n  const v = params ? params[0] : void 0;\n  const result = processSingleValue(v, options, \"scalar()\");\n  return result.isMissing ? null : result.value;\n};\nfunction scalar(value) {\n  return SummarizeOperation.leaf(scalarInternal, [value], void 0);\n}\nconst s = scalar;\n\nconsole.log(\"\\u26AA @m2c2kit/data-calc version 0.8.6 (c86b5047)\");\n\nexport { DataCalc, SummarizeOperation, max, mean, median, min, n, parens, s, scalar, sd, sum, variance };\n//# sourceMappingURL=index.js.map\n","import {\n  Game,\n  Action,\n  Scene,\n  Shape,\n  Label,\n  Transition,\n  TransitionDirection,\n  WebColors,\n  RandomDraws,\n  GameParameters,\n  GameOptions,\n  TrialSchema,\n  Timer,\n  Easings,\n  RgbaColor,\n  Sprite,\n  Constants,\n  Translation,\n  M2Error,\n  ScoringProvider,\n  ActivityKeyValueData,\n  ScoringSchema,\n} from \"@m2c2kit/core\";\nimport {\n  Button,\n  Grid,\n  Instructions,\n  CountdownScene,\n  InstructionsOptions,\n  LocalePicker,\n} from \"@m2c2kit/addons\";\nimport { DataCalc } from \"@m2c2kit/data-calc\";\n\n/**\n * Color Shapes is a visual array change detection task, measuring intra-item\n * feature binding, where participants determine if shapes change color across\n * two sequential presentations of shape stimuli.\n */\nclass ColorShapes extends Game implements ScoringProvider {\n  constructor() {\n    /**\n     * These are configurable game parameters and their defaults.\n     * Each game parameter should have a type, default (this is the default\n     * value), and a description.\n     */\n    const defaultParameters: GameParameters = {\n      fixation_duration_ms: {\n        default: 500,\n        description: \"How long fixation scene is shown, milliseconds.\",\n        type: \"number\",\n      },\n      shape_colors: {\n        type: \"array\",\n        description: \"Array of colors for shapes.\",\n        items: {\n          type: \"object\",\n          properties: {\n            colorName: {\n              type: \"string\",\n              description: \"Human-friendly name of color.\",\n            },\n            rgbaColor: {\n              type: \"array\",\n              description: \"Color as array, [r,g,b,a].\",\n              items: {\n                type: \"number\",\n              },\n            },\n          },\n        },\n        default: [\n          { colorName: \"black\", rgbaColor: [0, 0, 0, 1] },\n          { colorName: \"green\", rgbaColor: [0, 158, 115, 1] },\n          { colorName: \"yellow\", rgbaColor: [240, 228, 66, 1] },\n          { colorName: \"blue\", rgbaColor: [0, 114, 178, 1] },\n          { colorName: \"orange\", rgbaColor: [213, 94, 0, 1] },\n          { colorName: \"pink\", rgbaColor: [204, 121, 167, 1] },\n        ],\n      },\n      number_of_shapes_shown: {\n        default: 3,\n        description: \"How many shapes to show on the grid at one time.\",\n        type: \"integer\",\n      },\n      number_of_shapes_changing_color: {\n        default: 2,\n        description:\n          \"If a different color trial, how many shapes should change color (minimum is 2, because changes are swaps with other shapes).\",\n        type: \"integer\",\n      },\n      shapes_presented_duration_ms: {\n        default: 2000,\n        description: \"How long the shapes are shown, milliseconds.\",\n        type: \"number\",\n      },\n      shapes_removed_duration_ms: {\n        default: 1000,\n        description:\n          \"How long to show a blank square after shapes are removed, milliseconds.\",\n        type: \"number\",\n      },\n      cells_per_side: {\n        default: 3,\n        description:\n          \"How many cell positions for each side of the square grid (e.g., 3 is a 3x3 grid; 4 is a 4x4 grid).\",\n        type: \"integer\",\n      },\n      number_of_different_colors_trials: {\n        default: 6,\n        type: \"integer\",\n        description: \"Number of trials where the shapes have different colors.\",\n      },\n      number_of_trials: {\n        default: 12,\n        description: \"How many trials to run.\",\n        type: \"integer\",\n      },\n      show_trials_complete_scene: {\n        default: true,\n        type: \"boolean\",\n        description:\n          \"After the final trial, should a completion scene be shown? Otherwise, the game will immediately end.\",\n      },\n      instruction_type: {\n        default: \"long\",\n        description: \"Type of instructions to show, 'short' or 'long'.\",\n        type: \"string\",\n        enum: [\"short\", \"long\"],\n      },\n      instructions: {\n        default: null,\n        type: [\"object\", \"null\"],\n        description:\n          \"When non-null, an InstructionsOptions object that will completely override the built-in instructions.\",\n      },\n      show_quit_button: {\n        type: \"boolean\",\n        default: false,\n        description: \"Should the activity quit button be shown?\",\n      },\n      show_fps: {\n        type: \"boolean\",\n        default: false,\n        description: \"Should the FPS be shown?\",\n      },\n      show_locale_picker: {\n        type: \"boolean\",\n        default: false,\n        description:\n          \"Should the icon that allows the participant to switch the locale be shown?\",\n      },\n      seed: {\n        type: [\"string\", \"null\"],\n        default: null,\n        description:\n          \"Optional seed for the seeded pseudo-random number generator. When null, the default Math.random() is used.\",\n      },\n      scoring: {\n        type: \"boolean\",\n        default: false,\n        description: \"Should scoring data be generated? Default is false.\",\n      },\n    };\n\n    /**\n     * This describes all the data that will be generated by the assessment.\n     * At runtime, when a trial completes, the data will be returned to the\n     * session with a callback, along with this schema transformed into\n     * JSON Schema.\n     */\n    const colorShapesTrialSchema: TrialSchema = {\n      activity_begin_iso8601_timestamp: {\n        type: \"string\",\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the beginning of the game activity.\",\n      },\n      trial_begin_iso8601_timestamp: {\n        type: [\"string\", \"null\"],\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the beginning of the trial. Null if trial was skipped.\",\n      },\n      trial_end_iso8601_timestamp: {\n        type: [\"string\", \"null\"],\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the end of the trial (when user presses 'Same' or 'Different'). Null if trial was skipped.\",\n      },\n      trial_index: {\n        type: [\"integer\", \"null\"],\n        description: \"Index of the trial within this assessment, 0-based.\",\n      },\n      present_shapes: {\n        description:\n          \"Configuration of shapes shown to the user in the presentation phase. Null if trial was skipped.\",\n        type: [\"array\", \"null\"],\n        items: {\n          type: \"object\",\n          properties: {\n            shape_index: {\n              type: \"integer\",\n              description:\n                \"Index of the shape within the library of shapes, 0-based\",\n            },\n            color_name: {\n              type: \"string\",\n              description: \"Human-friendly name of color.\",\n            },\n            rgba_color: {\n              type: \"array\",\n              description: \"Color as array, [r,g,b,a].\",\n              items: {\n                type: \"number\",\n              },\n            },\n            location: {\n              type: \"object\",\n              description: \"Location of shape.\",\n              properties: {\n                row: {\n                  type: \"number\",\n                  description: \"Row of the shape, 0-based.\",\n                },\n                column: {\n                  type: \"number\",\n                  description: \"Column of the shape, 0-based.\",\n                },\n              },\n            },\n          },\n        },\n      },\n      response_shapes: {\n        description:\n          \"Configuration of shapes shown to the user in the response phase. Null if trial was skipped.\",\n        type: [\"array\", \"null\"],\n        items: {\n          type: \"object\",\n          properties: {\n            shape_index: {\n              type: \"integer\",\n              description:\n                \"Index of the shape within the library of shapes, 0-based\",\n            },\n            color_name: {\n              type: \"string\",\n              description: \"Human-friendly name of color.\",\n            },\n            rgba_color: {\n              type: \"array\",\n              description: \"Color as array, [r,g,b,a].\",\n              items: {\n                type: \"number\",\n              },\n            },\n            location: {\n              type: \"object\",\n              description: \"Location of shape.\",\n              properties: {\n                row: {\n                  type: \"number\",\n                  description: \"Row of the shape, 0-based.\",\n                },\n                column: {\n                  type: \"number\",\n                  description: \"Column of the shape, 0-based.\",\n                },\n              },\n            },\n          },\n        },\n      },\n      response_time_duration_ms: {\n        type: [\"number\", \"null\"],\n        description:\n          \"Milliseconds from when the response configuration of shapes is shown until the user taps a response. Null if trial was skipped.\",\n      },\n      user_response: {\n        type: [\"string\", \"null\"],\n        enum: [\"same\", \"different\"],\n        description:\n          \"User's response to whether the shapes are same colors or different.\",\n      },\n      user_response_correct: {\n        type: [\"boolean\", \"null\"],\n        description: \"Was the user's response correct?\",\n      },\n      quit_button_pressed: {\n        type: \"boolean\",\n        description: \"Was the quit button pressed?\",\n      },\n    };\n\n    const colorShapesScoringSchema: ScoringSchema = {\n      activity_begin_iso8601_timestamp: {\n        type: \"string\",\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the beginning of the game activity.\",\n      },\n      first_trial_begin_iso8601_timestamp: {\n        type: [\"string\", \"null\"],\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the beginning of the first trial. Null if no trials were completed.\",\n      },\n      last_trial_end_iso8601_timestamp: {\n        type: [\"string\", \"null\"],\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the end of the last trial. Null if no trials were completed.\",\n      },\n      n_trials: {\n        type: \"integer\",\n        description: \"Number of trials completed.\",\n      },\n      flag_trials_match_expected: {\n        type: \"integer\",\n        description:\n          \"Does the number of completed and expected trials match? 1 = true, 0 = false.\",\n      },\n      n_trials_correct: {\n        type: \"integer\",\n        description: \"Number of correct trials.\",\n      },\n      n_trials_incorrect: {\n        type: \"integer\",\n        description: \"Number of incorrect trials.\",\n      },\n      participant_score: {\n        type: [\"number\", \"null\"],\n        description:\n          \"Participant-facing score, calculated as (number of correct trials / number of trials attempted) * 100. This is a simple metric to provide feedback to the participant. Null if no trials attempted.\",\n      },\n    };\n\n    const translation: Translation = {\n      configuration: {\n        baseLocale: \"en-US\",\n      },\n      \"en-US\": {\n        localeName: \"English\",\n        INSTRUCTIONS_TITLE: \"Color Shapes\",\n        SHORT_INSTRUCTIONS_TEXT_PAGE_1:\n          \"Try to remember the color of 3 shapes, because they will soon disappear. When the shapes reappear, answer whether they have the SAME or DIFFERENT colors as they had before\",\n        INSTRUCTIONS_TEXT_PAGE_1:\n          \"Try to remember the color of 3 shapes, because they will soon disappear.\",\n        INSTRUCTIONS_TEXT_PAGE_2: \"Next you will see the same shapes reappear.\",\n        INSTRUCTIONS_TEXT_PAGE_3:\n          \"Answer whether the shapes have the SAME or DIFFERENT colors as they had before.\",\n        START_BUTTON_TEXT: \"START\",\n        NEXT_BUTTON_TEXT: \"Next\",\n        BACK_BUTTON_TEXT: \"Back\",\n        GET_READY_COUNTDOWN_TEXT: \"GET READY!\",\n        SAME_BUTTON_TEXT: \"Same\",\n        DIFFERENT_BUTTON_TEXT: \"Different\",\n        TRIALS_COMPLETE_SCENE_TEXT: \"This activity is complete.\",\n        TRIALS_COMPLETE_SCENE_BUTTON_TEXT: \"OK\",\n      },\n      // cSpell:disable (for VS Code extension, Code Spell Checker)\n      \"es-MX\": {\n        localeName: \"Espaol\",\n        INSTRUCTIONS_TITLE: \"Formas de Color\",\n        // Short instructions need to be translated.\n        // SHORT_INSTRUCTIONS_TEXT_PAGE_1: \"\",\n        INSTRUCTIONS_TEXT_PAGE_1:\n          \"Intenta recordar el color de las 3 formas, porque pronto desaparecern.\",\n        INSTRUCTIONS_TEXT_PAGE_2: \"Luego vers reaparecer las mismas formas.\",\n        INSTRUCTIONS_TEXT_PAGE_3:\n          \"Responde si las formas tienen el MISMO o DIFERENTE color que antes.\",\n        START_BUTTON_TEXT: \"COMENZAR\",\n        NEXT_BUTTON_TEXT: \"Siguiente\",\n        BACK_BUTTON_TEXT: \"Atrs\",\n        GET_READY_COUNTDOWN_TEXT: \"PREPRESE\",\n        SAME_BUTTON_TEXT: \"Mismo\",\n        DIFFERENT_BUTTON_TEXT: \"Diferente\",\n        TRIALS_COMPLETE_SCENE_TEXT: \"Esta actividad est completa.\",\n        TRIALS_COMPLETE_SCENE_BUTTON_TEXT: \"OK\",\n      },\n      \"de-DE\": {\n        localeName: \"Deutsch\",\n        INSTRUCTIONS_TITLE: \"Farb-Formen\",\n        // Short instructions need to be translated.\n        // SHORT_INSTRUCTIONS_TEXT_PAGE_1: \"\",\n        INSTRUCTIONS_TEXT_PAGE_1: \"Oben und unten sehen Sie Symbolpaare.\",\n        INSTRUCTIONS_TEXT_PAGE_2:\n          \"Ihre Aufgabe wird es sein, auf dasjenige untere Paar zu tippen, welches mit einem der obigen Paare exakt bereinstimmt.\",\n        INSTRUCTIONS_TEXT_PAGE_3:\n          \"Versuchen Sie bitte, so schnell und korrekt wie mglich zu sein.\",\n        START_BUTTON_TEXT: \"START\",\n        NEXT_BUTTON_TEXT: \"Weiter\",\n        BACK_BUTTON_TEXT: \"Vorherige\",\n        GET_READY_COUNTDOWN_TEXT: \"BEREIT MACHEN\",\n        SAME_BUTTON_TEXT: \"Gleich\",\n        DIFFERENT_BUTTON_TEXT: \"Unterschiedlich\",\n        TRIALS_COMPLETE_SCENE_TEXT: \"Die Aufgabe ist beendet.\",\n        TRIALS_COMPLETE_SCENE_BUTTON_TEXT: \"OK\",\n      },\n      // cSpell:enable\n    };\n\n    const options: GameOptions = {\n      name: \"Color Shapes\",\n      /**\n       * This id must match the property m2c2kit.assessmentId in package.json\n       */\n      id: \"color-shapes\",\n      publishUuid: \"394cb010-2ccf-4a87-9d23-cda7fb07a960\",\n      version: \"__PACKAGE_JSON_VERSION__\",\n      moduleMetadata: Constants.MODULE_METADATA_PLACEHOLDER,\n      translation: translation,\n      shortDescription:\n        \"Color Shapes is a visual array change detection \\\ntask, measuring intra-item feature binding, where participants determine \\\nif shapes change color across two sequential presentations of shape \\\nstimuli.\",\n      longDescription: `Color Shapes is a change detection paradigm used \\\nto measure visual short-term memory binding (Parra et al., 2009). \\\nParticipants are asked to memorize the shapes and colors of three different \\\npolygons for 3 seconds. The three polygons are then removed from the screen \\\nand re-displayed at different locations, either having the same or different \\\ncolors. Participants are then asked to decide whether the combination of \\\ncolors and shapes are the \"Same\" or \"Different\" between the study and test \\\nphases.`,\n      showFps: defaultParameters.show_fps.default,\n      width: 400,\n      height: 800,\n      trialSchema: colorShapesTrialSchema,\n      scoringSchema: colorShapesScoringSchema,\n      parameters: defaultParameters,\n      fonts: [\n        {\n          fontName: \"roboto\",\n          url: \"fonts/roboto/Roboto-Regular.ttf\",\n        },\n      ],\n      images: [\n        {\n          imageName: \"instructions-1\",\n          height: 256,\n          width: 256,\n          url: \"images/cs-instructions-1.png\",\n        },\n        {\n          imageName: \"instructions-2\",\n          height: 256,\n          width: 256,\n          url: \"images/cs-instructions-2.png\",\n        },\n        {\n          imageName: \"instructions-3\",\n          height: 350,\n          width: 300,\n          url: \"images/cs-instructions-3.png\",\n          localize: true,\n        },\n        {\n          imageName: \"circle-x\",\n          height: 32,\n          width: 32,\n          // the svg is from evericons and is licensed under CC0 1.0\n          // Universal (Public Domain). see https://www.patreon.com/evericons\n          url: \"images/circle-x.svg\",\n        },\n      ],\n    };\n\n    super(options);\n  }\n\n  override async initialize() {\n    await super.initialize();\n    // just for convenience, alias the variable game to \"this\"\n    // (even though eslint doesn't like it)\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const game = this;\n\n    const seed = game.getParameter<string | null>(\"seed\");\n    if (typeof seed === \"string\") {\n      RandomDraws.setSeed(seed);\n    }\n\n    const SHAPE_SVG_HEIGHT = 96;\n    const SQUARE_SIDE_LENGTH = 350;\n    const numberOfShapesShown = game.getParameter<number>(\n      \"number_of_shapes_shown\",\n    );\n    const shapeLibrary = this.makeShapes(SHAPE_SVG_HEIGHT);\n\n    // ==============================================================\n\n    if (game.getParameter<boolean>(\"show_quit_button\")) {\n      const quitSprite = new Sprite({\n        imageName: \"circle-x\",\n        position: { x: 380, y: 20 },\n        isUserInteractionEnabled: true,\n      });\n      game.addFreeNode(quitSprite);\n      quitSprite.onTapDown((e) => {\n        game.removeAllFreeNodes();\n        e.handled = true;\n        const blankScene = new Scene();\n        game.addScene(blankScene);\n        game.presentScene(blankScene);\n        game.addTrialData(\"quit_button_pressed\", true);\n        game.trialComplete();\n        if (game.getParameter<boolean>(\"scoring\")) {\n          // Score the data only if user does not quit. If user quits, pass\n          // empty data to calculateScores so a \"blank\" set of scores is\n          // generated.\n          const scores = game.calculateScores([], {\n            numberOfTrials: game.getParameter<number>(\"number_of_trials\"),\n          });\n          game.addScoringData(scores);\n          game.scoringComplete();\n        }\n        game.cancel();\n      });\n    }\n\n    let localePicker: LocalePicker;\n    if (game.getParameter<boolean>(\"show_locale_picker\")) {\n      localePicker = new LocalePicker();\n      game.addFreeNode(localePicker);\n    }\n\n    // ==============================================================\n    // SCENES: instructions\n    let instructionsScenes: Array<Scene>;\n\n    const customInstructions = game.getParameter<InstructionsOptions | null>(\n      \"instructions\",\n    );\n    if (customInstructions) {\n      instructionsScenes = Instructions.create(customInstructions);\n    } else {\n      switch (game.getParameter(\"instruction_type\")) {\n        case \"short\": {\n          instructionsScenes = Instructions.create({\n            instructionScenes: [\n              {\n                title: \"INSTRUCTIONS_TITLE\",\n                text: \"SHORT_INSTRUCTIONS_TEXT_PAGE_1\",\n                imageName: \"instructions-1\",\n                imageAboveText: false,\n                imageMarginTop: 32,\n                textFontSize: 24,\n                titleFontSize: 30,\n                textVerticalBias: 0.2,\n                nextButtonText: \"START_BUTTON_TEXT\",\n                nextButtonBackgroundColor: WebColors.Green,\n                nextSceneTransition: Transition.none(),\n              },\n            ],\n          });\n          break;\n        }\n        case \"long\": {\n          instructionsScenes = Instructions.create({\n            instructionScenes: [\n              {\n                title: \"INSTRUCTIONS_TITLE\",\n                text: \"INSTRUCTIONS_TEXT_PAGE_1\",\n                imageName: \"instructions-1\",\n                imageAboveText: false,\n                imageMarginTop: 32,\n                textFontSize: 24,\n                titleFontSize: 30,\n                textVerticalBias: 0.2,\n                nextButtonText: \"NEXT_BUTTON_TEXT\",\n                backButtonText: \"BACK_BUTTON_TEXT\",\n              },\n              {\n                title: \"INSTRUCTIONS_TITLE\",\n                text: \"INSTRUCTIONS_TEXT_PAGE_2\",\n                imageName: \"instructions-2\",\n                imageAboveText: false,\n                imageMarginTop: 32,\n                textFontSize: 24,\n                titleFontSize: 30,\n                textVerticalBias: 0.2,\n                nextButtonText: \"NEXT_BUTTON_TEXT\",\n                backButtonText: \"BACK_BUTTON_TEXT\",\n              },\n              {\n                title: \"INSTRUCTIONS_TITLE\",\n                text: \"INSTRUCTIONS_TEXT_PAGE_3\",\n                imageName: \"instructions-3\",\n                imageAboveText: false,\n                imageMarginTop: 32,\n                textFontSize: 24,\n                titleFontSize: 30,\n                textVerticalBias: 0.2,\n                nextButtonText: \"START_BUTTON_TEXT\",\n                nextButtonBackgroundColor: WebColors.Green,\n                backButtonText: \"BACK_BUTTON_TEXT\",\n              },\n            ],\n          });\n          break;\n        }\n        default: {\n          throw new M2Error(\"invalid value for instruction_type\");\n        }\n      }\n    }\n    instructionsScenes[0].onAppear(() => {\n      // in case user quits before starting a trial, record the\n      // timestamp\n      game.addTrialData(\n        \"activity_begin_iso8601_timestamp\",\n        this.beginIso8601Timestamp,\n      );\n    });\n    game.addScenes(instructionsScenes);\n\n    // ==============================================================\n    // SCENE: countdown. Show 3 second countdown.\n    const countdownScene = new CountdownScene({\n      milliseconds: 3000,\n      text: \"GET_READY_COUNTDOWN_TEXT\",\n      zeroDwellMilliseconds: 1000,\n      transition: Transition.none(),\n    });\n    game.addScene(countdownScene);\n\n    const gridRows = game.getParameter<number>(\"cells_per_side\");\n    const gridColumns = game.getParameter<number>(\"cells_per_side\");\n    const numberOfTrials = game.getParameter<number>(\"number_of_trials\");\n    const shapeColors =\n      game.getParameter<Array<{ colorName: string; rgbaColor: RgbaColor }>>(\n        \"shape_colors\",\n      );\n\n    interface DisplayShape {\n      shape: Shape;\n      shapeIndex: number;\n      color: RgbaColor;\n      colorName: string;\n      location: {\n        row: number;\n        column: number;\n      };\n    }\n\n    interface TrialConfiguration {\n      presentShapes: Array<DisplayShape>;\n      responseShapes: Array<DisplayShape>;\n      numberOfShapesWithDifferentColors: number;\n    }\n\n    const trialConfigurations: Array<TrialConfiguration> = [];\n    const rows = game.getParameter<number>(\"cells_per_side\");\n    const columns = rows;\n    const numberOfDifferentColorsTrials = game.getParameter<number>(\n      \"number_of_different_colors_trials\",\n    );\n    const differentColorsTrialIndexes = RandomDraws.fromRangeWithoutReplacement(\n      numberOfDifferentColorsTrials,\n      0,\n      numberOfTrials - 1,\n    );\n\n    for (let i = 0; i < numberOfTrials; i++) {\n      const presentShapes = new Array<DisplayShape>();\n      const responseShapes = new Array<DisplayShape>();\n      const shapesToShowIndexes = RandomDraws.fromRangeWithoutReplacement(\n        numberOfShapesShown,\n        0,\n        shapeLibrary.length - 1,\n      );\n      const shapeColorsIndexes = RandomDraws.fromRangeWithoutReplacement(\n        numberOfShapesShown,\n        0,\n        shapeColors.length - 1,\n      );\n\n      // do not allow shapes to be in the same row or column\n      // or along the diagonal\n      const onDiagonal = (\n        locations: {\n          row: number;\n          column: number;\n        }[],\n      ): boolean => {\n        if (\n          locations\n            .map((c) => c.row === 0 && c.column === 0)\n            .some((e) => e === true) &&\n          locations\n            .map((c) => c.row === 1 && c.column === 1)\n            .some((e) => e === true) &&\n          locations\n            .map((c) => c.row === 2 && c.column === 2)\n            .some((e) => e === true)\n        ) {\n          return true;\n        }\n        if (\n          locations\n            .map((c) => c.row === 2 && c.column === 0)\n            .some((e) => e === true) &&\n          locations\n            .map((c) => c.row === 1 && c.column === 1)\n            .some((e) => e === true) &&\n          locations\n            .map((c) => c.row === 0 && c.column === 2)\n            .some((e) => e === true)\n        ) {\n          return true;\n        }\n        return false;\n      };\n\n      const inLine = (\n        locations: {\n          row: number;\n          column: number;\n        }[],\n      ): boolean => {\n        const uniqueRows = new Set(locations.map((l) => l.row)).size;\n        const uniqueColumns = new Set(locations.map((l) => l.column)).size;\n\n        if (uniqueRows !== 1 && uniqueColumns !== 1) {\n          return false;\n        }\n        return true;\n      };\n\n      // assign present shapes' locations and colors\n      let presentLocationsOk = false;\n      let presentLocations: {\n        row: number;\n        column: number;\n      }[];\n      do {\n        presentLocations = RandomDraws.fromGridWithoutReplacement(\n          numberOfShapesShown,\n          rows,\n          columns,\n        );\n\n        if (!inLine(presentLocations) && !onDiagonal(presentLocations)) {\n          presentLocationsOk = true;\n        } else {\n          presentLocationsOk = false;\n        }\n      } while (!presentLocationsOk);\n      for (let j = 0; j < numberOfShapesShown; j++) {\n        const presentShape: DisplayShape = {\n          shape: shapeLibrary[shapesToShowIndexes[j]],\n          shapeIndex: shapesToShowIndexes[j],\n          color: shapeColors[shapeColorsIndexes[j]].rgbaColor,\n          colorName: shapeColors[shapeColorsIndexes[j]].colorName,\n          location: presentLocations[j],\n        };\n        presentShapes.push(presentShape);\n      }\n\n      // assign response shapes' locations\n      let responseLocationsOk = false;\n      let responseLocations: {\n        row: number;\n        column: number;\n      }[];\n      do {\n        responseLocations = RandomDraws.fromGridWithoutReplacement(\n          numberOfShapesShown,\n          rows,\n          columns,\n        );\n\n        if (!inLine(responseLocations) && !onDiagonal(responseLocations)) {\n          responseLocationsOk = true;\n        } else {\n          responseLocationsOk = false;\n        }\n      } while (!responseLocationsOk);\n      for (let j = 0; j < numberOfShapesShown; j++) {\n        const responseShape: DisplayShape = {\n          shape: presentShapes[j].shape,\n          shapeIndex: shapesToShowIndexes[j],\n          color: presentShapes[j].color,\n          colorName: shapeColors[shapeColorsIndexes[j]].colorName,\n          location: responseLocations[j],\n        };\n        responseShapes.push(responseShape);\n      }\n\n      let numberOfShapesWithDifferentColors = 0;\n      const differentColorTrial = differentColorsTrialIndexes.includes(i);\n\n      if (differentColorTrial) {\n        const numberOfShapesToChange = game.getParameter<number>(\n          \"number_of_shapes_changing_color\",\n        );\n        if (numberOfShapesToChange > numberOfShapesShown) {\n          throw new M2Error(\n            `number_of_shapes_changing_color is ${numberOfShapesToChange}, but it must be less than or equal to number_of_shapes_shown (which is ${numberOfShapesShown}).`,\n          );\n        }\n        const shapesToChangeIndexes = RandomDraws.fromRangeWithoutReplacement(\n          numberOfShapesToChange,\n          0,\n          numberOfShapesShown - 1,\n        );\n        const shapesToChange = shapesToChangeIndexes.map(\n          (index) => responseShapes[index],\n        );\n        numberOfShapesWithDifferentColors = shapesToChange.length;\n\n        /**\n         * rotate each shape's color to the next one. The last shape\n         * gets the first shape's color\n         */\n        const firstShapeColor = shapesToChange[0].color;\n        for (let j = 0; j < numberOfShapesToChange; j++) {\n          const shape = shapesToChange[j];\n          if (j + 1 < numberOfShapesToChange) {\n            shape.color = shapesToChange[j + 1].color;\n          } else {\n            shape.color = firstShapeColor;\n          }\n        }\n      }\n\n      trialConfigurations.push({\n        presentShapes: presentShapes,\n        responseShapes: responseShapes,\n        numberOfShapesWithDifferentColors: numberOfShapesWithDifferentColors,\n      });\n    }\n\n    // ==============================================================\n    // SCENE: fixation. Show get ready message, then advance after XXXX\n    // milliseconds (as defined in fixation_duration_ms parameter)\n    const fixationScene = new Scene();\n    game.addScene(fixationScene);\n\n    const fixationSceneSquare = new Shape({\n      rect: { size: { width: SQUARE_SIDE_LENGTH, height: SQUARE_SIDE_LENGTH } },\n      fillColor: WebColors.Transparent,\n      strokeColor: WebColors.Gray,\n      lineWidth: 4,\n      position: { x: 200, y: 300 },\n    });\n    fixationScene.addChild(fixationSceneSquare);\n\n    const plusLabel = new Label({\n      text: \"+\",\n      fontSize: 32,\n      fontColor: WebColors.Black,\n      localize: false,\n    });\n    fixationSceneSquare.addChild(plusLabel);\n\n    fixationScene.onAppear(() => {\n      game.addTrialData(\n        \"activity_begin_iso8601_timestamp\",\n        this.beginIso8601Timestamp,\n      );\n      game.addTrialData(\n        \"trial_begin_iso8601_timestamp\",\n        new Date().toISOString(),\n      );\n      fixationScene.run(\n        Action.sequence([\n          Action.wait({ duration: game.getParameter(\"fixation_duration_ms\") }),\n          Action.custom({\n            callback: () => {\n              game.presentScene(shapePresentationScene);\n            },\n          }),\n        ]),\n      );\n    });\n\n    // ==============================================================\n    // SCENE: Shape Presentation.\n    const shapePresentationScene = new Scene();\n    game.addScene(shapePresentationScene);\n\n    const presentationSceneSquare = new Shape({\n      rect: { size: { width: SQUARE_SIDE_LENGTH, height: SQUARE_SIDE_LENGTH } },\n      fillColor: WebColors.Transparent,\n      strokeColor: WebColors.Gray,\n      lineWidth: 4,\n      position: { x: 200, y: 300 },\n    });\n    shapePresentationScene.addChild(presentationSceneSquare);\n\n    const presentationGrid = new Grid({\n      rows: gridRows,\n      columns: gridColumns,\n      size: { width: SQUARE_SIDE_LENGTH, height: SQUARE_SIDE_LENGTH },\n      position: { x: 200, y: 300 },\n      backgroundColor: WebColors.Transparent,\n      gridLineColor: WebColors.Transparent,\n    });\n    shapePresentationScene.addChild(presentationGrid);\n\n    shapePresentationScene.onAppear(() => {\n      const trialConfiguration = trialConfigurations[game.trialIndex];\n      for (let i = 0; i < trialConfiguration.presentShapes.length; i++) {\n        const presentShape = trialConfiguration.presentShapes[i].shape;\n        presentShape.fillColor = trialConfiguration.presentShapes[i].color;\n        /**\n         * Because we are repositioning children of a grid, we need to\n         * set its position back to zero, because in the grid, it recalculates\n         * the position. If we don't do this, the shapes will be positioned\n         * incorrectly if they are positioned a second time.\n         */\n        presentShape.position = { x: 0, y: 0 };\n        presentationGrid.addAtCell(\n          presentShape,\n          trialConfiguration.presentShapes[i].location.row,\n          trialConfiguration.presentShapes[i].location.column,\n        );\n      }\n      shapePresentationScene.run(\n        Action.sequence([\n          Action.wait({\n            duration: game.getParameter(\"shapes_presented_duration_ms\"),\n          }),\n          Action.custom({\n            callback: () => {\n              presentationGrid.removeAllGridChildren();\n            },\n          }),\n          Action.wait({\n            duration: game.getParameter(\"shapes_removed_duration_ms\"),\n          }),\n          Action.custom({\n            callback: () => {\n              presentationGrid.removeAllGridChildren();\n              game.presentScene(shapeResponseScene);\n            },\n          }),\n        ]),\n      );\n    });\n\n    // ==============================================================\n    // SCENE: Shape Response.\n    const shapeResponseScene = new Scene();\n    game.addScene(shapeResponseScene);\n\n    const responseSceneSquare = new Shape({\n      rect: { size: { width: SQUARE_SIDE_LENGTH, height: SQUARE_SIDE_LENGTH } },\n      fillColor: WebColors.Transparent,\n      strokeColor: WebColors.Gray,\n      lineWidth: 4,\n      position: { x: 200, y: 300 },\n    });\n    shapeResponseScene.addChild(responseSceneSquare);\n\n    const responseGrid = new Grid({\n      rows: gridRows,\n      columns: gridColumns,\n      size: { width: SQUARE_SIDE_LENGTH, height: SQUARE_SIDE_LENGTH },\n      position: { x: 200, y: 300 },\n      backgroundColor: WebColors.Transparent,\n      gridLineColor: WebColors.Transparent,\n    });\n    shapeResponseScene.addChild(responseGrid);\n\n    shapeResponseScene.onAppear(() => {\n      const trialConfiguration = trialConfigurations[game.trialIndex];\n      for (let i = 0; i < trialConfiguration.responseShapes.length; i++) {\n        const responseShape = trialConfiguration.responseShapes[i].shape;\n        responseShape.fillColor = trialConfiguration.responseShapes[i].color;\n        /**\n         * Because we are repositioning children of a grid, we need to\n         * set its position back to zero, because in the grid, it recalculates\n         * the position. If we don't do this, the shapes will be positioned\n         * incorrectly if they are positioned a second time.\n         */\n        responseShape.position = { x: 0, y: 0 };\n        responseGrid.addAtCell(\n          responseShape,\n          trialConfiguration.responseShapes[i].location.row,\n          trialConfiguration.responseShapes[i].location.column,\n        );\n      }\n      sameButton.isUserInteractionEnabled = true;\n      differentButton.isUserInteractionEnabled = true;\n      Timer.startNew(\"rt\");\n    });\n\n    const sameButton = new Button({\n      text: \"SAME_BUTTON_TEXT\",\n      position: { x: 100, y: 700 },\n      size: { width: 150, height: 50 },\n    });\n    shapeResponseScene.addChild(sameButton);\n    sameButton.onTapDown(() => {\n      sameButton.isUserInteractionEnabled = false;\n      handleSelection(false);\n    });\n\n    const differentButton = new Button({\n      text: \"DIFFERENT_BUTTON_TEXT\",\n      position: { x: 300, y: 700 },\n      size: { width: 150, height: 50 },\n    });\n    shapeResponseScene.addChild(differentButton);\n    differentButton.onTapDown(() => {\n      differentButton.isUserInteractionEnabled = false;\n      handleSelection(true);\n    });\n\n    const handleSelection = (differentPressed: boolean) => {\n      const rt = Timer.elapsed(\"rt\");\n      Timer.remove(\"rt\");\n      responseGrid.removeAllGridChildren();\n\n      game.addTrialData(\n        \"trial_end_iso8601_timestamp\",\n        new Date().toISOString(),\n      );\n      const trialConfiguration = trialConfigurations[game.trialIndex];\n      game.addTrialData(\"response_time_duration_ms\", rt);\n      game.addTrialData(\n        \"user_response\",\n        differentPressed ? \"different\" : \"same\",\n      );\n      const correctResponse =\n        (trialConfiguration.numberOfShapesWithDifferentColors === 0 &&\n          !differentPressed) ||\n        (trialConfiguration.numberOfShapesWithDifferentColors > 0 &&\n          differentPressed);\n      game.addTrialData(\"user_response_correct\", correctResponse);\n\n      const presentShapes = trialConfiguration.presentShapes.map((p) => {\n        return {\n          shape_index: p.shapeIndex,\n          color_name: p.colorName,\n          rgba_color: p.color,\n          location: p.location,\n        };\n      });\n      game.addTrialData(\"present_shapes\", presentShapes);\n      game.addTrialData(\"quit_button_pressed\", false);\n\n      const responseShapes = trialConfiguration.responseShapes.map((p) => {\n        return {\n          shape_index: p.shapeIndex,\n          color_name: p.colorName,\n          rgba_color: p.color,\n          location: p.location,\n        };\n      });\n      game.addTrialData(\"response_shapes\", responseShapes);\n      game.addTrialData(\"trial_index\", game.trialIndex);\n\n      game.trialComplete();\n      if (game.trialIndex < numberOfTrials) {\n        game.presentScene(fixationScene);\n      } else {\n        if (game.getParameter<boolean>(\"scoring\")) {\n          const scores = game.calculateScores(game.data.trials, {\n            numberOfTrials: game.getParameter<number>(\"number_of_trials\"),\n          });\n          game.addScoringData(scores);\n          game.scoringComplete();\n        }\n\n        if (game.getParameter(\"show_trials_complete_scene\")) {\n          game.presentScene(\n            doneScene,\n            Transition.slide({\n              direction: TransitionDirection.Left,\n              duration: 500,\n              easing: Easings.sinusoidalInOut,\n            }),\n          );\n        } else {\n          game.end();\n        }\n      }\n    };\n\n    // ==============================================================\n    // SCENE: done. Show done message, with a button to exit.\n    const doneScene = new Scene();\n    game.addScene(doneScene);\n\n    const doneSceneText = new Label({\n      text: \"TRIALS_COMPLETE_SCENE_TEXT\",\n      position: { x: 200, y: 400 },\n    });\n    doneScene.addChild(doneSceneText);\n\n    const okButton = new Button({\n      text: \"TRIALS_COMPLETE_SCENE_BUTTON_TEXT\",\n      position: { x: 200, y: 650 },\n    });\n    okButton.isUserInteractionEnabled = true;\n    okButton.onTapDown(() => {\n      // don't allow repeat taps of ok button\n      okButton.isUserInteractionEnabled = false;\n      doneScene.removeAllChildren();\n      game.end();\n    });\n    doneScene.addChild(okButton);\n    doneScene.onSetup(() => {\n      // no need to have cancel button, because we're done\n      game.removeAllFreeNodes();\n    });\n  }\n\n  calculateScores(\n    data: ActivityKeyValueData[],\n    extras: {\n      numberOfTrials: number;\n    },\n  ) {\n    const dc = new DataCalc(data);\n    const scores = dc\n      .summarize({\n        activity_begin_iso8601_timestamp: this.beginIso8601Timestamp,\n        first_trial_begin_iso8601_timestamp: dc\n          .arrange(\"trial_begin_iso8601_timestamp\")\n          .slice(0)\n          .pull(\"trial_begin_iso8601_timestamp\"),\n        last_trial_end_iso8601_timestamp: dc\n          .arrange(\"-trial_end_iso8601_timestamp\")\n          .slice(0)\n          .pull(\"trial_end_iso8601_timestamp\"),\n        n_trials: dc.length,\n        flag_trials_match_expected: dc.length === extras.numberOfTrials ? 1 : 0,\n        n_trials_correct: dc.filter((obs) => obs.user_response_correct === true)\n          .length,\n        n_trials_incorrect: dc.filter(\n          (obs) => obs.user_response_correct === false,\n        ).length,\n      })\n      .mutate({\n        participant_score: (obs) =>\n          obs.n_trials > 0 ? (obs.n_trials_correct / obs.n_trials) * 100 : null,\n      });\n    return scores.observations;\n  }\n\n  private makeShapes(svgHeight: number) {\n    const shape01 = new Shape({\n      path: {\n        pathString: shapePathStrings[0],\n        height: svgHeight,\n      },\n      lineWidth: 0,\n    });\n\n    const shape02 = new Shape({\n      path: {\n        pathString: shapePathStrings[1],\n        height: svgHeight,\n      },\n      lineWidth: 0,\n    });\n\n    // note: shape03 is purposively smaller (.8 height of other shapes)\n    const shape03 = new Shape({\n      path: {\n        pathString: shapePathStrings[2],\n        height: svgHeight * 0.8,\n      },\n      lineWidth: 0,\n    });\n\n    const shape04 = new Shape({\n      path: {\n        pathString: shapePathStrings[3],\n        height: svgHeight,\n      },\n      lineWidth: 0,\n    });\n\n    // note: shape05 is purposively smaller (.8 height of other shapes)\n    const shape05 = new Shape({\n      path: {\n        pathString: shapePathStrings[4],\n        height: svgHeight * 0.8,\n      },\n      lineWidth: 0,\n    });\n\n    const shape06 = new Shape({\n      path: {\n        pathString: shapePathStrings[5],\n        height: svgHeight,\n      },\n      lineWidth: 0,\n    });\n\n    const shape07 = new Shape({\n      path: {\n        pathString: shapePathStrings[6],\n        height: svgHeight,\n      },\n      lineWidth: 0,\n    });\n\n    const shape08 = new Shape({\n      path: {\n        pathString: shapePathStrings[7],\n        height: svgHeight,\n      },\n      lineWidth: 0,\n    });\n\n    const shapes = [\n      shape01,\n      shape02,\n      shape03,\n      shape04,\n      shape05,\n      shape06,\n      shape07,\n      shape08,\n    ];\n    return shapes;\n  }\n}\n\nconst shapePathStrings = [\n  \"M0 89.94v-2L131.95 0h2v88.7c2.34 1.6 4.47 3.11 6.65 4.55 42.77 28.22 85.54 56.42 128.3 84.63v2c-44.65 29.65-89.3 59.29-133.95 88.94h-1v-90.84C89.44 148.72 44.72 119.33 0 89.94Z\",\n  \"M162 188c-.33 27-.67 54-1 81-26.87-26.18-53.74-52.35-80-77.94V269H0C0 180.83 0 92.67.04 4.5.04 3 .67 1.5 1 0c24.64 29.1 49.15 58.31 73.96 87.26 28.88 33.7 58.01 67.17 87.04 100.74Z\",\n  \"M3 148.86V61.12C41.76 40.75 80.52 20.37 119.28 0h2.91c21.32 20.7 42.64 41.4 63.96 62.11v89.71c-38.44 20.04-76.88 40.09-115.31 60.13h-2.91L3.01 148.86Z\",\n  \"M134 0h2c7.26 22.31 14.38 44.67 21.86 66.9 3.91 11.61 5.47 29.91 13.25 33.27C203 113.94 236.86 123.13 270 134v1L136 269h-1c-11.04-33.58-22.08-67.16-33.21-101.03C67.87 156.98 33.93 145.99 0 135v-1L134 0Z\",\n  \"M107 0h1l108 108v1c-26.67 35.33-53.33 70.66-80 106h-1c-8.82-35.03-17.64-70.07-27-107.28C98.62 145.01 89.81 180 81.01 215h-1C53.33 179.66 26.67 144.33 0 109v-2L107 0Z\",\n  \"M0 1C2.17.67 4.33.05 6.5.04 58.33-.01 110.17 0 162 0v270H2c26.2-22.17 52.41-44.33 78.86-66.71V67.4c-3.85-3.22-7.35-6.2-10.9-9.11C46.64 39.18 23.32 20.09 0 1Z\",\n  \"M95 268.99h-1C62.66 238.66 31.33 208.33 0 178V88C26.67 58.67 53.33 29.33 80 0h1c0 29.45 0 58.89-.01 88.38 35.99 29.57 72 59.09 108.01 88.61v1l-94 91Z\",\n  \"M13 0h67l135 135v1L81 270c-27-.33-54-.67-81-1 11.73-12.51 23.61-24.87 35.16-37.54 33.14-36.35 66.14-72.82 100.23-110.38C94.4 80.52 53.7 40.26 13 0Z\",\n];\n\nexport { ColorShapes };\n"],"names":["M2Error"],"mappings":"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"}