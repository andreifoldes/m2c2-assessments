{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  Game,\n  Action,\n  Scene,\n  Shape,\n  Label,\n  Transition,\n  TransitionDirection,\n  WebColors,\n  RandomDraws,\n  LabelHorizontalAlignmentMode,\n  GameParameters,\n  GameOptions,\n  TrialSchema,\n  Timer,\n  Easings,\n  Sprite,\n  Constants,\n  Translation,\n} from \"@m2c2kit/core\";\nimport {\n  Button,\n  CountdownScene,\n  Grid,\n  Instructions,\n  InstructionsOptions,\n  LocalePicker,\n} from \"@m2c2kit/addons\";\n\n/**\n * Grid Memory is a visuospatial working memory task, with delayed free\n * recall. After a brief exposure, and a short distraction phase,\n * participants report the location of dots on a grid.\n */\nclass GridMemory extends Game {\n  constructor() {\n    /**\n     * These are configurable game parameters and their defaults.\n     * Each game parameter should have a type, default (this is the default\n     * value), and a description.\n     */\n    const defaultParameters: GameParameters = {\n      number_of_dots: {\n        type: \"integer\",\n        default: 3,\n        description: \"Number of dots to present.\",\n      },\n      preparation_duration_ms: {\n        type: \"number\",\n        default: 500,\n        description:\n          \"How long the 'get ready' message before each trial is shown, milliseconds.\",\n      },\n      blank_grid_duration_ms: {\n        type: \"number\",\n        default: 500,\n        description:\n          \"How long a blank grid is shown before the dots appear, milliseconds.\",\n      },\n      interference_duration_ms: {\n        type: \"number\",\n        default: 8000,\n        description:\n          \"How long the grid of interference targets is shown, milliseconds.\",\n      },\n      interference_transition_animation: {\n        type: \"boolean\",\n        default: true,\n        description:\n          \"Should the transitions between dot presentation, interference, and recall be animated slide transitions?\",\n      },\n      dot_present_duration_ms: {\n        type: \"number\",\n        default: 3000,\n        description: \"How long the dots are shown, milliseconds.\",\n      },\n      number_of_interference_targets: {\n        type: \"integer\",\n        default: 5,\n        description: \"How many targets to show in the interference phase.\",\n      },\n      number_of_trials: {\n        type: \"integer\",\n        default: 4,\n        description: \"How many trials to run.\",\n      },\n      show_trials_complete_scene: {\n        default: true,\n        type: \"boolean\",\n        description:\n          \"After the final trial, should a completion scene be shown? Otherwise, the game will immediately end.\",\n      },\n      instruction_type: {\n        type: \"string\",\n        default: \"long\",\n        description: \"Type of instructions to show, 'short' or 'long'.\",\n      },\n      instructions: {\n        default: null,\n        type: [\"object\", \"null\"],\n        description:\n          \"When non-null, an InstructionsOptions object that will completely override the built-in instructions.\",\n      },\n      show_quit_button: {\n        type: \"boolean\",\n        default: false,\n        description: \"Should the activity quit button be shown?\",\n      },\n      show_fps: {\n        type: \"boolean\",\n        default: false,\n        description: \"Should the FPS be shown?\",\n      },\n      show_locale_picker: {\n        type: \"boolean\",\n        default: false,\n        description:\n          \"Should the icon that allows the participant to switch the locale be shown?\",\n      },\n    };\n\n    /**\n     * This describes all the data that will be generated by the assessment.\n     * At runtime, when a trial completes, the data will be returned to the\n     * session with a callback, along with this schema transformed into\n     * JSON Schema.\n     */\n    const gridMemoryTrialSchema: TrialSchema = {\n      activity_begin_iso8601_timestamp: {\n        type: \"string\",\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the beginning of the game activity.\",\n      },\n      trial_begin_iso8601_timestamp: {\n        type: [\"string\", \"null\"],\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the beginning of the trial. Null if trial was skipped.\",\n      },\n      trial_end_iso8601_timestamp: {\n        type: [\"string\", \"null\"],\n        format: \"date-time\",\n        description:\n          \"ISO 8601 timestamp at the end of the trial (when user presses 'Done' after placing the three objects). Null if trial was skipped.\",\n      },\n      trial_index: {\n        type: [\"integer\", \"null\"],\n        description: \"Index of the trial within this assessment, 0-based.\",\n      },\n      response_time_duration_ms: {\n        type: [\"number\", \"null\"],\n        description:\n          \"Milliseconds from the when the empty grid is shown in the recall phase until the user has placed all dots and taps the done button. Null if trial was skipped.\",\n      },\n      presented_cells: {\n        type: [\"array\", \"null\"],\n        description:\n          \"Randomly chosen locations of the dots presented to the user. Null if trial was skipped.\",\n        items: {\n          type: \"object\",\n          properties: {\n            row: {\n              type: \"integer\",\n              description: \"Row of the cell, 0-indexed.\",\n            },\n            column: {\n              type: \"integer\",\n              description: \"Column of the cell, 0-indexed.\",\n            },\n          },\n        },\n      },\n      selected_cells: {\n        type: [\"array\", \"null\"],\n        description:\n          \"User selected locations of the dots. Null if trial was skipped.\",\n        items: {\n          type: \"object\",\n          properties: {\n            row: {\n              type: \"integer\",\n              description: \"Row of the cell, 0-indexed.\",\n            },\n            column: {\n              type: \"integer\",\n              description: \"Column of the cell, 0-indexed.\",\n            },\n          },\n        },\n      },\n      user_dot_actions: {\n        type: [\"array\", \"null\"],\n        description:\n          \"Complete user dot actions: placement, removal, and done. Null if trial was skipped.\",\n        items: {\n          type: \"object\",\n          properties: {\n            elapsed_duration_ms: {\n              type: \"number\",\n              description:\n                \"Duration, milliseconds, from when dot recall scene fully appeared until this user action.\",\n            },\n            action_type: {\n              type: \"string\",\n              enum: [\"placed\", \"removed\", \"done\"],\n              description:\n                \"Was the action a dot placement, dot removal, or done button push?\",\n            },\n            cell: {\n              type: [\"object\", \"null\"],\n              description:\n                \"Cell of user action; null if non-applicable (user action was done button push).\",\n              properties: {\n                row: {\n                  type: \"integer\",\n                  description: \"Row of the cell, 0-indexed.\",\n                },\n                column: {\n                  type: \"integer\",\n                  description: \"Column of the cell, 0-indexed.\",\n                },\n                tap_x: {\n                  type: \"number\",\n                  description:\n                    \"X coordinate of user's tap on the cell, relative to the cell.\",\n                },\n                tap_y: {\n                  type: \"number\",\n                  description:\n                    \"Y coordinate of user's tap on the cell, relative to the cell.\",\n                },\n              },\n            },\n          },\n        },\n      },\n      user_interference_actions: {\n        type: [\"array\", \"null\"],\n        description:\n          \"User actions tapping the interference targets. Null if trial was skipped.\",\n        items: {\n          type: \"object\",\n          properties: {\n            elapsed_duration_ms: {\n              type: \"number\",\n              description:\n                \"Duration, milliseconds, from when interference scene fully appeared until this user action.\",\n            },\n            action_type: {\n              type: \"string\",\n              enum: [\"on-target\", \"off-target\"],\n              description: \"Was the action on an interference target or off?\",\n            },\n            cell: {\n              type: \"object\",\n              description: \"Cell of user interference action.\",\n              properties: {\n                row: {\n                  type: \"integer\",\n                  description: \"Row of the cell, 0-indexed.\",\n                },\n                column: {\n                  type: \"integer\",\n                  description: \"Column of the cell, 0-indexed.\",\n                },\n                tap_x: {\n                  type: \"number\",\n                  description:\n                    \"X coordinate of user's tap on the cell, relative to the cell.\",\n                },\n                tap_y: {\n                  type: \"number\",\n                  description:\n                    \"Y coordinate of user's tap on the cell, relative to the cell.\",\n                },\n              },\n            },\n          },\n        },\n      },\n      number_of_correct_dots: {\n        type: [\"integer\", \"null\"],\n        description:\n          \"Number of dots that were correctly placed. Null if trial was skipped.\",\n      },\n      quit_button_pressed: {\n        type: \"boolean\",\n        description: \"Was the quit button pressed?\",\n      },\n    };\n\n    const translation: Translation = {\n      configuration: {\n        baseLocale: \"en-US\",\n      },\n      \"en-US\": {\n        localeName: \"English\",\n        INSTRUCTIONS_TITLE: \"Grid Memory\",\n        INSTRUCTIONS_TEXT_PAGE_1:\n          \"For this activity, try to remember the location of {{NUMBER_OF_DOTS}} dots.\",\n        INSTRUCTIONS_TEXT_PAGE_2:\n          \"Before placing the {{NUMBER_OF_DOTS}} dots in their location, you will also have to tap some Fs on the screen as quickly as you can.\",\n        INSTRUCTIONS_TEXT_PAGE_3: \"Press START to begin!\",\n        GET_READY: \"GET READY\",\n        REMEMBER_LOCATIONS: \"Remember the dot locations!\",\n        TOUCH_INTERFERENCE: \"Touch the F's!\",\n        DONE_BUTTON_TEXT: \"Done\",\n        WHERE_WERE: \"Where were the dots?\",\n        MUST_SELECT: \"You must select all {{NUMBER_OF_DOTS}} locations!\",\n        START_BUTTON_TEXT: \"START\",\n        NEXT_BUTTON_TEXT: \"Next\",\n        BACK_BUTTON_TEXT: \"Back\",\n        TRIALS_COMPLETE_SCENE_TEXT: \"This activity is complete.\",\n        TRIALS_COMPLETE_SCENE_BUTTON_TEXT: \"OK\",\n      },\n      // cSpell:disable (for VS Code extension, Code Spell Checker)\n      \"es-MX\": {\n        localeName: \"Español\",\n        INSTRUCTIONS_TITLE: \"Memoria de Puntos\",\n        INSTRUCTIONS_TEXT_PAGE_1:\n          \"Para esta actividad, intenta recordar la ubicación de {{NUMBER_OF_DOTS}} puntos.\",\n        INSTRUCTIONS_TEXT_PAGE_2:\n          \"Antes de colocar los {{NUMBER_OF_DOTS}} puntos en su ubicación, también tendrás que tocar las Fs en la pantalla lo más rápido que puedas.\",\n        INSTRUCTIONS_TEXT_PAGE_3: \"Presione COMENZAR para Empezar\",\n        GET_READY: \"PREPÁRESE\",\n        REMEMBER_LOCATIONS: \"Recuerda las ubicaciones de los puntos\",\n        TOUCH_INTERFERENCE: \"¡Toca las Fs!\",\n        DONE_BUTTON_TEXT: \"Listo\",\n        WHERE_WERE: \"¿Dónde estaban los puntos?\",\n        MUST_SELECT:\n          \"¡Debes seleccionar todas las {{NUMBER_OF_DOTS}} ubicaciones!\",\n        START_BUTTON_TEXT: \"COMENZAR\",\n        NEXT_BUTTON_TEXT: \"Siguiente\",\n        BACK_BUTTON_TEXT: \"Atrás\",\n        TRIALS_COMPLETE_SCENE_TEXT: \"Esta actividad está completa.\",\n        TRIALS_COMPLETE_SCENE_BUTTON_TEXT: \"OK\",\n      },\n      \"de-DE\": {\n        localeName: \"Deutsch\",\n        INSTRUCTIONS_TITLE: \"Raster-Gedächtnis\",\n        INSTRUCTIONS_TEXT_PAGE_1:\n          \"In dieser Aufgabe werden {{NUMBER_OF_DOTS}} rote Punkte kurz in einem Raster erscheinen. Ihre Aufgabe ist es, sich ihre Standorte zu merken!\",\n        INSTRUCTIONS_TEXT_PAGE_2:\n          \"Als nächstes werden Sie eine Seite voll mit den Buchstaben E und F sehen, wie auf dem Beispiel unten. Ihre Aufgabe ist es, so schnell wie möglich auf alle F's zu tippen!\",\n        INSTRUCTIONS_TEXT_PAGE_3:\n          \"Sobald das leere Raster erscheint, platzieren Sie die Punkte dort, wo Sie sie zuvor gesehen haben, indem Sie auf die entsprechenden Stellen tippen.\",\n        GET_READY: \"BEREIT MACHEN\",\n        REMEMBER_LOCATIONS: \"Merken Sie sich die Punktpositionen!\",\n        TOUCH_INTERFERENCE: \"Berühren die F's!\",\n        DONE_BUTTON_TEXT: \"Fertig\",\n        WHERE_WERE: \"Wo waren die Punkte?\",\n        MUST_SELECT:\n          \"Sie müssen alle {{NUMBER_OF_DOTS}} Punktpositionen auswählen!\",\n        START_BUTTON_TEXT: \"START\",\n        NEXT_BUTTON_TEXT: \"Weiter\",\n        BACK_BUTTON_TEXT: \"Vorherige\",\n        TRIALS_COMPLETE_SCENE_TEXT: \"Die Aufgabe ist beendet.\",\n        TRIALS_COMPLETE_SCENE_BUTTON_TEXT: \"OK\",\n      },\n      // cSpell:enable\n    };\n\n    const img_default_size = 200;\n    const options: GameOptions = {\n      name: \"Grid Memory\",\n      /**\n       * This id must match the property m2c2kit.assessmentId in package.json\n       */\n      id: \"grid-memory\",\n      publishUuid: \"50ee0af4-d013-408f-a7d1-c8d5c04da920\",\n      version: \"__PACKAGE_JSON_VERSION__\",\n      moduleMetadata: Constants.MODULE_METADATA_PLACEHOLDER,\n      translation: translation,\n      shortDescription:\n        \"Grid Memory is a visuospatial working memory task, \\\nwith delayed free recall. After a brief exposure, and a short distraction \\\nphase, participants report the location of dots on a grid.\",\n      longDescription:\n        'Each trial of the dot memory task consisted of 3 phases: encoding, \\\n  distraction, and retrieval. During the encoding phase, the participant was \\\n  asked to remember the location three red dots appear on a 5 x 5 grid. After \\\n  a 3-second study period, the grid was removed and the distraction phase \\\n  began, during which the participant was required to locate and touch Fs among \\\n  an array of Es. After performing the distraction task for 8 seconds, and \\\n  empty 5 x 5 grid reappeared on the screen and participants were then \\\n  prompted to recall the locations of the 3 dots presented initially and press \\\n  a button labeled \"Done\" after entering their responses to complete the trial. \\\n  Participants completed 2 trials (encoding, distractor, retrieval) with a \\\n  1-second delay between trials. The dependent variable was an error score with \\\n  partial credit given based on the deviation from the correct positions. If \\\n  all dots were recalled in their correct location, the participant received a \\\n  score of zero. In the case of one or more retrieval errors, Euclidean distance \\\n  of the location of the incorrect dot to the correct grid location was \\\n  calculated, with higher scores indicating less accurate placement and poorer \\\n  performance (Siedlecki, 2007). The rationale for our use of this task as an \\\n  indicator of working memory has both an empirical and theoretical basis. \\\n  Previous research (Miyake, Friedman, Rettinger, Shah, & Hegarty, 2001) has \\\n  demonstrated that a similar dotmemory task loaded on a factor representing \\\n  working memory. The authors of this study reasoned that the spatial dot \\\n  memory task placed high demands on controlled attention—a hallmark of working \\\n  memory tasks. Indeed, individual differences in working memory capacity arise \\\n  \"in situations where information needs to be actively maintained or when a \\\n  controlled search of memory is required\" (Unsworth & Engle, 2007, p. 123). \\\n  The ambulatory dot memory task satisfies this requirement by using an \\\n  interference task to prevent rehearsal and produce interference with encoded \\\n  locations, which creates the demand for active maintenance and controlled \\\n  retrieval of previously encoded location during the recall phase. \\\n  SOURCE: Sliwinski, Martin J., Jacqueline A. Mogle, Jinshil Hyun, Elizabeth \\\n  Munoz, Joshua M. Smyth, and Richard B. Lipton. \"Reliability and validity of \\\n  ambulatory cognitive assessments.\" Assessment 25, no. 1 (2018): 14-30.',\n      showFps: defaultParameters.show_fps.default,\n      width: 400,\n      height: 800,\n      trialSchema: gridMemoryTrialSchema,\n      parameters: defaultParameters,\n      fonts: [\n        {\n          fontName: \"roboto\",\n          url: \"fonts/roboto/Roboto-Regular.ttf\",\n        },\n      ],\n      images: [\n        {\n          imageName: \"grid\",\n          height: img_default_size,\n          width: img_default_size,\n          url: \"images/dotmem1_grid.png\",\n        },\n        {\n          imageName: \"fs\",\n          height: img_default_size,\n          width: img_default_size,\n          url: \"images/dotmem2_fs.png\",\n        },\n        {\n          imageName: \"circle-x\",\n          height: 32,\n          width: 32,\n          // the svg is from evericons and is licensed under CC0 1.0\n          // Universal (Public Domain). see https://www.patreon.com/evericons\n          url: \"images/circle-x.svg\",\n        },\n      ],\n    };\n\n    super(options);\n  }\n\n  override async initialize() {\n    await super.initialize();\n    // just for convenience, alias the variable game to \"this\"\n    // (even though eslint doesn't like it)\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const game = this;\n\n    // ==============================================================\n    // variables user actions with dots and interference targets\n\n    interface cell {\n      row: number;\n      column: number;\n    }\n    let presentedCells: cell[];\n    let selectedCells: cell[];\n\n    interface UserAction {\n      elapsed_duration_ms: number;\n      action_type: \"placed\" | \"removed\" | \"done\" | \"on-target\" | \"off-target\";\n      cell: null | {\n        row: number | null;\n        column: number | null;\n        tap_x: number | null;\n        tap_y: number | null;\n      };\n    }\n\n    let userDotActions: UserAction[];\n    let userInterferenceActions: UserAction[];\n\n    const NUMBER_OF_DOTS = game.getParameter<number>(\"number_of_dots\");\n\n    // ==============================================================\n\n    if (game.getParameter<boolean>(\"show_quit_button\")) {\n      const quitSprite = new Sprite({\n        imageName: \"circle-x\",\n        position: { x: 380, y: 20 },\n        isUserInteractionEnabled: true,\n      });\n      game.addFreeNode(quitSprite);\n      quitSprite.onTapDown((e) => {\n        game.removeAllFreeNodes();\n        e.handled = true;\n        const blankScene = new Scene();\n        game.addScene(blankScene);\n        game.presentScene(blankScene);\n        game.addTrialData(\"quit_button_pressed\", true);\n        game.trialComplete();\n        game.cancel();\n      });\n    }\n\n    let localePicker: LocalePicker;\n    if (game.getParameter<boolean>(\"show_locale_picker\")) {\n      localePicker = new LocalePicker();\n      game.addFreeNode(localePicker);\n    }\n\n    // ==============================================================\n    // SCENES: instructions\n\n    let instructionsScenes: Array<Scene>;\n\n    const customInstructions = game.getParameter<InstructionsOptions | null>(\n      \"instructions\",\n    );\n    if (customInstructions) {\n      instructionsScenes = Instructions.create(customInstructions);\n    } else {\n      if (!this.i18n) {\n        throw new Error(\"No i18n object found.\");\n      }\n      instructionsScenes = Instructions.create({\n        instructionScenes: [\n          {\n            title: \"INSTRUCTIONS_TITLE\",\n            text: \"INSTRUCTIONS_TEXT_PAGE_1\",\n            textInterpolation: { NUMBER_OF_DOTS: NUMBER_OF_DOTS.toString() },\n            imageName: \"grid\",\n            imageAboveText: false,\n            imageMarginTop: 12,\n            textFontSize: 24,\n            titleFontSize: 30,\n            textVerticalBias: 0.25,\n            nextButtonText: \"NEXT_BUTTON_TEXT\",\n            backButtonText: \"BACK_BUTTON_TEXT\",\n          },\n          {\n            title: \"INSTRUCTIONS_TITLE\",\n            text: \"INSTRUCTIONS_TEXT_PAGE_2\",\n            textInterpolation: { NUMBER_OF_DOTS: NUMBER_OF_DOTS.toString() },\n            imageName: \"fs\",\n            imageAboveText: false,\n            imageMarginTop: 12,\n            textFontSize: 24,\n            titleFontSize: 30,\n            textVerticalBias: 0.25,\n            nextButtonText: \"NEXT_BUTTON_TEXT\",\n            backButtonText: \"BACK_BUTTON_TEXT\",\n          },\n          {\n            title: \"INSTRUCTIONS_TITLE\",\n            text: \"INSTRUCTIONS_TEXT_PAGE_3\",\n            textFontSize: 24,\n            titleFontSize: 30,\n            textAlignmentMode: LabelHorizontalAlignmentMode.Center,\n            nextButtonText: \"START_BUTTON_TEXT\",\n            nextButtonBackgroundColor: WebColors.Green,\n            backButtonText: \"BACK_BUTTON_TEXT\",\n          },\n        ],\n      });\n    }\n    instructionsScenes[0].onAppear(() => {\n      // in case user quits before starting trial, record the timestamp\n      game.addTrialData(\n        \"activity_begin_iso8601_timestamp\",\n        this.beginIso8601Timestamp,\n      );\n    });\n    game.addScenes(instructionsScenes);\n\n    let forward_into_interference_scene_transition: Transition | undefined;\n    let back_from_interference_scene_transition: Transition | undefined;\n    if (game.getParameter<boolean>(\"interference_transition_animation\")) {\n      forward_into_interference_scene_transition = Transition.slide({\n        direction: TransitionDirection.Left,\n        duration: 500,\n        easing: Easings.sinusoidalInOut,\n      });\n      back_from_interference_scene_transition = Transition.slide({\n        direction: TransitionDirection.Right,\n        duration: 500,\n        easing: Easings.sinusoidalInOut,\n      });\n    }\n\n    // ==============================================================\n    // SCENE: countdown. Show 3 second countdown.\n    const countdownScene = new CountdownScene({\n      milliseconds: 3000,\n      // No message, because we show \"Get Ready\" before each trial\n      text: \"\",\n      zeroDwellMilliseconds: 1000,\n      transition: Transition.none(),\n    });\n    game.addScene(countdownScene);\n\n    // ==============================================================\n    // SCENE: per-trial preparation. Show get ready message, then advance after\n    // XXXX milliseconds (as defined in preparation_duration_ms parameter)\n    const preparationScene = new Scene();\n    game.addScene(preparationScene);\n\n    const getReadyMessage = new Label({\n      text: \"GET_READY\",\n      fontSize: 24,\n      position: { x: 200, y: 400 },\n    });\n    preparationScene.addChild(getReadyMessage);\n\n    preparationScene.onAppear(() => {\n      preparationScene.run(\n        Action.sequence([\n          Action.custom({\n            callback: () => {\n              game.addTrialData(\n                \"activity_begin_iso8601_timestamp\",\n                this.beginIso8601Timestamp,\n              );\n              game.addTrialData(\n                \"trial_begin_iso8601_timestamp\",\n                new Date().toISOString(),\n              );\n            },\n          }),\n          Action.wait({\n            duration: game.getParameter(\"preparation_duration_ms\"),\n          }),\n          Action.custom({\n            callback: () => {\n              game.presentScene(dotPresentationScene);\n            },\n          }),\n        ]),\n      );\n    });\n\n    // ==============================================================\n    // SCENE: Show the dot placement\n    const dotPresentationScene = new Scene();\n    game.addScene(dotPresentationScene);\n\n    const rememberDotsMessage = new Label({\n      text: \"REMEMBER_LOCATIONS\",\n      fontSize: 24,\n      position: { x: 200, y: 150 },\n    });\n    dotPresentationScene.addChild(rememberDotsMessage);\n\n    const presentationGrid = new Grid({\n      size: { width: 300, height: 300 },\n      position: { x: 200, y: 400 },\n      rows: 5,\n      columns: 5,\n      backgroundColor: WebColors.Silver,\n      gridLineColor: WebColors.Black,\n      gridLineWidth: 4,\n    });\n    dotPresentationScene.addChild(presentationGrid);\n\n    dotPresentationScene.onSetup(() => {\n      rememberDotsMessage.hidden = true;\n    });\n\n    dotPresentationScene.onAppear(() => {\n      // randomly choose 3 (NUMBER_OF_DOTS) cells that will have the red dots\n      // on a grid of size 5 rows, 5 columns\n      rememberDotsMessage.hidden = false;\n\n      dotPresentationScene.run(\n        Action.sequence([\n          Action.wait({\n            duration: game.getParameter(\"blank_grid_duration_ms\"),\n          }),\n          Action.custom({\n            callback: () => {\n              presentedCells = RandomDraws.FromGridWithoutReplacement(\n                NUMBER_OF_DOTS,\n                5,\n                5,\n              );\n              for (let i = 0; i < NUMBER_OF_DOTS; i++) {\n                const circle = new Shape({\n                  circleOfRadius: 20,\n                  fillColor: WebColors.Red,\n                  strokeColor: WebColors.Black,\n                  lineWidth: 2,\n                });\n                presentationGrid.addAtCell(\n                  circle,\n                  presentedCells[i].row,\n                  presentedCells[i].column,\n                );\n              }\n            },\n          }),\n          Action.wait({\n            duration: game.getParameter(\"dot_present_duration_ms\"),\n          }),\n          Action.custom({\n            callback: () => {\n              presentationGrid.removeAllGridChildren();\n              rememberDotsMessage.hidden = true;\n              game.presentScene(\n                interferenceScene,\n                forward_into_interference_scene_transition,\n              );\n            },\n          }),\n        ]),\n      );\n    });\n\n    // ==============================================================\n    // SCENE: interference. Ask participant to the touch the Fs\n    const interferenceScene = new Scene();\n    game.addScene(interferenceScene);\n\n    const touchTheFs = new Label({\n      text: \"TOUCH_INTERFERENCE\",\n      fontSize: 24,\n      position: { x: 200, y: 100 },\n    });\n    interferenceScene.addChild(touchTheFs);\n\n    const interferenceGrid = new Grid({\n      size: { width: 300, height: 480 },\n      position: { x: 200, y: 400 },\n      rows: 8,\n      columns: 5,\n      backgroundColor: WebColors.Transparent,\n      gridLineColor: WebColors.Transparent,\n    });\n\n    interferenceScene.addChild(interferenceGrid);\n\n    interferenceScene.onSetup(() => {\n      userInterferenceActions = new Array<UserAction>();\n      // note: we should really start the timer in onAppear, but that can\n      // cause a problem if that user taps a target before the timer starts\n      // TODO: refactor so that the tappability of targets is turned on\n      // only in onAppear\n      Timer.startNew(\"interferenceResponseTime\");\n\n      touchTheFs.hidden = true;\n      ShowInterferenceActivity();\n\n      // Advance to the next recall screen after \"interference_duration_ms\"\n      interferenceScene.run(\n        Action.sequence([\n          Action.wait({\n            duration: game.getParameter(\"interference_duration_ms\"),\n          }),\n          Action.custom({\n            callback: () => {\n              Timer.remove(\"interferenceResponseTime\");\n              game.presentScene(\n                dotRecallScene,\n                back_from_interference_scene_transition,\n              );\n            },\n          }),\n        ]),\n        \"advanceAfterInterference\",\n      );\n\n      // On repeated showings of the grid, we will slide it into view\n      // and slideGridIntoScene = true\n      function ShowInterferenceActivity(slideGridIntoScene = false) {\n        interferenceGrid.removeAllGridChildren();\n        let tappedFCount = 0;\n\n        // randomly choose six cells to have F in them from the grid that\n        // is of size 8 rows and 5 columns\n        const number_of_interference_targets = game.getParameter<number>(\n          \"number_of_interference_targets\",\n        );\n        const FCells = RandomDraws.FromGridWithoutReplacement(\n          number_of_interference_targets,\n          8,\n          5,\n        );\n        for (let i = 0; i < 8; i++) {\n          for (let j = 0; j < 5; j++) {\n            const square = new Shape({\n              rect: { size: { width: 59, height: 59 } },\n              fillColor: WebColors.Transparent,\n            });\n\n            let letterIsF = false;\n            let letter: Label;\n            letter = new Label({ text: \"E\", fontSize: 50 });\n            for (let k = 0; k < number_of_interference_targets; k++) {\n              if (FCells[k].row === i && FCells[k].column === j) {\n                letter = new Label({ text: \"F\", fontSize: 50 });\n                letterIsF = true;\n              }\n            }\n            interface squareUserData {\n              row: number;\n              column: number;\n              tapStatus: number;\n            }\n\n            square.userData = {};\n            (<squareUserData>square.userData).row = i;\n            (<squareUserData>square.userData).column = j;\n\n            if (letterIsF) {\n              // square can be tapped, but yet not tapped\n              (<squareUserData>square.userData).tapStatus = 0;\n            } else {\n              // square cannot be tapped\n              (<squareUserData>square.userData).tapStatus = -1;\n            }\n            square.isUserInteractionEnabled = true;\n            square.onTapDown((e) => {\n              if ((<squareUserData>square.userData).tapStatus === 0) {\n                tappedFCount++;\n                letter.text = \"E\";\n                letter.run(\n                  Action.sequence([\n                    Action.scale({ scale: 1.25, duration: 125 }),\n                    Action.scale({ scale: 1, duration: 125 }),\n                  ]),\n                );\n                // square has been tapped\n                (<squareUserData>square.userData).tapStatus = 1;\n                if (tappedFCount >= number_of_interference_targets) {\n                  // don't allow more taps on this current grid\n                  interferenceGrid.gridChildren.forEach((cell) => {\n                    cell.node.isUserInteractionEnabled = false;\n                  });\n\n                  // show a new interference grid\n                  // but this time, slide it into view\n                  ShowInterferenceActivity(true);\n                }\n                /**\n                 * There is an edge case in which the interference_duration_ms\n                 * has elapsed and we auto-advance to the next scene, but\n                 * then the user taps a target. In that case, the\n                 * \"interferenceResponseTime\" timer has been removed, and thus\n                 * a call to Timer.elapsed() will throw an error.\n                 * To prevent this, check if the timer exists before\n                 * calling Timer.elapsed(). We will not record these user taps,\n                 * but that is OK because we are at or beyond the\n                 * interference_duration_ms duration.\n                 */\n                if (Timer.exists(\"interferenceResponseTime\")) {\n                  userInterferenceActions.push({\n                    elapsed_duration_ms: Timer.elapsed(\n                      \"interferenceResponseTime\",\n                    ),\n                    action_type: \"on-target\",\n                    cell: {\n                      row: (<squareUserData>square.userData).row,\n                      column: (<squareUserData>square.userData).column,\n                      tap_x: e.point.x,\n                      tap_y: e.point.y,\n                    },\n                  });\n                }\n              } else {\n                if (Timer.exists(\"interferenceResponseTime\")) {\n                  userInterferenceActions.push({\n                    elapsed_duration_ms: Timer.elapsed(\n                      \"interferenceResponseTime\",\n                    ),\n                    action_type: \"off-target\",\n                    cell: {\n                      row: (<squareUserData>square.userData).row,\n                      column: (<squareUserData>square.userData).column,\n                      tap_x: e.point.x,\n                      tap_y: e.point.y,\n                    },\n                  });\n                }\n              }\n            });\n\n            interferenceGrid.addAtCell(letter, i, j);\n            interferenceGrid.addAtCell(square, i, j);\n          }\n        }\n\n        if (slideGridIntoScene) {\n          interferenceGrid.position = { x: 200, y: 1040 };\n          interferenceGrid.run(\n            Action.move({ point: { x: 200, y: 400 }, duration: 500 }),\n          );\n        }\n      }\n    });\n\n    interferenceScene.onAppear(() => {\n      touchTheFs.hidden = false;\n    });\n\n    // ==============================================================\n    // SCENE: recall. Ask participant to recall the dot positions\n    const dotRecallScene = new Scene();\n    game.addScene(dotRecallScene);\n\n    const whereDotsMessage = new Label({\n      text: \"WHERE_WERE\",\n      fontSize: 24,\n      position: { x: 200, y: 150 },\n    });\n    dotRecallScene.addChild(whereDotsMessage);\n\n    const recallGrid = new Grid({\n      size: { width: 300, height: 300 },\n      position: { x: 200, y: 400 },\n      rows: 5,\n      columns: 5,\n      backgroundColor: WebColors.Silver,\n      gridLineColor: WebColors.Black,\n      gridLineWidth: 4,\n    });\n    dotRecallScene.addChild(recallGrid);\n\n    let tappedCellCount = 0;\n\n    dotRecallScene.onSetup(() => {\n      // note: we should really start the timer in onAppear, but that can\n      // cause a problem if that user taps a target before the timer starts\n      // TODO: refactor so that the tappability of targets is turned on\n      // only in onAppear\n      Timer.startNew(\"responseTime\");\n\n      recallGrid.removeAllGridChildren();\n      recallDoneButton.hidden = true;\n      whereDotsMessage.hidden = true;\n\n      tappedCellCount = 0;\n      selectedCells = new Array<{\n        row: number;\n        column: number;\n      }>();\n      userDotActions = new Array<UserAction>();\n\n      for (let i = 0; i < 5; i++) {\n        for (let j = 0; j < 5; j++) {\n          const cell = new Shape({\n            // this rectangle will be the hit area for the cell\n            // it's transparent -- we use it only for its hit\n            // area. Make it 59 x 59 (not 60 x 60) to avoid overlap\n            // of hit area on the borders\n            rect: { size: { width: 59, height: 59 } },\n            fillColor: WebColors.Transparent,\n          });\n          // a node's userData is a property we can use to store\n          // anything we want. Here, we use it simply to keep track\n          // of whether the cell has been tapped or not.\n          cell.userData = 0;\n          cell.onTapDown((e) => {\n            if (cell.userData === 0 && tappedCellCount < NUMBER_OF_DOTS) {\n              // cell has not been tapped, and there are not yet\n              // 3 (NUMBER_OF_DOTS) circles placed\n              const circle = new Shape({\n                circleOfRadius: 20,\n                fillColor: WebColors.Red,\n                strokeColor: WebColors.Black,\n                lineWidth: 2,\n              });\n              cell.addChild(circle);\n              cell.userData = 1;\n              tappedCellCount++;\n              selectedCells.push({ row: i, column: j });\n              userDotActions.push({\n                elapsed_duration_ms: Timer.elapsed(\"responseTime\"),\n                action_type: \"placed\",\n                cell: {\n                  row: i,\n                  column: j,\n                  tap_x: e.point.x,\n                  tap_y: e.point.y,\n                },\n              });\n            } else if (cell.userData === 1) {\n              // this cell has been tapped. Remove the circle from here\n              cell.removeAllChildren();\n              cell.userData = 0;\n              tappedCellCount--;\n              // remove this \"untapped\" cell from the recorded data of tapped cells\n              selectedCells = selectedCells.filter(\n                (cell) => !(cell.row === i && cell.column === j),\n              );\n              userDotActions.push({\n                elapsed_duration_ms: Timer.elapsed(\"responseTime\"),\n                action_type: \"removed\",\n                cell: {\n                  row: i,\n                  column: j,\n                  tap_x: e.point.x,\n                  tap_y: e.point.y,\n                },\n              });\n            }\n          });\n          cell.isUserInteractionEnabled = true;\n          recallGrid.addAtCell(cell, i, j);\n        }\n      }\n    });\n\n    dotRecallScene.onAppear(() => {\n      recallDoneButton.hidden = false;\n      whereDotsMessage.hidden = false;\n    });\n\n    const recallDoneButton = new Button({\n      text: \"DONE_BUTTON_TEXT\",\n      position: { x: 200, y: 700 },\n      size: { width: 250, height: 50 },\n    });\n    dotRecallScene.addChild(recallDoneButton);\n\n    // place this warning message on the scene, but hide it\n    // we'll unhide it, if needed.\n    const youMustSelectAllMessage = new Label({\n      text: \"MUST_SELECT\",\n      interpolation: { NUMBER_OF_DOTS: NUMBER_OF_DOTS.toString() },\n      position: { x: 200, y: 600 },\n      hidden: true,\n    });\n    dotRecallScene.addChild(youMustSelectAllMessage);\n\n    recallDoneButton.isUserInteractionEnabled = true;\n    recallDoneButton.onTapDown(() => {\n      const doneButtonElapsedMs = Timer.elapsed(\"responseTime\");\n      userDotActions.push({\n        elapsed_duration_ms: doneButtonElapsedMs,\n        action_type: \"done\",\n        cell: null,\n      });\n\n      if (tappedCellCount < NUMBER_OF_DOTS) {\n        youMustSelectAllMessage.run(\n          Action.sequence([\n            Action.custom({\n              callback: () => {\n                youMustSelectAllMessage.hidden = false;\n              },\n            }),\n            Action.wait({ duration: 3000 }),\n            Action.custom({\n              callback: () => {\n                youMustSelectAllMessage.hidden = true;\n              },\n            }),\n          ]),\n        );\n      } else {\n        Timer.stop(\"responseTime\");\n        Timer.remove(\"responseTime\");\n\n        game.addTrialData(\n          \"trial_end_iso8601_timestamp\",\n          new Date().toISOString(),\n        );\n        game.addTrialData(\"response_time_duration_ms\", doneButtonElapsedMs);\n        game.addTrialData(\"presented_cells\", presentedCells);\n        game.addTrialData(\"selected_cells\", selectedCells);\n        game.addTrialData(\"user_dot_actions\", userDotActions);\n        game.addTrialData(\"user_interference_actions\", userInterferenceActions);\n\n        const cellsEqual = (cell1: cell, cell2: cell): boolean => {\n          return cell1.row === cell2.row && cell1.column === cell2.column;\n        };\n        const numberOfCorrectDots = selectedCells\n          .map((selectedCell) =>\n            presentedCells.some((presentedCell) =>\n              cellsEqual(presentedCell, selectedCell),\n            )\n              ? 1\n              : 0,\n          )\n          .reduce((a: number, b) => a + b, 0);\n        game.addTrialData(\"number_of_correct_dots\", numberOfCorrectDots);\n        game.addTrialData(\"quit_button_pressed\", false);\n        game.addTrialData(\"trial_index\", game.trialIndex);\n        game.trialComplete();\n        if (game.trialIndex === game.getParameter(\"number_of_trials\")) {\n          const nextScreenTransition = Transition.slide({\n            direction: TransitionDirection.Left,\n            duration: 500,\n            easing: Easings.sinusoidalInOut,\n          });\n          if (game.getParameter(\"show_trials_complete_scene\")) {\n            game.presentScene(doneScene, nextScreenTransition);\n          } else {\n            game.end();\n          }\n        } else {\n          game.presentScene(preparationScene);\n        }\n      }\n    });\n\n    // ==============================================================\n    // SCENE: done. Show done message, with a button to exit.\n    const doneScene = new Scene();\n    game.addScene(doneScene);\n\n    const doneSceneText = new Label({\n      text: \"TRIALS_COMPLETE_SCENE_TEXT\",\n      position: { x: 200, y: 400 },\n    });\n    doneScene.addChild(doneSceneText);\n\n    const okButton = new Button({\n      text: \"TRIALS_COMPLETE_SCENE_BUTTON_TEXT\",\n      position: { x: 200, y: 600 },\n    });\n    okButton.isUserInteractionEnabled = true;\n    okButton.onTapDown(() => {\n      // don't allow repeat taps of ok button\n      okButton.isUserInteractionEnabled = false;\n      doneScene.removeAllChildren();\n      game.end();\n    });\n    doneScene.addChild(okButton);\n    doneScene.onSetup(() => {\n      // no need to have cancel button, because we're done\n      game.removeAllFreeNodes();\n    });\n  }\n}\n\nexport { GridMemory };\n"],"names":["cell"],"mappings":"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"}